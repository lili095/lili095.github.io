<!DOCTYPE html>
<html lang="zh" >
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="description" content="">
	<meta name="keywords" content="">
	<title>归档 - 李梓卓的技术专栏</title>
    <link rel="alternate" href="" type="application/atom+xml"/>
	<link rel="shortcut icon" href=""/>
	
<link rel="stylesheet" href="/css/style.css">

	
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
	<div class="main-con">

        <div class="nav cl">
    <ul class="cl nav-list">
        
            <li>
                
                    <a href="/" class="">
                        <i class="fa fa-home"></i> 
                        <span>主页</span>
                    </a>
                
            </li>
        
            <li>
                
                    <a href="/archives/" class="active">
                        <i class=" fa-"></i> 
                        <span>归档</span>
                    </a>
                
            </li>
        
            <li>
                
                    
                    <a href="javascript:void(0)" class="">
                    
                        <i class=" fa-"></i> 
                        <span>关于</span>
                        <span class="drop-flag fa fa-angle-down"></span>
                    </a>
                    <dl>
                        
                            <li>
                                <a href="/about" class="">
                                    <i class=" fa-"></i>
                                    <span>关于本站</span>
                                </a>
                            </li>
                        
                    </dl>
                
            </li>
        
    </ul>
    <ul class="cl nav-tool">
        
            <li>
                <a href="/github">
                    <i class="fa fa-github"></i>
                </a>
            </li>
        
            <li>
                <a href="/mail">
                    <i class="fa fa-envelope"></i>
                </a>
            </li>
        
            <li>
                <a href="/twitter">
                    <i class="fa fa-twitter"></i>
                </a>
            </li>
        
        
        <li>
            <a href="javascript:void(0)" class="nav-search-btn">
                <i class="fa fa-search"></i>
            </a>
        </li>
        
    </ul>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="nav-search"><input type="search" name="q" class="nav-search-input" placeholder="search..."><input type="hidden" name="sitesearch" value="https://lili095.github.io"></form>
</div>

        <header class="top" id="fallEle" style="background-image: url(/imgs/head.jpg)">
    <i class="fa fa-bars" id="media-toggle" style="display: none"></i>
    <div class="top-info cl fadeToBottom">
        <h2 class="site-name"><a href="/">mokusei</a> <small id="type-data">This is a hexo theme</small></h2>
    </div>
</header>

        
<div class="con-wrap fadeToTop archive">
    
    <section class="article-area">
    
        
        
            
                <div class="archive-year"><span class="year-block">2024</span></div>

            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/HTTP协议入门/" title="HTTP协议入门">
                    HTTP协议入门
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/HTTP/">HTTP</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP&#x2F;0.9"></a>一、HTTP&#x2F;0.9</h2><p>HTTP 是基于 TCP&#x2F;IP 协议的<a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html"><strong>应用层协议</strong></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p>
<blockquote>
<pre><code class="hljs http">GET /index.html</code></pre>
</blockquote>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p>
<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>
<blockquote>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
</blockquote>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h2 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP&#x2F;1.0"></a>二、HTTP&#x2F;1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP&#x2F;1.0 版本发布，内容大大增加。</p>
<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p>
<p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.0</span>
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*</code></pre>
</blockquote>
<p>可以看到，这个格式与0.9版有很大变化。</p>
<p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p>
<h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-meta">HTTP/1.0</span> <span class="hljs-number">200</span> OK 
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>137582
<span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT
<span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT
<span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache 0.84

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre>
</blockquote>
<p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p>
<p>下面是一些常见的<code>Content-Type</code>字段的值。</p>
<blockquote>
<ul>
<li>text&#x2F;plain</li>
<li>text&#x2F;html</li>
<li>text&#x2F;css</li>
<li>image&#x2F;jpeg</li>
<li>image&#x2F;png</li>
<li>image&#x2F;svg+xml</li>
<li>audio&#x2F;mp4</li>
<li>video&#x2F;mp4</li>
<li>application&#x2F;javascript</li>
<li>application&#x2F;pdf</li>
<li>application&#x2F;zip</li>
<li>application&#x2F;atom+xml</li>
</ul>
</blockquote>
<p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p>
<p>除了预定义的类型，厂商也可以自定义类型。</p>
<blockquote>
<pre><code class="hljs http">application/vnd.debian.binary-package</code></pre>
</blockquote>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8</code></pre>
</blockquote>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*</code></pre>
</blockquote>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p>
<blockquote>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span>
<span class="hljs-comment">&lt;!-- 等同于 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span></code></pre>
</blockquote>
<h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip
<span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>compress
<span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>deflate</code></pre>
</blockquote>
<p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate</code></pre>
</blockquote>
<h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP&#x2F;1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive</code></pre>
</blockquote>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive</code></pre>
</blockquote>
<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h2 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP&#x2F;1.1"></a>三、HTTP&#x2F;1.1</h2><p>1997年1月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close</code></pre>
</blockquote>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>3495</code></pre>
</blockquote>
<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p>
<p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">“分块传输编码”</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked</code></pre>
</blockquote>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain
<span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked

<span class="language-livecodeserver"><span class="hljs-number">25</span></span>
<span class="language-livecodeserver">This is <span class="hljs-keyword">the</span> data <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> chunk</span>
<span class="language-livecodeserver"></span>
<span class="language-livecodeserver"><span class="hljs-number">1</span>C</span>
<span class="language-livecodeserver"><span class="hljs-keyword">and</span> this is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-literal">one</span></span>
<span class="language-livecodeserver"></span>
<span class="language-livecodeserver"><span class="hljs-number">3</span></span>
<span class="language-livecodeserver">con</span>
<span class="language-livecodeserver"></span>
<span class="language-livecodeserver"><span class="hljs-number">8</span></span>
<span class="language-livecodeserver">sequence</span>
<span class="language-livecodeserver"></span>
<span class="language-livecodeserver"><span class="hljs-number">0</span></span></code></pre>
</blockquote>
<h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p>
<p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p>
<blockquote>
<pre><code class="hljs http"><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com</code></pre>
</blockquote>
<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">“队头堵塞”</a>（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。</p>
<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承。</p>
<h2 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP&#x2F;2"></a>五、HTTP&#x2F;2</h2><p>2015年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3。</p>
<h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP&#x2F;1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP&#x2F;2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP&#x2F;2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP&#x2F;2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<p>- </p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/Markdown语法/" title="Markdown语法">
                    Markdown语法
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Markdown/">Markdown</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="0-使用markdown的第0步"><a href="#0-使用markdown的第0步" class="headerlink" title="0.使用markdown的第0步"></a>0.使用markdown的第0步</h2><p>在使用markdown时，要使用半角标点（即中文符号），使用CTRL＋＂＋＂进行全半角切换。</p>
<h2 id="1-标题【多个“-”-空格注意要前置】"><a href="#1-标题【多个“-”-空格注意要前置】" class="headerlink" title="1.标题【多个“#” +空格	注意要前置】"></a>1.标题【多个“#” +空格	注意要前置】</h2><p>另外，在开启严格模式的情况下，要在打完“#”后加上空格。</p>
<h2 id="2-强调（用“-”或“-”包围）"><a href="#2-强调（用“-”或“-”包围）" class="headerlink" title="2. 强调（用“**”或“__”包围）"></a>2. 强调（用“**”或“__”包围）</h2><p><strong>这是一段强调文字</strong>	<strong>这也是强调文字</strong></p>
<p>或者按下<strong>ctrl+b</strong></p>
<h2 id="3-斜体（用”-“或”-”包围）"><a href="#3-斜体（用”-“或”-”包围）" class="headerlink" title="3.斜体（用”*“或”_”包围）"></a>3.斜体（用”*“或”_”包围）</h2><h2 id="4-删除线（用-包围）"><a href="#4-删除线（用-包围）" class="headerlink" title="4.删除线（用~~包围）"></a>4.删除线（用~~包围）</h2><p><del>这是删除文字</del></p>
<h2 id="5-高亮（用-包围）"><a href="#5-高亮（用-包围）" class="headerlink" title="5.高亮（用&#x3D;&#x3D;包围）"></a>5.高亮（用&#x3D;&#x3D;包围）</h2><p>&#x3D;&#x3D;注意：这个很少有软件适配&#x3D;&#x3D;</p>
<h2 id="6-代码（用”-”包围，只有用英文能够打出）"><a href="#6-代码（用”-”包围，只有用英文能够打出）" class="headerlink" title="6.代码（用”&#96;”包围，只有用英文能够打出）"></a>6.代码（用”&#96;”包围，只有用英文能够打出）</h2><p><code>print(&#39;hello,world!&#39;)</code></p>
<h2 id="7-代码块（用”-”包围，只有用英文能够打出）"><a href="#7-代码块（用”-”包围，只有用英文能够打出）" class="headerlink" title="7.代码块（用”&#96;&#96;&#96;”包围，只有用英文能够打出）"></a>7.代码块（用”&#96;&#96;&#96;”包围，只有用英文能够打出）</h2><pre><code class="hljs c">​```
<span class="hljs-comment">// 这里就可以开始输入你要的代码了</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-built_in">printf</span> (“Hello, world!\n<span class="hljs-string">&quot;);</span>
<span class="hljs-string">    retrun 0;</span>
<span class="hljs-string">&#125;</span>
<span class="hljs-string">​``` // (这三个&quot;</span>`<span class="hljs-string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></code></pre>

<h2 id="8-引用-“-”-空格-前置"><a href="#8-引用-“-”-空格-前置" class="headerlink" title="8.引用 [“&gt;” + 空格 前置]"></a>8.引用 [“&gt;” + 空格 前置]</h2><blockquote>
<p>引用1：鲁迅曾经说过…</p>
<p>鲁迅干的事关我周树人什么事？</p>
</blockquote>
<h2 id="9-无序列表-“-“-或-“-”-空格-前置"><a href="#9-无序列表-“-“-或-“-”-空格-前置" class="headerlink" title="9.无序列表 [“-“ 或 “+” + 空格 前置]"></a>9.无序列表 [“-“ 或 “+” + 空格 前置]</h2><ul>
<li><p>解决问题</p>
</li>
<li><p>是问题的关键</p>
<ul>
<li>按下Tab是子集</li>
<li>按下enter关闭列表</li>
</ul>
</li>
</ul>
<h2 id="10-有序列表-数字-“-”-空格-前置"><a href="#10-有序列表-数字-“-”-空格-前置" class="headerlink" title="10. 有序列表 [数字 + “.” + 空格 前置]"></a>10. 有序列表 [数字 + “.” + 空格 前置]</h2><ol>
<li>公平！</li>
<li>公平1</li>
<li>还是tm的公平！</li>
<li>按下enter关闭列表。</li>
</ol>
<h2 id="11-链接-使用-“-”-“-”-分别包围文本与链接"><a href="#11-链接-使用-“-”-“-”-分别包围文本与链接" class="headerlink" title="11. 链接 [使用 “[ ]” + “( )” 分别包围文本与链接]"></a>11. 链接 [使用 “[ ]” + “( )” 分别包围文本与链接]</h2><p><code>[Python基础课](https://github.com/jackfrued/Python-for-Freshmen-2023/tree/master)</code></p>
<p><a href="https://github.com/jackfrued/Python-for-Freshmen-2023/tree/master">Python基础课</a></p>
<p><a href="https://github.com/jackfrued/Python-100-Days">100天学会Python</a></p>
<p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并 <code>单击鼠标左键</code> 即可跳转.</p>
<h2 id="12-任务列表-“-”-空格-前置"><a href="#12-任务列表-“-”-空格-前置" class="headerlink" title="12.任务列表 [“- [ ]” + 空格 前置]"></a>12.任务列表 [“- [ ]” + 空格 前置]</h2><pre><code class="hljs plaintext">TodoList:
- [ ] 刷B站
- [ ] 写代码
- [x] 起床</code></pre>

<p>TodoList:</p>
<ul>
<li><input disabled="" type="checkbox"> 刷B站</li>
<li><input disabled="" type="checkbox"> 写代码</li>
<li><input checked="" disabled="" type="checkbox"> 起床</li>
</ul>
<h2 id="13-表格-用-“-”-绘制表格边框"><a href="#13-表格-用-“-”-绘制表格边框" class="headerlink" title="13.表格[用 “|” 绘制表格边框]"></a>13.表格[用 “|” 绘制表格边框]</h2><pre><div class="caption"><span>学号 | 姓名  | 年龄 |</span></div><code class="hljs |">| 学号 | 姓名  | 年龄 |
| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)
|114514|田所|24|
|1919810|浩三|25|</code></pre>

<table>
<thead>
<tr>
<th align="left">学号</th>
<th align="center">姓名</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="left">114514</td>
<td align="center">田所</td>
<td align="right">24</td>
</tr>
<tr>
<td align="left">1919810</td>
<td align="center">浩三</td>
<td align="right">25</td>
</tr>
</tbody></table>
<h2 id="14-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#14-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="14.分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>14.分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h2><p>实例：</p>
<hr>
<hr>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/Python标准库初探/" title="Python标准库初探">
                    Python标准库初探
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>Python语言最可爱的地方在于它的标准库和三方库实在是太丰富了，日常开发工作中的很多任务都可以通过这些标准库或者三方库直接解决。下面我们先介绍Python标准库中的一些常用模块，后面的课程中再陆陆续续为大家介绍Python常用三方库的用途和用法。</p>
<h3 id="base64-Base64编解码模块"><a href="#base64-Base64编解码模块" class="headerlink" title="base64 - Base64编解码模块"></a>base64 - Base64编解码模块</h3><p><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的方法。由于$log _{2}64&#x3D;6$，所以Base64以6个比特（二进制位，可以表示0或1）为一个单元，每个单元对应一个可打印字符。对于3字节（24比特）的二进制数据，我们可以将其处理成对应于4个Base64单元，即3个字节可由4个可打印字符来表示。Base64编码可用来作为电子邮件的传输编码，也可以用于其他需要将二进制数据转成文本字符的场景，这使得在XML、JSON、YAML这些文本数据格式中传输二进制内容成为可能。在Base64中的可打印字符包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>，这里一共是62个字符，另外两个可打印符号通常是<code>+</code>和<code>/</code>，<code>=</code>用于在Base64编码最后进行补位。</p>
<p>关于Base64编码的细节，大家可以参考<a href="http://www.ruanyifeng.com/blog/2008/06/base64.html">《Base64笔记》</a>一文，Python标准库中的<code>base64</code>模块提供了<code>b64encode</code>和<code>b64decode</code>两个函数，专门用于实现Base64的编码和解码，下面演示了在<strong>Python的交互式环境</strong>中执行这两个函数的效果。</p>
<pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> base64
<span class="hljs-meta">&gt;&gt;&gt; </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>content = <span class="hljs-string">&#x27;Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base64.b64encode(content.encode())
<span class="hljs-string">b&#x27;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>content = <span class="hljs-string">b&#x27;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base64.b64decode(content).decode()
<span class="hljs-string">&#x27;Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.&#x27;</span></code></pre>

<h3 id="collections-容器数据类型模块"><a href="#collections-容器数据类型模块" class="headerlink" title="collections - 容器数据类型模块"></a>collections - 容器数据类型模块</h3><p><code>collections</code>模块提供了诸多非常好用的数据结构，主要包括：</p>
<ul>
<li><code>namedtuple</code>：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li>
<li><code>deque</code>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而<code>deque</code>底层是双向链表，因此当你需要在头尾添加和删除元素是，<code>deque</code>会表现出更好的性能，渐近时间复杂度为$O(1)$。</li>
<li><code>Counter</code>：<code>dict</code>的子类，键是元素，值是元素的计数，它的<code>most_common()</code>方法可以帮助我们获取出现频率最高的元素。<code>Counter</code>和<code>dict</code>的继承关系我认为是值得商榷的，按照CARP原则，<code>Counter</code>跟<code>dict</code>的关系应该设计为关联关系更为合理。</li>
<li><code>OrderedDict</code>：<code>dict</code>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li>
<li><code>defaultdict</code>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的<code>setdefault()</code>方法，这种做法更加高效。</li>
</ul>
<p>下面是在<strong>Python交互式环境中</strong>使用<code>namedtuple</code>创建扑克牌类的例子。</p>
<pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>Card = namedtuple(<span class="hljs-string">&#x27;Card&#x27;</span>, (<span class="hljs-string">&#x27;suite&#x27;</span>, <span class="hljs-string">&#x27;face&#x27;</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>card1 = Card(<span class="hljs-string">&#x27;红桃&#x27;</span>, <span class="hljs-number">5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>card2 = Card(<span class="hljs-string">&#x27;草花&#x27;</span>, <span class="hljs-number">9</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>card1
Card(suite=<span class="hljs-string">&#x27;红桃&#x27;</span>, face=<span class="hljs-number">5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>card2
Card(suite=<span class="hljs-string">&#x27;草花&#x27;</span>, face=<span class="hljs-number">9</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;card1.suite&#125;</span><span class="hljs-subst">&#123;card1.face&#125;</span>&#x27;</span>)
红桃<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;card2.suite&#125;</span><span class="hljs-subst">&#123;card2.face&#125;</span>&#x27;</span>)
草花<span class="hljs-number">9</span></code></pre>

<p>下面是使用<code>Counter</code>类统计列表中出现次数最多的三个元素的例子。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

words = [
    <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;into&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;into&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>,
    <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;not&#x27;</span>, <span class="hljs-string">&#x27;around&#x27;</span>,
    <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&quot;don&#x27;t&quot;</span>, <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;around&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>,
    <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;into&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&quot;you&#x27;re&quot;</span>, <span class="hljs-string">&#x27;under&#x27;</span>
]
counter = Counter(words)
<span class="hljs-comment"># 打印words列表中出现频率最高的3个元素及其出现次数</span>
<span class="hljs-keyword">for</span> elem, count <span class="hljs-keyword">in</span> counter.most_common(<span class="hljs-number">3</span>):
    <span class="hljs-built_in">print</span>(elem, count)</code></pre>

<h3 id="hashlib-哈希函数模块"><a href="#hashlib-哈希函数模块" class="headerlink" title="hashlib - 哈希函数模块"></a>hashlib - 哈希函数模块</h3><p>哈希函数又称哈希算法或散列函数，是一种为已有的数据创建“数字指纹”（哈希摘要）的方法。哈希函数把数据压缩成摘要，对于相同的输入，哈希函数可以生成相同的摘要（数字指纹），需要注意的是这个过程并不可逆（不能通过摘要计算出输入的内容）。一个优质的哈希函数能够为不同的输入生成不同的摘要，出现哈希冲突（不同的输入产生相同的摘要）的概率极低，<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>、<a href="%5Bhttps://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F%5D(https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)">SHA家族</a>就是这类好的哈希函数。</p>
<blockquote>
<p><strong>说明</strong>：在2011年的时候，RFC 6151中已经禁止将MD5用作密钥散列消息认证码，这个问题不在我们讨论的范围内。</p>
</blockquote>
<p>Python标准库的<code>hashlib</code>模块提供了对哈希函数的封装，通过使用<code>md5</code>、<code>sha1</code>、<code>sha256</code>等类，我们可以轻松的生成“数字指纹”。举一个简单的例子，用户注册时我们希望在数据库中保存用户的密码，很显然我们不能将用户密码直接保存在数据库中，这样可能会导致用户隐私的泄露，所以在数据库中保存用户密码时，通常都会将密码的“指纹”保存起来，用户登录时通过哈希函数计算密码的“指纹”再进行匹配来判断用户登录是否成功。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> hashlib

<span class="hljs-comment"># 计算字符串&quot;123456&quot;的MD5摘要</span>
<span class="hljs-built_in">print</span>(hashlib.md5(<span class="hljs-string">&#x27;123456&#x27;</span>.encode()).hexdigest())

<span class="hljs-comment"># 计算文件&quot;Python-3.7.1.tar.xz&quot;的MD5摘要</span>
hasher = hashlib.md5()
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Python-3.7.1.tar.xz&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:
    data = file.read(<span class="hljs-number">512</span>)
    <span class="hljs-keyword">while</span> data:
        hasher.update(data)
        data = file.read(<span class="hljs-number">512</span>)
<span class="hljs-built_in">print</span>(hasher.hexdigest())</code></pre>

<blockquote>
<p><strong>说明</strong>：很多网站在下载链接的旁边都提供了哈希摘要，完成文件下载后，我们可以计算该文件的哈希摘要并检查它与网站上提供的哈希摘要是否一致（指纹比对）。如果计算出的哈希摘要与网站提供的并不一致，很有可能是下载出错或该文件在传输过程中已经被篡改，这时候就不应该直接使用这个文件。</p>
</blockquote>
<h3 id="heapq-堆排序模块"><a href="#heapq-堆排序模块" class="headerlink" title="heapq - 堆排序模块"></a>heapq - 堆排序模块</h3><p><code>heapq</code>模块实现了堆排序算法，如果希望使用堆排序，尤其是要解决**<code>TopK</code>问题**（从序列中找到K个最大或最小元素），直接使用该模块即可，代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> heapq

list1 = [<span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">99</span>, <span class="hljs-number">87</span>, <span class="hljs-number">63</span>, <span class="hljs-number">58</span>, <span class="hljs-number">78</span>, <span class="hljs-number">88</span>, <span class="hljs-number">92</span>]
<span class="hljs-comment"># 找出列表中最大的三个元素</span>
<span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, list1))
<span class="hljs-comment"># 找出列表中最小的三个元素</span>
<span class="hljs-built_in">print</span>(heapq.nsmallest(<span class="hljs-number">3</span>, list1))

list2 = [
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;IBM&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">91.1</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;AAPL&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">543.22</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;FB&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">21.09</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;HPQ&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">31.75</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;YHOO&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">16.35</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ACME&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">115.65</span>&#125;
]
<span class="hljs-comment"># 找出价格最高的三只股票</span>
<span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, list2, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;price&#x27;</span>]))
<span class="hljs-comment"># 找出持有数量最高的三只股票</span>
<span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, list2, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;shares&#x27;</span>]))</code></pre>

<h3 id="itertools-迭代工具模块"><a href="#itertools-迭代工具模块" class="headerlink" title="itertools - 迭代工具模块"></a>itertools - 迭代工具模块</h3><p><code>itertools</code>可以帮助我们生成各种各样的迭代器，大家可以看看下面的例子。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> itertools

<span class="hljs-comment"># 产生ABCD的全排列</span>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> itertools.permutations(<span class="hljs-string">&#x27;ABCD&#x27;</span>):	
    <span class="hljs-built_in">print</span>(value)

<span class="hljs-comment"># 产生ABCDE的五选三组合</span>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> itertools.combinations(<span class="hljs-string">&#x27;ABCDE&#x27;</span>, <span class="hljs-number">3</span>):	<span class="hljs-comment">#返回 `iterable` 中元素的所有可能排列，长度为 `r`，为3。</span>
    <span class="hljs-built_in">print</span>(value)

<span class="hljs-comment"># 产生ABCD和123的笛卡尔积</span>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>):
    <span class="hljs-built_in">print</span>(value)

<span class="hljs-comment"># 产生ABC的无限循环序列</span>
it = itertools.cycle((<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))</code></pre>

<h3 id="random-随机数和随机抽样模块"><a href="#random-随机数和随机抽样模块" class="headerlink" title="random - 随机数和随机抽样模块"></a>random - 随机数和随机抽样模块</h3><p>这个模块我们之前已经用过很多次了，生成随机数、实现随机乱序和随机抽样，下面是常用函数的列表。</p>
<ul>
<li><code>getrandbits(k)</code>：返回具有<code>k</code>个随机比特位的整数。</li>
<li><code>randrange(start, stop[, step])</code>：从<code>range(start, stop, step)</code> 返回一个随机选择的元素，但实际上并没有构建一个<code>range</code>对象。</li>
<li><code>randint(a, b)</code>：返回随机整数<code>N</code>满足<code>a &lt;= N &lt;= b</code>，相当于<code>randrange(a, b+1)</code>。</li>
<li><code>choice(seq)</code>：从非空序列<code>seq</code>返回一个随机元素。 如果<code>seq</code>为空，则引发<code>IndexError</code>。</li>
<li><code>choices(population, weight=None, *, cum_weights=None, k=1)</code>：从<code>population</code>中选择替换，返回大小为<code>k</code>的元素列表。 如果<code>population</code>为空，则引发<code>IndexError</code>。</li>
<li><code>shuffle(x[, random])</code>：将序列<code>x</code>随机打乱位置。</li>
<li><code>sample(population, k)</code>：返回从总体序列或集合中选择<code>k</code>个不重复元素构造的列表，用于无重复的随机抽样。</li>
<li><code>random()</code>：返回<code>[0.0, 1.0)</code>范围内的下一个随机浮点数。</li>
<li><code>expovariate(lambd)</code>：指数分布。</li>
<li><code>gammavariate(alpha, beta)</code>：伽玛分布。</li>
<li><code>gauss(mu, sigma)</code> &#x2F; <code>normalvariate(mu, sigma)</code>：正态分布。</li>
<li><code>paretovariate(alpha)</code>：帕累托分布。 </li>
<li><code>weibullvariate(alpha, beta)</code>：威布尔分布。</li>
</ul>
<h3 id="os-path-路径操作相关模块"><a href="#os-path-路径操作相关模块" class="headerlink" title="os.path - 路径操作相关模块"></a>os.path - 路径操作相关模块</h3><p><code>os.path</code>模块封装了操作路径的工具函数，如果程序中需要对文件路径做拼接、拆分、获取以及获取文件的存在性和其他属性，这个模块将会非常有帮助，下面为大家罗列一些常用的函数。</p>
<ul>
<li><code>dirname(path)</code>：返回路径<code>path</code>的目录名称。</li>
<li><code>exists(path)</code>：如果<code>path</code>指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。</li>
<li><code>getatime(path)</code> &#x2F; <code>getmtime(path)</code> &#x2F; <code>getctime(path)</code>：返回<code>path</code>的最后访问时间&#x2F;最后修改时间&#x2F;创建时间。</li>
<li><code>getsize(path)</code>：返回<code>path</code>的大小，以字节为单位。如果该文件不存在或不可访问，则抛出<code>OSError</code>异常。</li>
<li><code>isfile(path)</code>：如果<code>path</code>是普通文件，则返回 <code>True</code>。</li>
<li><code>isdir(path)</code>：如果<code>path</code>是目录（文件夹），则返回<code>True</code>。</li>
<li><code>join(path, *paths)</code>：合理地拼接一个或多个路径部分。返回值是<code>path</code>和<code>paths</code>所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。</li>
<li><code>splitext(path)</code>：将路径<code>path</code>拆分为一对，即<code>(root, ext)</code>，使得<code>root + ext == path</code>，其中<code>ext</code>为空或以英文句点开头，且最多包含一个句点。</li>
</ul>
<h3 id="uuid-UUID生成模块"><a href="#uuid-UUID生成模块" class="headerlink" title="uuid - UUID生成模块"></a>uuid - UUID生成模块</h3><p><code>uuid</code>模块可以帮助我们生成全局唯一标识符（Universal Unique IDentity）。该模块提供了四个用于生成UUID的函数，分别是：</p>
<ul>
<li><code>uuid1()</code>：由MAC地址、当前时间戳、随机数生成，可以保证全球范围内的唯一性。</li>
<li><code>uuid3(namespace, name)</code>：通过计算命名空间和名字的MD5哈希摘要（“指纹”）值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字会生成相同的UUID。</li>
<li><code>uuid4()</code>：由伪随机数生成UUID，有一定的重复概率，该概率可以计算出来。</li>
<li><code>uuid5()</code>：算法与<code>uuid3</code>相同，只不过哈希函数用SHA-1取代了MD5。</li>
</ul>
<p>由于<code>uuid4</code>存在概率型重复，那么在真正需要全局唯一标识符的地方最好不用使用它。在分布式环境下，<code>uuid1</code>是很好的选择，因为它能够保证生成ID的全局唯一性。下面是在<strong>Python交互式环境中</strong>使用<code>uuid1</code>函数生成全局唯一标识符的例子。</p>
<pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> uuid
<span class="hljs-meta">&gt;&gt;&gt; </span>uuid.uuid1().<span class="hljs-built_in">hex</span>
<span class="hljs-string">&#x27;622a8334baab11eaaa9c60f81da8d840&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>uuid.uuid1().<span class="hljs-built_in">hex</span>
<span class="hljs-string">&#x27;62b066debaab11eaaa9c60f81da8d840&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>uuid.uuid1().<span class="hljs-built_in">hex</span>
<span class="hljs-string">&#x27;642c0db0baab11eaaa9c60f81da8d840&#x27;</span></code></pre>

<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python标准库中有大量的模块，日常开发中有很多常见的任务在Python标准库中都有封装好的函数或类可供使用，这也是Python这门语言最可爱的地方。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/使用Python操作各类文件/" title="使用Python操作各类文件">
                    使用Python操作各类文件
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="用Python读写CSV文件"><a href="#用Python读写CSV文件" class="headerlink" title="用Python读写CSV文件"></a>用Python读写CSV文件</h2><h3 id="CSV文件介绍"><a href="#CSV文件介绍" class="headerlink" title="CSV文件介绍"></a>CSV文件介绍</h3><p>CSV（Comma Separated Values）全称<strong>逗号分隔值文件</strong>是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，而且很多编程语言中都提供了对读写CSV文件的支持，因此CSV格式在数据处理和数据科学中被广泛应用。</p>
<p>CSV文件有以下特点：</p>
<ol>
<li>纯文本，使用某种字符集（如<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>、<a href="https://zh.wikipedia.org/wiki/GB2312">GB2312</a>）等）；</li>
<li>由一条条的记录组成（典型的是每行一条记录）；</li>
<li>每条记录被分隔符（如逗号、分号、制表符等）分隔为字段（列）；</li>
<li>每条记录都有同样的字段序列。</li>
</ol>
<p>CSV文件可以使用文本编辑器或类似于Excel电子表格这类工具打开和编辑，当使用Excel这类电子表格打开CSV文件时，你甚至感觉不到CSV和Excel文件的区别。很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，这些内容并不是现在要讨论的重点。</p>
<h3 id="将数据写入CSV文件"><a href="#将数据写入CSV文件" class="headerlink" title="将数据写入CSV文件"></a>将数据写入CSV文件</h3><p>现有五个学生三门课程的考试成绩需要保存到一个CSV文件中，要达成这个目标，可以使用Python标准库中的<code>csv</code>模块，该模块的<code>writer</code>函数会返回一个<code>csvwriter</code>对象，通过该对象的<code>writerow</code>或<code>writerows</code>方法就可以将数据写入到CSV文件中，具体的代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">import</span> random

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;scores.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:
    writer = csv.writer(file)
    writer.writerow([<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>])
    names = [<span class="hljs-string">&#x27;关羽&#x27;</span>, <span class="hljs-string">&#x27;张飞&#x27;</span>, <span class="hljs-string">&#x27;赵云&#x27;</span>, <span class="hljs-string">&#x27;马超&#x27;</span>, <span class="hljs-string">&#x27;黄忠&#x27;</span>]
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:
        scores = [random.randrange(<span class="hljs-number">50</span>, <span class="hljs-number">101</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]
        scores.insert(<span class="hljs-number">0</span>, name)
        writer.writerow(scores)</code></pre>

<p>生成的CSV文件的内容。</p>
<pre><code class="hljs plaintext">姓名,语文,数学,英语
关羽,98,86,61
张飞,86,58,80
赵云,95,73,70
马超,83,97,55
黄忠,61,54,87</code></pre>

<p>需要说明的是上面的<code>writer</code>函数，除了传入要写入数据的文件对象外，还可以<code>dialect</code>参数，它表示CSV文件的方言，默认值是<code>excel</code>。除此之外，还可以通过<code>delimiter</code>、<code>quotechar</code>、<code>quoting</code>参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。大家可以尝试将上面第5行代码修改为下面的代码，然后查看生成的CSV文件。</p>
<pre><code class="hljs Python">writer = csv.writer(file, delimiter=<span class="hljs-string">&#x27;|&#x27;</span>, quoting=csv.QUOTE_ALL)</code></pre>

<p>生成的CSV文件的内容。</p>
<pre><code class="hljs plaintext">&quot;姓名&quot;|&quot;语文&quot;|&quot;数学&quot;|&quot;英语&quot;
&quot;关羽&quot;|&quot;88&quot;|&quot;64&quot;|&quot;65&quot;
&quot;张飞&quot;|&quot;76&quot;|&quot;93&quot;|&quot;79&quot;
&quot;赵云&quot;|&quot;78&quot;|&quot;55&quot;|&quot;76&quot;
&quot;马超&quot;|&quot;72&quot;|&quot;77&quot;|&quot;68&quot;
&quot;黄忠&quot;|&quot;70&quot;|&quot;72&quot;|&quot;51&quot;</code></pre>

<h3 id="从CSV文件读取数据"><a href="#从CSV文件读取数据" class="headerlink" title="从CSV文件读取数据"></a>从CSV文件读取数据</h3><p>如果要读取刚才创建的CSV文件，可以使用下面的代码，通过<code>csv</code>模块的<code>reader</code>函数可以创建出<code>csvreader</code>对象，该对象是一个迭代器，可以通过<code>next</code>函数或<code>for-in</code>循环读取到文件中的数据。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> csv

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;scores.csv&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:
    reader = csv.reader(file, delimiter=<span class="hljs-string">&#x27;|&#x27;</span>)
    <span class="hljs-keyword">for</span> data_list <span class="hljs-keyword">in</span> reader:
        <span class="hljs-built_in">print</span>(reader.line_num, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> data_list:
            <span class="hljs-built_in">print</span>(elem, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-built_in">print</span>()</code></pre>

<blockquote>
<p><strong>注意</strong>：上面的代码对<code>csvreader</code>对象做<code>for</code>循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。</p>
</blockquote>
<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>将来如果大家使用Python做数据分析，很有可能会用到名为<code>pandas</code>的三方库，它是Python数据分析的神器之一。<code>pandas</code>中封装了名为<code>read_csv</code>和<code>to_csv</code>的函数用来读写CSV文件，其中<code>read_CSV</code>会将读取到的数据变成一个<code>DataFrame</code>对象，而<code>DataFrame</code>就是<code>pandas</code>库中最重要的类型，它封装了一系列用于数据处理的方法（清洗、转换、聚合等）；而<code>to_csv</code>会将<code>DataFrame</code>对象中的数据写入CSV文件，完成数据的持久化。<code>read_csv</code>函数和<code>to_csv</code>函数远远比原生的<code>csvreader</code>和<code>csvwriter</code>强大。</p>
<h2 id="用Python读写Excel文件"><a href="#用Python读写Excel文件" class="headerlink" title="用Python读写Excel文件"></a>用Python读写Excel文件</h2><h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p>
<p>本章我们继续讲解基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p>
<pre><code class="hljs Bash">pip install openpyxl</code></pre>

<p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code><strong>并不支持操作Office 2007以前版本的</strong>Excel文件。</p>
<h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> datetime

<span class="hljs-keyword">import</span> openpyxl

<span class="hljs-comment"># 加载一个工作簿 ---&gt; Workbook</span>
wb = openpyxl.load_workbook(<span class="hljs-string">&#x27;阿里巴巴2020年股票数据.xlsx&#x27;</span>)
<span class="hljs-comment"># 获取工作表的名字</span>
<span class="hljs-built_in">print</span>(wb.sheetnames)
<span class="hljs-comment"># 获取工作表 ---&gt; Worksheet</span>
sheet = wb.worksheets[<span class="hljs-number">0</span>]
<span class="hljs-comment"># 获得单元格的范围</span>
<span class="hljs-built_in">print</span>(sheet.dimensions)
<span class="hljs-comment"># 获得行数和列数</span>
<span class="hljs-built_in">print</span>(sheet.max_row, sheet.max_column)

<span class="hljs-comment"># 获取指定单元格的值</span>
<span class="hljs-built_in">print</span>(sheet.cell(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>).value)
<span class="hljs-built_in">print</span>(sheet[<span class="hljs-string">&#x27;C3&#x27;</span>].value)
<span class="hljs-built_in">print</span>(sheet[<span class="hljs-string">&#x27;G255&#x27;</span>].value)

<span class="hljs-comment"># 获取多个单元格（嵌套元组）</span>
<span class="hljs-built_in">print</span>(sheet[<span class="hljs-string">&#x27;A2:C5&#x27;</span>])

<span class="hljs-comment"># 读取所有单元格的数据</span>
<span class="hljs-keyword">for</span> row_ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, sheet.max_row + <span class="hljs-number">1</span>):
    <span class="hljs-keyword">for</span> col_ch <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABCDEFG&#x27;</span>:
        value = sheet[<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col_ch&#125;</span><span class="hljs-subst">&#123;row_ch&#125;</span>&#x27;</span>].value
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) == datetime.datetime:
            <span class="hljs-built_in">print</span>(value.strftime(<span class="hljs-string">&#x27;%Y年%m月%d日&#x27;</span>), end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-built_in">int</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;value:&lt;10d&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-built_in">float</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;value:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(value, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
    <span class="hljs-built_in">print</span>()</code></pre>

<blockquote>
<p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xlsx”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p>
</blockquote>
<p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet[&#39;A2:C5&#39;]</code>或<code>sheet[&#39;A2&#39;:&#39;C5&#39;]</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p>
<h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> random

<span class="hljs-keyword">import</span> openpyxl

<span class="hljs-comment"># 第一步：创建工作簿（Workbook）</span>
wb = openpyxl.Workbook()

<span class="hljs-comment"># 第二步：添加工作表（Worksheet）</span>
sheet = wb.active
sheet.title = <span class="hljs-string">&#x27;期末成绩&#x27;</span>

titles = (<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>)
<span class="hljs-keyword">for</span> col_index, title <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(titles):
    sheet.cell(<span class="hljs-number">1</span>, col_index + <span class="hljs-number">1</span>, title)

names = (<span class="hljs-string">&#x27;关羽&#x27;</span>, <span class="hljs-string">&#x27;张飞&#x27;</span>, <span class="hljs-string">&#x27;赵云&#x27;</span>, <span class="hljs-string">&#x27;马超&#x27;</span>, <span class="hljs-string">&#x27;黄忠&#x27;</span>)
<span class="hljs-keyword">for</span> row_index, name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(names):
    sheet.cell(row_index + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, name)
    <span class="hljs-keyword">for</span> col_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>):
        sheet.cell(row_index + <span class="hljs-number">2</span>, col_index, random.randrange(<span class="hljs-number">50</span>, <span class="hljs-number">101</span>))

<span class="hljs-comment"># 第四步：保存工作簿</span>
wb.save(<span class="hljs-string">&#x27;考试成绩表.xlsx&#x27;</span>)</code></pre>

<h4 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h4><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> openpyxl
<span class="hljs-keyword">from</span> openpyxl.styles <span class="hljs-keyword">import</span> Font, Alignment, Border, Side

<span class="hljs-comment"># 对齐方式</span>
alignment = Alignment(horizontal=<span class="hljs-string">&#x27;center&#x27;</span>, vertical=<span class="hljs-string">&#x27;center&#x27;</span>)
<span class="hljs-comment"># 边框线条</span>
side = Side(color=<span class="hljs-string">&#x27;ff7f50&#x27;</span>, style=<span class="hljs-string">&#x27;mediumDashed&#x27;</span>)

wb = openpyxl.load_workbook(<span class="hljs-string">&#x27;考试成绩表.xlsx&#x27;</span>)
sheet = wb.worksheets[<span class="hljs-number">0</span>]

<span class="hljs-comment"># 调整行高和列宽</span>
sheet.row_dimensions[<span class="hljs-number">1</span>].height = <span class="hljs-number">30</span>
sheet.column_dimensions[<span class="hljs-string">&#x27;E&#x27;</span>].width = <span class="hljs-number">120</span>

sheet[<span class="hljs-string">&#x27;E1&#x27;</span>] = <span class="hljs-string">&#x27;平均分&#x27;</span>
<span class="hljs-comment"># 设置字体</span>
sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).font = Font(size=<span class="hljs-number">18</span>, bold=<span class="hljs-literal">True</span>, color=<span class="hljs-string">&#x27;ff1493&#x27;</span>, name=<span class="hljs-string">&#x27;华文楷体&#x27;</span>)
<span class="hljs-comment"># 设置对齐方式</span>
sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).alignment = alignment
<span class="hljs-comment"># 设置单元格边框</span>
sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).border = Border(left=side, top=side, right=side, bottom=side)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">7</span>):
    <span class="hljs-comment"># 公式计算每个学生的平均分</span>
    sheet[<span class="hljs-string">f&#x27;E<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>] = <span class="hljs-string">f&#x27;=average(B<span class="hljs-subst">&#123;i&#125;</span>:D<span class="hljs-subst">&#123;i&#125;</span>)&#x27;</span>
    sheet.cell(i, <span class="hljs-number">5</span>).font = Font(size=<span class="hljs-number">12</span>, color=<span class="hljs-string">&#x27;4169e1&#x27;</span>, italic=<span class="hljs-literal">True</span>)
    sheet.cell(i, <span class="hljs-number">5</span>).alignment = alignment

wb.save(<span class="hljs-string">&#x27;考试成绩表.xlsx&#x27;</span>)</code></pre>

<h3 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h3><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook
<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> BarChart, Reference

wb = Workbook(write_only=<span class="hljs-literal">True</span>)
sheet = wb.create_sheet()

rows = [
    (<span class="hljs-string">&#x27;类别&#x27;</span>, <span class="hljs-string">&#x27;销售A组&#x27;</span>, <span class="hljs-string">&#x27;销售B组&#x27;</span>),
    (<span class="hljs-string">&#x27;手机&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>),
    (<span class="hljs-string">&#x27;平板&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>),
    (<span class="hljs-string">&#x27;笔记本&#x27;</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>),
    (<span class="hljs-string">&#x27;外围设备&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>),
]

<span class="hljs-comment"># 向表单中添加行</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:
    sheet.append(row)

<span class="hljs-comment"># 创建图表对象</span>
chart = BarChart()
chart.<span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;col&#x27;</span>
chart.style = <span class="hljs-number">10</span>
<span class="hljs-comment"># 设置图表的标题</span>
chart.title = <span class="hljs-string">&#x27;销售统计图&#x27;</span>
<span class="hljs-comment"># 设置图表纵轴的标题</span>
chart.y_axis.title = <span class="hljs-string">&#x27;销量&#x27;</span>
<span class="hljs-comment"># 设置图表横轴的标题</span>
chart.x_axis.title = <span class="hljs-string">&#x27;商品类别&#x27;</span>
<span class="hljs-comment"># 设置数据的范围</span>
data = Reference(sheet, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">5</span>, max_col=<span class="hljs-number">3</span>)
<span class="hljs-comment"># 设置分类的范围</span>
cats = Reference(sheet, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">5</span>)
<span class="hljs-comment"># 给图表添加数据</span>
chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)
<span class="hljs-comment"># 给图表设置分类</span>
chart.set_categories(cats)
chart.shape = <span class="hljs-number">4</span>
<span class="hljs-comment"># 将图表添加到表单指定的单元格中</span>
sheet.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)

wb.save(<span class="hljs-string">&#x27;demo.xlsx&#x27;</span>)</code></pre>

<p>运行上面的代码，打开生成的Excel文件，效果如下图所示。</p>
<img src="https://github.com/jackfrued/mypic/raw/master/20210819235009.png" alt="image-20210819235009026" width="75%">

<h3 id="简单的总结-1"><a href="#简单的总结-1" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/函数的应用/" title="函数的应用">
                    函数的应用
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>设计一个生成随机验证码的函数，验证码由数字和英文大小写字母构成，长度可以通过参数设置。</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> string

ALL_CHARS = string.digits + string.ascii_letters


<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_code</span>(<span class="hljs-params">*, code_len=<span class="hljs-number">4</span></span>):	<span class="hljs-comment"># *后面的参数是命名关键字参数</span>
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    生成指定长度的验证码</span>
<span class="hljs-string">    :param code_len: 验证码的长度(默认4个字符)</span>
<span class="hljs-string">    :return: 由大小写英文字母和数字构成的随机验证码字符串</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(random.choices(ALL_CHARS, k=code_len))</code></pre>

<blockquote>
<p><strong>说明1</strong>：<code>string</code>模块的<code>digits</code>代表0到9的数字构成的字符串<code>&#39;0123456789&#39;</code>，<code>string</code>模块的<code>ascii_letters</code>代表大小写英文字母构成的字符串<code>&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code>。</p>
<p><strong>说明2</strong>：<code>random</code>模块的<code>sample</code>和<code>choices</code>函数都可以实现随机抽样，<code>sample</code>实现无放回抽样，这意味着抽样取出的元素是不重复的；<code>choices</code>实现有放回抽样，这意味着可能会重复选中某些元素。这两个函数的第一个参数代表抽样的总体，而参数<code>k</code>代表样本容量，需要说明的是<code>choices</code>函数的参数<code>k</code>是一个命名关键字参数，在传参时必须指定参数名。</p>
</blockquote>
<p>可以用下面的代码生成5组随机验证码来测试上面的函数。</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    <span class="hljs-built_in">print</span>(generate_code())</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">59tZ
QKU5
izq8
IBBb
jIfX</code></pre>



<p>或者</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    <span class="hljs-built_in">print</span>(generate_code(code_len=<span class="hljs-number">6</span>))</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">FxJucw
HS4H9G
0yyXfz
x7fohf
ReO22w</code></pre>

<blockquote>
<p><strong>说明</strong>：我们设计的<code>generate_code</code>函数的参数是命名关键字参数，由于它有默认值，可以不给它传值，使用默认值4。如果需要给函数传入参数，必须指定参数名<code>code_len</code>。</p>
</blockquote>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>设计一个判断给定的大于1的正整数是不是质数的函数。质数是只能被1和自身整除的正整数（大于1），如果一个大于1的正整数$N$是质数，那就意味着在2到$N-1$之间都没有它的因子。</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    判断一个正整数是不是质数</span>
<span class="hljs-string">    :param num: 大于1的正整数</span>
<span class="hljs-string">    :return: 如果num是质数返回True，否则返回False</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(num ** <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):		<span class="hljs-comment">#num ** 0.5为float格式，会报错，要改为int格式</span>
        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>

<blockquote>
<p><strong>说明1</strong>：上面<code>is_prime</code>函数的参数<code>num</code>后面的<code>: int</code>用来标注参数的类型，虽然<strong>它对代码的执行结果不产生任何影响</strong>，但是很好的增强了代码的可读性。同理，参数列表后面的<code>-&gt; bool</code>用来标注函数返回值的类型，它<strong>也不会对代码的执行结果产生影响</strong>，但是却让我们清楚的知道，调用函数会得到一个布尔值，要么是<code>True</code>，要么是<code>False</code>。</p>
<p><strong>说明2</strong>：上面的循环并不需要从2循环到$\small{N-1}$，因为如果循环进行到$\small{\sqrt{N}}$时，还没有找到$\small{N}$的因子，那么$\small{\sqrt{N}}$之后也不会出现$\small{N}$的因子，大家可以自己想一想这是为什么。</p>
</blockquote>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>设计计算两个正整数最大公约数和最小公倍数的函数。$x$和$y$的最大公约数是能够同时整除$x$和$y$的最大整数，如果$x$和$y$互质，那么它们的最大公约数为1；$x$和$y$的最小公倍数是能够同时被$x$和$y$整除的最小正整数，如果$x$和$y$互质，那么它们的最小公倍数为$x \times y$。需要提醒大家注意的是，计算最大公约数和最小公倍数是两个不同的功能，应该设计成两个函数，而不是把两个功能放到同一个函数中。</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot;求最小公倍数&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> x * y // gcd(x, y)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot;求最大公约数&quot;&quot;&quot;</span>
    <span class="hljs-keyword">while</span> y % x != <span class="hljs-number">0</span>:
        x, y = y % x, x
    <span class="hljs-keyword">return</span> x</code></pre>

<blockquote>
<p><strong>说明1</strong>：函数之间可以相互调用，上面求最小公倍数的<code>lcm</code>函数就调用了求最大公约数的<code>gcd</code>函数，通过$\frac{x \times y}{ gcd(x, y)}$来计算最小公倍数。</p>
<p><strong>说明2</strong>：上面的<code>gcd</code>（自己定义的）函数使用了欧几里得算法计算最大公约数，欧几里得算法也称为辗转相除法，这个算法通常有更好的执行效率，不了解的小伙伴可以自行科普。</p>
</blockquote>
<h3 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h3><p>假设样本数据保存一个列表中，设计计算样本数据描述性统计信息的函数。描述性统计信息通常包括：算术平均值、中位数、极差（最大值和最小值的差）、方差、标准差、变异系数等，计算公式如下所示：</p>
<p>样本均值（sample mean）： $$ \bar{x} &#x3D; \frac{\sum_{i&#x3D;1}^{n}x_{i}}{n} &#x3D; \frac{x_{1}+x_{2}+\cdots +x_{n}}{n} $$ 样本方差（sample variance）： $$ s^2 &#x3D; \frac {\sum_{i&#x3D;1}^{n}(x_i - \bar{x})^2} {n-1} $$ 样本标准差（sample standard deviation）： $$ s &#x3D; \sqrt{\frac{\sum_{i&#x3D;1}^{n}(x_i - \bar{x})^2}{n-1}} $$ 变异系数（coefficient of sample variation）： $$ CV &#x3D; \frac{s}{\bar{x}} $$</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ptp</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;极差（全距）&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(data) - <span class="hljs-built_in">min</span>(data)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">mean</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;算术平均&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(data) / <span class="hljs-built_in">len</span>(data)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;中位数&quot;&quot;&quot;</span>
    temp, size = <span class="hljs-built_in">sorted</span>(data), <span class="hljs-built_in">len</span>(data)
    <span class="hljs-keyword">if</span> size % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> temp[size // <span class="hljs-number">2</span>]
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> mean(temp[size // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>:size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>])


<span class="hljs-keyword">def</span> <span class="hljs-title function_">var</span>(<span class="hljs-params">data, ddof=<span class="hljs-number">1</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;方差&quot;&quot;&quot;</span>
    x_bar = mean(data)
    temp = [(num - x_bar) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data]
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(temp) / (<span class="hljs-built_in">len</span>(temp) - ddof)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">std</span>(<span class="hljs-params">data, ddof=<span class="hljs-number">1</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;标准差&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> var(data, ddof) ** <span class="hljs-number">0.5</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">cv</span>(<span class="hljs-params">data, ddof=<span class="hljs-number">1</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;变异系数&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> std(data, ddof) / mean(data)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">describe</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;输出描述性统计信息&quot;&quot;&quot;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;均值: <span class="hljs-subst">&#123;mean(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中位数: <span class="hljs-subst">&#123;median(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;极差: <span class="hljs-subst">&#123;ptp(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差: <span class="hljs-subst">&#123;var(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差: <span class="hljs-subst">&#123;std(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;变异系数: <span class="hljs-subst">&#123;cv(data)&#125;</span>&#x27;</span>)</code></pre>

<blockquote>
<p><strong>说明1</strong>：中位数是将数据按照升序或降序排列后位于中间的数，它描述了数据的中等水平。中位数的计算分两种情况：当数据体量$n$为奇数时，中位数是位于$\frac{n + 1}{2}$位置的元素；当数据体量$n$为偶数时，中位数是位于$\frac{n}{2}$和$\frac{n}{2} + 1$两个位置元素的均值。</p>
<p><strong>说明2</strong>：计算方差和标准差的函数中有一个名为<code>ddof</code>的参数，它代表了可以调整的自由度，默认值为1。在计算样本方差和样本标准差时，需要进行自由度校正；如果要计算总体方差和总体标准差，可以将<code>ddof</code>参数赋值为0，即不需要进行自由度校正。</p>
<p><strong>说明3</strong>：<code>describe</code>函数将上面封装好的统计函数组装到一起，用于输出数据的描述性统计信息。事实上，Python 标准库中有一个名为<code>statistics</code>的模块，它已经把获取描述性统计信息的函数封装好了，有兴趣的读者可以自行了解。</p>
</blockquote>
<h3 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h3><p>我们用函数重构之前讲过的双色球随机选号的例子，将生成随机号码和输出一组号码的功能分别封装到两个函数中，然后通过调用函数实现机选<code>N</code>注号码的功能。</p>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">双色球随机选号程序</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">import</span> random

RED_BALLS = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">34</span>)]
BLUE_BALLS = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">17</span>)]


<span class="hljs-keyword">def</span> <span class="hljs-title function_">choose</span>():
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    生成一组随机号码</span>
<span class="hljs-string">    :return: 保存随机号码的列表</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    selected_balls = random.sample(RED_BALLS, <span class="hljs-number">6</span>)
    selected_balls.sort()
    selected_balls.append(random.choice(BLUE_BALLS))	<span class="hljs-comment">#从蓝色球列表中随机抽出1个蓝色球</span>
    <span class="hljs-keyword">return</span> selected_balls


<span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">balls</span>):
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    格式输出一组号码</span>
<span class="hljs-string">    :param balls: 保存随机号码的列表</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">for</span> ball <span class="hljs-keyword">in</span> balls[:-<span class="hljs-number">1</span>]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[031m<span class="hljs-subst">&#123;ball:<span class="hljs-number">0</span>&gt;2d&#125;</span>\033[0m&#x27;</span>, end=<span class="hljs-string">&#x27; &#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[034m<span class="hljs-subst">&#123;balls[-<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>&gt;2d&#125;</span>\033[0m&#x27;</span>)


n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;生成几注号码: &#x27;</span>))
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
    display(choose())</code></pre>



<blockquote>
<p><strong>说明</strong>：大家看看<code>display(choose())</code>这行代码，这里我们先通过<code>choose</code>函数获得一组随机号码，然后把<code>choose</code>函数的返回值作为<code>display</code>函数的参数，通过<code>display</code>函数将选中的随机号码显示出来。重构之后的代码逻辑非常清晰，代码的可读性更强了。如果有人为你封装了这两个函数，你仅仅是函数的调用者，其实你根本不用关心<code>choose</code>函数和<code>display</code>函数的内部实现，你只需要知道调用<code>choose</code>函数可以生成一组随机号码，而调用<code>display</code>函数传入一个列表，就可以输出这组号码。将来我们使用各种各样的 Python 三方库时，我们也根本不关注它们的底层实现，我们需要知道的仅仅是调用哪个函数可以解决问题。</p>
</blockquote>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/XML快速入门/" title="XML入门">
                    XML入门
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Xml/">Xml</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="什么是-XML？"><a href="#什么是-XML？" class="headerlink" title="什么是 XML？"></a>什么是 XML？</h2><ul>
<li>XML 指可扩展标记语言（EXtensible Markup Language）。</li>
<li>XML 是一种很像HTML的标记语言。</li>
<li>XML 的设计宗旨是传输数据，而不是显示数据。</li>
<li>XML 标签没有被预定义。您需要自行定义标签。</li>
<li>XML 被设计为具有自我描述性。</li>
<li>XML 是 W3C 的推荐标准。</li>
</ul>
<hr>
<h2 id="XML-和-HTML-之间的差异"><a href="#XML-和-HTML-之间的差异" class="headerlink" title="XML 和 HTML 之间的差异"></a>XML 和 HTML 之间的差异</h2><p>XML 不是 HTML 的替代。</p>
<p>XML 和 HTML 为不同的目的而设计：</p>
<ul>
<li>XML 被设计用来传输和存储数据，其焦点是数据的内容。</li>
<li>HTML 被设计用来显示数据，其焦点是数据的外观。</li>
</ul>
<p>HTML 旨在显示信息，而 XML 旨在传输信息。</p>
<hr>
<h2 id="XML-不会做任何事情"><a href="#XML-不会做任何事情" class="headerlink" title="XML 不会做任何事情"></a>XML 不会做任何事情</h2><p>也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。</p>
<p>下面实例是 Jani 写给 Tove 的便签，存储为 XML：</p>
<p><note> <to>Tove</to> <from>Jani</from> <heading>Reminder</heading> <body>Don’t forget me this weekend!</body> </note></p>
<p>上面的这条便签具有自我描述性。它包含了发送者和接受者的信息，同时拥有标题以及消息主体。</p>
<p>但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</p>
<hr>
<h2 id="通过-XML-您可以发明自己的标签"><a href="#通过-XML-您可以发明自己的标签" class="headerlink" title="通过 XML 您可以发明自己的标签"></a>通过 XML 您可以发明自己的标签</h2><p>上面实例中的标签没有在任何 XML 标准中定义过（比如 <to> 和 <from>）。这些标签是由 XML 文档的创作者发明的。</p>
<p>这是因为 XML 语言没有预定义的标签。</p>
<p>HTML 中使用的标签都是预定义的。HTML 文档只能使用在 HTML 标准中定义过的标签（如 <p>、<h1> 等等）。</p>
<p>XML 允许创作者定义自己的标签和自己的文档结构。</p>
<hr>
<h2 id="XML-不是对-HTML-的替代"><a href="#XML-不是对-HTML-的替代" class="headerlink" title="XML 不是对 HTML 的替代"></a>XML 不是对 HTML 的替代</h2><p><strong>XML 是对 HTML 的补充。</strong></p>
<p>XML 不会替代 HTML，理解这一点很重要。在大多数 Web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。</p>
<p>对 XML 最好的描述是：</p>
<p><strong>XML 是独立于软件和硬件的信息传输工具。</strong></p>
<h1 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h1><hr>
<p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。</p>
<hr>
<h2 id="一个-XML-文档实例"><a href="#一个-XML-文档实例" class="headerlink" title="一个 XML 文档实例"></a>一个 XML 文档实例</h2><p>XML 文档使用简单的具有自我描述性的语法：</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）。</p>
<p>下一行描述文档的<strong>根元素</strong>（像在说：”本文档是一个便签”）：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>接下来 4 行描述根的 4 个<strong>子元素</strong>（to, from, heading 以及 body）：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>

<p>最后一行定义根元素的结尾：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>您可以假设，从这个实例中，XML 文档包含了一张 Jani 写给 Tove 的便签。</p>
<p>XML 具有出色的自我描述性，您同意吗？</p>
<hr>
<h2 id="XML-文档形成一种树结构"><a href="#XML-文档形成一种树结构" class="headerlink" title="XML 文档形成一种树结构"></a>XML 文档形成一种树结构</h2><p>XML 文档必须包含<strong>根元素</strong>。该元素是所有其他元素的父元素。</p>
<p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p>
<p>所有的元素都可以有子元素：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">subchild</span>&gt;</span>.....<span class="hljs-tag">&lt;/<span class="hljs-name">subchild</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></code></pre>

<p>父、子以及同胞等术语用于描述<strong>元素之间的关系</strong>。父元素拥有子元素。相同层级上的子元素成为<strong>同胞</strong>（兄弟或姐妹）。</p>
<p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p><img src="C:\Users\lili\Desktop\Python_exercise\nodetree.gif" alt="nodetree"></p>
<p>上图表示下面的 XML 中的一本书：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;COOKING&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Giada De Laurentiis<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>30.00<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;CHILDREN&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;WEB&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Erik T. Ray<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2003<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span></code></pre>

<p>实例中的根元素是 <bookstore>，这是整个 XML 文档的根元素，包含所有书籍的集合。所有其他元素都是该根元素的子元素。文档中的所有 <book> 元素都被包含在 <bookstore> 中。</p>
<p>每本书由一个 <code>&lt;book&gt;</code> 元素表示，包含书的详细信息。每个 <code>&lt;book&gt;</code> 元素具有一个 <code>category</code> 属性，表示书籍的类别。例如，第一个 <code>&lt;book&gt;</code> 元素的 <code>category</code> 属性值为 <code>&quot;COOKING&quot;</code>。</p>
<p><book> 元素有 4 个子元素：<title>、<author>、<year>、<price>。每个 <code>&lt;book&gt;</code> 元素包含以下子元素来描述书籍的具体信息：</p>
<ul>
<li><code>&lt;title&gt;</code>：表示书名，具有一个 <code>lang</code> 属性，表示书名的语言。例如，第一个书的书名是 “Everyday Italian”，语言为英语（<code>lang=&quot;en&quot;</code>）。</li>
<li><code>&lt;author&gt;</code>：表示书的作者。例如，第一个书的作者是 Giada De Laurentiis。</li>
<li><code>&lt;year&gt;</code>：表示书的出版年份。例如，第一个书的出版年份是 2005 年。</li>
<li><code>&lt;price&gt;</code>：表示书的价格。例如，第一个书的价格是 30.00 美元。</li>
</ul>
<h1 id="XML-语法规则"><a href="#XML-语法规则" class="headerlink" title="XML 语法规则"></a>XML 语法规则</h1><p>XML 的语法规则很简单，且很有逻辑。</p>
<p>这些规则很容易学习，也很容易使用。</p>
<hr>
<h2 id="XML-声明"><a href="#XML-声明" class="headerlink" title="XML 声明"></a>XML 声明</h2><p>XML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span></code></pre>

<blockquote>
<p>以上实例包含 XML 版本（version&#x3D;”1.0”），甚至包含字符编码（encoding&#x3D;”utf-8”）。</p>
<p>UTF-8 也是 HTML5, CSS, JavaScript, PHP, 和 SQL 的默认编码。</p>
</blockquote>
<hr>
<h2 id="XML-文档必须有根元素"><a href="#XML-文档必须有根元素" class="headerlink" title="XML 文档必须有根元素"></a>XML 文档必须有根元素</h2><p>XML 必须包含根元素，它是所有其他元素的父元素，比如以下实例中 root 就是根元素：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">subchild</span>&gt;</span>.....<span class="hljs-tag">&lt;/<span class="hljs-name">subchild</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></code></pre>

<p>以下实例中 note 是根元素：</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>XML文档由元素构成，每个元素包括开始标签、结束标签和元素内容。</p>
<hr>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>元素可以包含属性，属性提供有关元素的附加信息。</p>
<p>属性位于开始标签中，例如：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">gender</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>John Doe<span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span></code></pre>

<ul>
<li>一个元素可以有多个属性，它的基本格式为：</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">元素名</span> <span class="hljs-attr">属性名1</span>=<span class="hljs-string">&quot;属性值1&quot;</span> <span class="hljs-attr">属性名2</span>=<span class="hljs-string">&quot;属性值2&quot;</span>&gt;</span></code></pre>

<ul>
<li><p>特定的属性名称在同一个元素标记中只能出现一次</p>
</li>
<li><p>属性值不能包括 &lt;,&gt;,&amp;，如果一定要包含，也要使用实体</p>
</li>
</ul>
<hr>
<h2 id="XML-单标签"><a href="#XML-单标签" class="headerlink" title="XML 单标签"></a>XML 单标签</h2><p>所有的 XML 元素一般都有一个关闭标签，但也允许单标签的使用的。</p>
<p>单标签是指在一个标签中同时包含了开始和结束标签，形式类似于HTML中的空元素标签。</p>
<p>在XML中，你可以使用以下两种方式表示单标签：</p>
<p>使用空元素标签：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exampleTag</span> /&gt;</span></code></pre>

<p>使用开始和结束标签，但是不包含任何内容：</p>
<p>这两种表示方式是等效的，你可以根据个人或项目的约定选择使用其中之一。</p>
<p>在许多XML解析器中，它们都会将这两种形式解释为相同的结构。</p>
<hr>
<h2 id="XML-标签对大小写敏感"><a href="#XML-标签对大小写敏感" class="headerlink" title="XML 标签对大小写敏感"></a>XML 标签对大小写敏感</h2><p>XML 标签对大小写敏感。标签 <Letter> 与标签 <letter> 是不同的。</p>
<p>必须使用相同的大小写来编写打开标签和关闭标签：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Message</span>&gt;</span>这是错误的<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>这是正确的<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span></code></pre>

<p><strong>注释：</strong>打开标签和关闭标签通常被称为开始标签和结束标签。不论您喜欢哪种术语，它们的概念都是相同的。</p>
<hr>
<h2 id="XML-必须正确嵌套"><a href="#XML-必须正确嵌套" class="headerlink" title="XML 必须正确嵌套"></a>XML 必须正确嵌套</h2><p>在 HTML 中，常会看到没有正确嵌套的元素：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>This text is bold and italic<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></code></pre>

<p>在 XML 中，所有元素都<strong>必须彼此正确</strong>地嵌套：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>This text is bold and italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></code></pre>

<blockquote>
<p>在上面的实例中，正确嵌套的意思是：由于 <i> 元素是在 <b> 元素内打开的，那么它必须在 <b> 元素内关闭。</p>
</blockquote>
<hr>
<h2 id="XML-属性值必须加引号-关键"><a href="#XML-属性值必须加引号-关键" class="headerlink" title="XML 属性值必须加引号(关键)"></a><strong>XML 属性值必须加引号</strong>(关键)</h2><p>与 HTML 类似，XML 元素也可拥有属性（名称&#x2F;值的对）。</p>
<p>在 XML 中，XML 的属性值必须加引号。</p>
<p>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span> <span class="hljs-attr">date</span>=<span class="hljs-string">12/11/2007</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span> <span class="hljs-attr">date</span>=<span class="hljs-string">&quot;12/11/2007&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p>
<hr>
<h2 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h2><p>在 XML 中，一些字符拥有特殊的意义。</p>
<p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>
<p>这样会产生 XML 错误：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>if salary &lt; 1000 then<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span></code></pre>

<p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>if salary <span class="hljs-symbol">&amp;lt;</span> 1000 then<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span></code></pre>

<p>在 XML 中，有 5 个预定义的实体引用：</p>
<table>
<thead>
<tr>
<th align="center"><code>&amp;lt;</code></th>
<th align="center">&lt;</th>
<th align="center">less than</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;gt;</code></td>
<td align="center">&gt;</td>
<td align="center">greater than</td>
</tr>
<tr>
<td align="center"><code>&amp;amp;</code></td>
<td align="center">&amp;</td>
<td align="center">ampersand</td>
</tr>
<tr>
<td align="center"><code>&amp;apos;</code></td>
<td align="center">‘</td>
<td align="center">apostrophe</td>
</tr>
<tr>
<td align="center"><code>&amp;quot;</code></td>
<td align="center">“</td>
<td align="center">quotation mark</td>
</tr>
</tbody></table>
<blockquote>
<p>在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
</blockquote>
<hr>
<h2 id="XML-中的注释"><a href="#XML-中的注释" class="headerlink" title="XML 中的注释"></a>XML 中的注释</h2><p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- This is a comment /这是一个注释--&gt;</span></code></pre>

<hr>
<h2 id="在-XML-中，空格会被保留"><a href="#在-XML-中，空格会被保留" class="headerlink" title="在 XML 中，空格会被保留"></a>在 XML 中，空格会被保留</h2><p>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
<table>
<thead>
<tr>
<th>HTML:</th>
<th><code>Hello           Tove</code></th>
</tr>
</thead>
<tbody><tr>
<td>输出结果:</td>
<td>Hello Tove</td>
</tr>
</tbody></table>
<p>在 XML 中，文档中的空格不会被删减：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>xx       xxx<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>John Doe<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span></code></pre>

<p>title 内容读取显示如下：</p>
<pre><code class="hljs plaintext">xx       xxx</code></pre>

<hr>
<h2 id="XML-以-LF-存储换行"><a href="#XML-以-LF-存储换行" class="headerlink" title="XML 以 LF 存储换行"></a>XML 以 LF 存储换行</h2><p>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。</p>
<p>在 Unix 和 Mac OSX 中，使用 LF 来存储新行。</p>
<p>在旧的 Mac 系统中，使用 CR 来存储新行。</p>
<p>XML 以 LF 存储换行。</p>
<h1 id="XML-元素"><a href="#XML-元素" class="headerlink" title="XML 元素"></a>XML 元素</h1><h2 id="什么是-XML-元素？"><a href="#什么是-XML-元素？" class="headerlink" title="什么是 XML 元素？"></a>什么是 XML 元素？</h2><p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p>
<p>一个元素可以包含：</p>
<ul>
<li>其他元素</li>
<li>文本</li>
<li>属性</li>
<li>或混合以上所有…</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;CHILDREN&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;WEB&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Erik T. Ray<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2003<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span></code></pre>

<p>在上面的实例中，<bookstore> 和 <book> 都有 <strong>元素内容</strong>，因为他们包含其他元素。<book> 元素也有<strong>属性</strong>（category&#x3D;”CHILDREN”）。<title>、<author>、<year> 和 <price> 有<strong>文本内容</strong>，因为他们包含文本。</p>
<hr>
<h2 id="XML-命名规则"><a href="#XML-命名规则" class="headerlink" title="XML 命名规则"></a>XML 命名规则</h2><p>XML 元素必须遵循以下命名规则：</p>
<ul>
<li>名称可以包含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li>
<li>名称<strong>不能包含空格</strong></li>
</ul>
<p>可使用任何名称，没有保留的字词。</p>
<hr>
<h2 id="最佳命名习惯"><a href="#最佳命名习惯" class="headerlink" title="最佳命名习惯"></a>最佳命名习惯</h2><p>使名称具有描述性。使用下划线的名称也很不错：<first_name>、<last_name>。</p>
<p>名称应简短和简单，比如：<book_title>，而不是：<the_title_of_the_book>。</p>
<p><strong>避免 “-“ 字符。</strong>如果您按照这样的方式进行命名：”first-name”，一些软件会认为您想要从 first 里边减去 name。</p>
<p><strong>避免 “.” 字符。</strong>如果您按照这样的方式进行命名：”first.name”，一些软件会认为 “name” 是对象 “first” 的属性。</p>
<p><strong>避免 “:” 字符。</strong>冒号会被转换为命名空间来使用（稍后介绍）。</p>
<p>XML 文档经常有一个对应的数据库，其中的字段会对应 XML 文档中的元素。有一个实用的经验，即使用数据库的命名规则来命名 XML 文档中的元素。</p>
<p>在 XML 中，éòá 等非英语字母是完全合法的，不过需要留意，您的软件供应商不支持这些字符时可能出现的问题。</p>
<hr>
<h2 id="XML-元素是可扩展的"><a href="#XML-元素是可扩展的" class="headerlink" title="XML 元素是可扩展的"></a>XML 元素是可扩展的</h2><p>XML 元素是可扩展，以携带更多的信息。</p>
<p>请看下面的 XML 实例：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及 <body> 元素从 XML 文档中提取出来，并产生以下的输出：</p>
<pre><code class="hljs tex">MESSAGE
To: Tove
From: Jani

Don&#x27;t forget me this weekend!</code></pre>

<p>想象一下，XML 文档的作者添加的一些额外信息：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">date</span>&gt;</span>2008-01-10<span class="hljs-tag">&lt;/<span class="hljs-name">date</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>那么这个应用程序会中断或崩溃吗？</p>
<p>不会。这个应用程序仍然可以找到 XML 文档中的 <to>、<from> 以及 <body> 元素，并产生同样的输出。</p>
<p>XML 的优势之一，就是可以在不中断应用程序的情况下进行扩展。</p>
<h1 id="XML-属性"><a href="#XML-属性" class="headerlink" title="XML 属性"></a>XML 属性</h1><p>属性（Attribute）提供有关元素的额外信息。</p>
<h2 id="XML-属性-1"><a href="#XML-属性-1" class="headerlink" title="XML 属性"></a>XML 属性</h2><p>在<code> HTML</code> 中，属性提供有关元素的额外信息：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;computer.gif&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;demo.html&quot;</span>&gt;</span></code></pre>

<p>属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">file</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;gif&quot;</span>&gt;</span>computer.gif<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span></code></pre>

<hr>
<h2 id="XML-属性必须加引号"><a href="#XML-属性必须加引号" class="headerlink" title="XML 属性必须加引号"></a>XML 属性必须加引号</h2><p><strong>属性值必须被引号包围</strong>，不过单引号和双引号均可使用。比如一个人的性别，person 元素可以这样写：</p>
<person sex="female">

<p>或者这样也可以：</p>
<person sex='female'>

<p>如果属性值本身包含双引号，您可以使用单引号，就像这个实例：</p>
<gangster name='George "Shotgun" Ziegler'>

<p>或者您可以使用字符实体：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">gangster</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;George <span class="hljs-symbol">&amp;quot;</span>Shotgun<span class="hljs-symbol">&amp;quot;</span> Ziegler&quot;</span>&gt;</span>
<span class="hljs-comment">&lt;!-- $quot为双引号的字符实体--&gt;</span></code></pre>

<hr>
<h2 id="XML-元素-vs-属性"><a href="#XML-元素-vs-属性" class="headerlink" title="XML 元素 vs. 属性"></a>XML 元素 vs. 属性</h2><p>请看这些实例：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span> <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">firstname</span>&gt;</span>Anna<span class="hljs-tag">&lt;/<span class="hljs-name">firstname</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">lastname</span>&gt;</span>Smith<span class="hljs-tag">&lt;/<span class="hljs-name">lastname</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span></code></pre>

<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>female<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">firstname</span>&gt;</span>Anna<span class="hljs-tag">&lt;/<span class="hljs-name">firstname</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">lastname</span>&gt;</span>Smith<span class="hljs-tag">&lt;/<span class="hljs-name">lastname</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span></code></pre>

<p>在第一个实例中，sex 是一个属性。在第二个实例中，sex 是一个元素。这两个实例都提供相同的信息。</p>
<p>没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素吧。</p>
<hr>
<h2 id="我最喜欢的方式"><a href="#我最喜欢的方式" class="headerlink" title="我最喜欢的方式"></a>我最喜欢的方式</h2><p>下面的三个 XML 文档包含完全相同的信息：</p>
<p>第一个实例中使用了 date 属性：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span> <span class="hljs-attr">date</span>=<span class="hljs-string">&quot;10/01/2008&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>



<p>第二个实例中使用了 date 元素：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">date</span>&gt;</span>10/01/2008<span class="hljs-tag">&lt;/<span class="hljs-name">date</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>



<p>第三个实例中使用了扩展的 date 元素（这是我的最爱）：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">date</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">day</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">day</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">month</span>&gt;</span>01<span class="hljs-tag">&lt;/<span class="hljs-name">month</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2008<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">date</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<hr>
<h2 id="为什么避免-XML-属性？"><a href="#为什么避免-XML-属性？" class="headerlink" title="为什么避免 XML 属性？"></a>为什么避免 XML 属性？</h2><p>因使用属性而引起的一些问题：</p>
<ul>
<li>属性不能包含多个值（元素可以）</li>
<li>属性不能包含树结构（元素可以）</li>
<li>属性不容易扩展（为未来的变化）</li>
</ul>
<p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p>
<p>不要做这样的蠢事（这不是 XML 应该被使用的方式）：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span> <span class="hljs-attr">day</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">month</span>=<span class="hljs-string">&quot;01&quot;</span> <span class="hljs-attr">year</span>=<span class="hljs-string">&quot;2008&quot;</span></span>
<span class="hljs-tag"><span class="hljs-attr">to</span>=<span class="hljs-string">&quot;Tove&quot;</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;Jani&quot;</span> <span class="hljs-attr">heading</span>=<span class="hljs-string">&quot;Reminder&quot;</span></span>
<span class="hljs-tag"><span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Don&#x27;t forget me this weekend!&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<hr>
<h2 id="针对元数据的-XML-属性"><a href="#针对元数据的-XML-属性" class="headerlink" title="针对元数据的 XML 属性"></a>针对元数据的 XML 属性</h2><p>有时候会向元素分配 ID 引用。这些 ID 索引可用于标识 XML 元素，它起作用的方式与 HTML 中 id 属性是一样的。这个实例向我们演示了这种情况：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">messages</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">note</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;501&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">note</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;502&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Re: Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>I will not<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">messages</span>&gt;</span></code></pre>

<p>上面的 id 属性仅仅是一个标识符，用于标识不同的便签。它并不是便签数据的组成部分。</p>
<p>在此我们极力向您传递的理念是：<strong>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</strong></p>
<h1 id="XML-验证"><a href="#XML-验证" class="headerlink" title="XML 验证"></a>XML 验证</h1><p>拥有正确语法的 XML 被称为”形式良好”的 XML。</p>
<p>通过 DTD 验证的XML是”合法”的 XML。</p>
<h2 id="形式良好的-XML-文档"><a href="#形式良好的-XML-文档" class="headerlink" title="形式良好的 XML 文档"></a>形式良好的 XML 文档</h2><p>“形式良好”的 XML 文档拥有正确的语法。</p>
<p>在前面的章节描述的语法规则：</p>
<ul>
<li>XML 文档必须有一个根元素</li>
<li>XML元素都必须有一个关闭标签</li>
<li>XML 标签对大小写敏感</li>
<li>XML 元素必须被正确的嵌套</li>
<li>XML 属性值必须加引号</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>



<hr>
<h2 id="验证-XML-文档"><a href="#验证-XML-文档" class="headerlink" title="验证 XML 文档"></a>验证 XML 文档</h2><p>合法的 XML 文档是”形式良好”的 XML 文档，这也符合文档类型定义（DTD）的规则：</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span>
**<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;Note.dtd&quot;</span>&gt;</span>**
<span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>



<p>在上面的实例中，DOCTYPE 声明是对外部 DTD 文件的引用。下面的段落展示了这个文件的内容。</p>
<hr>
<h2 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h2><p>DTD 的目的是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构：</p>
<pre><code class="hljs dtd">&lt;!DOCTYPE note
[
&lt;!ELEMENT note (to,from,heading,body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
]&gt;</code></pre>

<p>如果您想要学习 DTD，请在<a href="https://www.runoob.com/">这里</a>查找 DTD 教程。</p>
<hr>
<h2 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h2><p>W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;note&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">xs:complexType</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">xs:sequence</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;to&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xs:string&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;from&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xs:string&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;heading&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xs:string&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;body&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xs:string&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">xs:sequence</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">xs:complexType</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">xs:element</span>&gt;</span></code></pre>

<p>如果您想要学习 XML Schema，请在<a href="https://www.runoob.com/">这里</a>查找 Schema 教程。</p>
<hr>
<h1 id="查看-XML-文件"><a href="#查看-XML-文件" class="headerlink" title="查看 XML 文件"></a>查看 XML 文件</h1><p>在所有主流的浏览器中，均能够查看原始的 XML 文件。</p>
<p>不要指望 XML 文件会直接显示为 HTML 页面。</p>
<h2 id="查看-XML-文件-1"><a href="#查看-XML-文件-1" class="headerlink" title="查看 XML 文件"></a>查看 XML 文件</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span>
- <span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre>

<p>查看这个 XML 文件：<a href="https://www.runoob.com/try/xml/note.xml">note.xml</a></p>
<p>XML 文档将显示为代码颜色化的根以及子元素。通过点击元素左侧的加号（+）或减号（ - ），可以展开或收起元素的结构。要查看原始的 XML 源（不包括 + 和 - 符号），选择”查看页面源代码”或从浏览器菜单”查看源文件”。</p>
<blockquote>
<p>在 Safari、Chrome 中，只有元素的文本将被显示。要查看原始的 XML，您必须右键单击页面，选择”查看源文件”。</p>
</blockquote>
<hr>
<h2 id="查看无效的-XML-文件"><a href="#查看无效的-XML-文件" class="headerlink" title="查看无效的 XML 文件"></a>查看无效的 XML 文件</h2><p>如果一个错误的XML文件被打开，浏览器会报告错误。</p>
<p>请查看这个 XML 文件：<a href="https://www.runoob.com/try/xml/note_error.xml">note_error.xml</a></p>
<hr>
<h2 id="其他-XML-实例"><a href="#其他-XML-实例" class="headerlink" title="其他 XML 实例"></a>其他 XML 实例</h2><p>请查看这些 XML 文档，这会有助于您建立对 XML 的感性认识。</p>
<p><a href="https://www.runoob.com/try/xml/cd_catalog.xml">一个 XML 的 CD 目录</a><br>这是一个 CD 集，存储为 XML 数据。</p>
<p><a href="https://www.runoob.com/try/xml/plant_catalog.xml">一个 XML 的植物目录</a><br>这是一个来自植物店的植物目录，存储为 XML 数据。</p>
<p><a href="https://www.runoob.com/try/xml/simple.xml">一个简单的食物菜单</a><br>这是一个来自餐馆的早餐菜单，存储为 XML 数据。</p>
<hr>
<h2 id="为什么-XML-显示这个样子？"><a href="#为什么-XML-显示这个样子？" class="headerlink" title="为什么 XML 显示这个样子？"></a>为什么 XML 显示这个样子？</h2><p>XML 文档不会携带有关如何显示数据的信息。</p>
<p>由于 XML 标签由 XML 文档的作者”发明”，浏览器无法确定像 <table> 这样一个标签究竟描述一个 HTML 表格还是一个餐桌。</p>
<p>在没有任何有关如何显示数据的信息的情况下，大多数的浏览器都会仅仅把 XML 文档显示为源代码。</p>
<p>在下面的章节，我们会了解几个有关这个显示问题的解决方案，其中会使用 CSS、XSLT 和 JavaScript。</p>
<hr>
<h1 id="使用-CSS-显示-XML-不常用"><a href="#使用-CSS-显示-XML-不常用" class="headerlink" title="使用 CSS 显示 XML(不常用)"></a>使用 CSS 显示 XML(不常用)</h1><p>通过使用 CSS（Cascading Style Sheets 层叠样式表），您可以添加显示信息到 XML 文档中。</p>
<h2 id="使用-CSS-显示您的-XML？"><a href="#使用-CSS-显示您的-XML？" class="headerlink" title="使用 CSS 显示您的 XML？"></a>使用 CSS 显示您的 XML？</h2><p>使用 CSS 来格式化 XML 文档是有可能的。</p>
<p>下面的实例就是关于如何使用 CSS 样式表来格式化 XML 文档：</p>
<p>请看这个 XML 文件：<a href="https://www.runoob.com/try/xml/cd_catalog.xml">CD 目录</a></p>
<p>然后看这个样式表：<a href="https://www.runoob.com/try/xml/cd_catalog.css">CSS 文件</a></p>
<p>最后，请查看：<a href="https://www.runoob.com/try/xml/cd_catalog_with_css.xml">使用 CSS 文件格式化的 CD 目录</a></p>
<p>使用 CSS 格式化 XML 不是常用的方法。</p>
<p>W3C 推荐使用 XSLT，请看下一章。</p>
<hr>
<h1 id="使用-XSLT-显示-XML"><a href="#使用-XSLT-显示-XML" class="headerlink" title="使用 XSLT 显示 XML"></a>使用 XSLT 显示 XML</h1><p>通过使用 XSLT，您可以把 XML 文档转换成 HTML 格式。</p>
<h2 id="使用-XSLT-显示-XML-1"><a href="#使用-XSLT-显示-XML-1" class="headerlink" title="使用 XSLT 显示 XML"></a>使用 XSLT 显示 XML</h2><p>XSLT 是首选的 XML 样式表语言。</p>
<p>XSLT（eXtensible Stylesheet Language Transformations）远比 CSS 更加完善。</p>
<p>XSLT 是在浏览器显示 XML 文件之前，先把它转换为 HTML：</p>
<p><a href="https://www.runoob.com/try/xml/simple.xml">XML 文件</a></p>
<p><a href="https://www.runoob.com/try/xml/simple.xsl">XSLT 文件</a></p>
<p>如果您想要学习有关 XSLT 的知识，请在我们的<a href="https://www.runoob.com/">首页</a>查找 XSLT 教程。</p>
<hr>
<h2 id="在服务器上通过-XSLT-转换-XML"><a href="#在服务器上通过-XSLT-转换-XML" class="headerlink" title="在服务器上通过 XSLT 转换 XML"></a>在服务器上通过 XSLT 转换 XML</h2><p>在上面的实例中，当浏览器读取 XML 文件时，XSLT 转换是由浏览器完成的。</p>
<p>在使用 XSLT 来转换 XML 时，不同的浏览器可能会产生不同结果。为了减少这种问题，可以在服务器上进行 XSLT 转换。</p>
<p><a href="https://www.runoob.com/try/xml/simple.php">查看结果</a>。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/分支和循环案例/" title="分支和循环案例">
                    分支和循环案例
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="分支结构和循环结构的应用"><a href="#分支结构和循环结构的应用" class="headerlink" title="分支结构和循环结构的应用"></a>分支结构和循环结构的应用</h2><p><strong>分支结构和循环结构是构造程序逻辑的基础</strong>，它们的重要性不言而喻，但是对于初学者来说这也是比较困难的部分。很多人对分支结构和循环结构的语法是能够理解的，但是遇到实际问题的时候又无法下手；<strong>看懂别人的代码很容易，但是要自己写出类似的代码却又很难</strong>。如果你也有同样的问题和困惑，千万不要沮丧，这只是因为你的编程之旅才刚刚开始，<strong>你的练习量还没有达到让你可以随心所欲的写出代码的程度</strong>，只要加强编程练习，通过量的积累来产生质的变化，这个问题迟早都会解决的。</p>
<h3 id="经典小案例"><a href="#经典小案例" class="headerlink" title="经典小案例"></a>经典小案例</h3><h4 id="例子1：100以内的素数"><a href="#例子1：100以内的素数" class="headerlink" title="例子1：100以内的素数"></a>例子1：100以内的素数</h4><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">输出100以内的素数</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>):
    is_prime = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(num ** <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:
            is_prime = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">if</span> is_prime:
        <span class="hljs-built_in">print</span>(num)</code></pre>

<h4 id="例子2：斐波那契数列"><a href="#例子2：斐波那契数列" class="headerlink" title="例子2：斐波那契数列"></a>例子2：斐波那契数列</h4><p>要求：输出斐波那契数列中的前20个数。</p>
<blockquote>
<p><strong>说明</strong>：斐波那契数列（Fibonacci sequence），通常也被称作黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中研究理想假设条件下兔子成长率问题而引入的数列，因此这个数列也常被戏称为“兔子数列”。斐波那契数列的特点是<strong>数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和。</strong>按照这个规律，斐波那契数列的前10个数是：<code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55</code>。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。</p>
</blockquote>
<pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">输出斐波那契数列中的前20个数</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):
    a, b = b, a + b
    <span class="hljs-built_in">print</span>(a)</code></pre>

<blockquote>
<p><strong>说明</strong>：上面循环中的<code>a, b = b, a + b</code>表示将变量<code>b</code>的值赋给<code>a</code>，把<code>a + b</code>的值赋给<code>b</code>。通过这个递推公式，我们可以依次获得斐波那契数列中的数。</p>
</blockquote>
<h4 id="例子3：寻找水仙花数"><a href="#例子3：寻找水仙花数" class="headerlink" title="例子3：寻找水仙花数"></a>例子3：寻找水仙花数</h4><p>要求：找出<code>100</code>到<code>999</code>范围内的所有水仙花数。</p>
<blockquote>
<p><strong>提示</strong>：在数论中，水仙花数（narcissistic number）也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个$\small{N}$位非负整数，其各位数字的$\small{N}$次方和刚好等于该数本身，例如：$\small{153&#x3D;1^3+5^3+3^3}$，所以<code>153</code> 是一个水仙花数；$\small{1634&#x3D;1^4+6^4+3^4+4^4}$，所以<code>1634</code>也是一个水仙花数。对于三位数，解题的关键是将它拆分为个位、十位、百位，再判断是否满足水仙花数的要求，这一点利用Python中的<code>//</code>和<code>%</code>运算符其实很容易做到。</p>
</blockquote>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">找出100到999范围内的水仙花数</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>):
    low = num % <span class="hljs-number">10</span>
    mid = num // <span class="hljs-number">10</span> % <span class="hljs-number">10</span>
    high = num // <span class="hljs-number">100</span>
    <span class="hljs-keyword">if</span> num == low ** <span class="hljs-number">3</span> + mid ** <span class="hljs-number">3</span> + high ** <span class="hljs-number">3</span>:
        <span class="hljs-built_in">print</span>(num)</code></pre>

<p>上面利用<code>//</code>和<code>%</code>拆分一个数的小技巧在写代码的时候还是很常用的。我们要<strong>将一个不知道有多少位的正整数进行反转</strong>，例如将<code>12389</code>变成<code>98321</code>，也可以利用这两个运算来实现，代码如下所示。</p>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">正整数的反转</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;num = &#x27;</span>))
reversed_num = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:	<span class="hljs-comment">#每次对10取余，到最后一位后取余会变为0</span>
    reversed_num = reversed_num * <span class="hljs-number">10</span> + num % <span class="hljs-number">10</span>
    num //= <span class="hljs-number">10</span>
<span class="hljs-built_in">print</span>(reversed_num)</code></pre>

<h4 id="例子4：百钱百鸡问题"><a href="#例子4：百钱百鸡问题" class="headerlink" title="例子4：百钱百鸡问题"></a>例子4：百钱百鸡问题</h4><blockquote>
<p><strong>说明</strong>：百钱百鸡是我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：<strong>公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</strong></p>
</blockquote>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">百钱百鸡问题</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">21</span>):
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">34</span>):
        <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>):
            <span class="hljs-keyword">if</span> x + y + z == <span class="hljs-number">100</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span> * y + z // <span class="hljs-number">3</span> == <span class="hljs-number">100</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;公鸡: <span class="hljs-subst">&#123;x&#125;</span>只, 母鸡: <span class="hljs-subst">&#123;y&#125;</span>只, 小鸡: <span class="hljs-subst">&#123;z&#125;</span>只&#x27;</span>)</code></pre>

<p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项，并检查每个候选项是否符合问题的描述，最终得到问题的解。上面的代码中，我们使用了嵌套的循环结构，假设公鸡有<code>x</code>只，显然<code>x</code>的取值范围是0到20，假设母鸡有<code>y</code>只，它的取值范围是<code>0</code>到<code>33</code>，假设小鸡有<code>z</code>只，它的取值范围是<code>0</code>到<code>99</code>且取值是<code>3</code> 的倍数。设置好<code>100</code>块钱的条件<code>5 * x + 3 * y + z // 3 == 100</code>，当条件同时满足时，就是问题的正确答案，我们用<code>print</code>函数输出它。</p>
<p>事实上，上面的代码还有更好的写法，既然我们已经假设公鸡有<code>x</code>只，母鸡有<code>y</code>只，那么小鸡的数量就应该是<code>100 - x - y</code>，这样减少一个条件，我们就可以把上面三层嵌套的<code>for-in</code>循环改写为两层嵌套的<code>for-in</code>循环。循环次数减少了，代码的执行效率就有了显著的提升，如下所示。</p>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">百钱百鸡问题</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">21</span>):
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">34</span>):
        z = <span class="hljs-number">100</span> - x - y
        <span class="hljs-keyword">if</span> z % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span> * y + z // <span class="hljs-number">3</span> == <span class="hljs-number">100</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;公鸡: <span class="hljs-subst">&#123;x&#125;</span>只, 母鸡: <span class="hljs-subst">&#123;y&#125;</span>只, 小鸡: <span class="hljs-subst">&#123;z&#125;</span>只&#x27;</span>)</code></pre>

<blockquote>
<p><strong>说明</strong>：上面代码中的<code>z % 3 == 0</code>是为了确保小鸡的数量是<code>3</code>的倍数。</p>
</blockquote>
<h4 id="例子5：CRAPS赌博游戏"><a href="#例子5：CRAPS赌博游戏" class="headerlink" title="例子5：CRAPS赌博游戏"></a>例子5：CRAPS赌博游戏</h4><blockquote>
<p><strong>说明</strong>：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简化后的规则是：玩家第一次摇骰子如果摇出了<code>7</code>点或<code>11</code>点，玩家胜；玩家第一次如果摇出<code>2</code>点、<code>3</code>点或<code>12</code>点，庄家胜；玩家如果摇出其他点数则游戏继续，玩家重新摇骰子，如果玩家摇出了<code>7</code>点，庄家胜；如果玩家摇出了<strong>第一次摇的点数</strong>，玩家胜；其他点数玩家继续摇骰子，直到分出胜负。为了增加代码的趣味性，我们设定游戏开始时玩家有<code>1000</code>元的赌注，每局游戏开始之前，玩家先下注，如果玩家获胜就可以获得对应下注金额的奖励，如果庄家获胜，玩家就会输掉自己下注的金额。游戏结束的条件是玩家破产（输光所有的赌注）。</p>
</blockquote>
<pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">Craps赌博游戏</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">import</span> random

money = <span class="hljs-number">1000</span>
<span class="hljs-keyword">while</span> money &gt; <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;你的总资产为: <span class="hljs-subst">&#123;money&#125;</span>元&#x27;</span>)
    <span class="hljs-comment"># 下注金额必须大于0且小于等于玩家的总资产</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        debt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请下注: &#x27;</span>))
        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; debt &lt;= money:
            <span class="hljs-keyword">break</span>
    <span class="hljs-comment"># 用两个1到6均匀分布的随机数相加模拟摇两颗色子得到的点数</span>
    first_point = random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>) + random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\n玩家摇出了<span class="hljs-subst">&#123;first_point&#125;</span>点&#x27;</span>)
    <span class="hljs-keyword">if</span> first_point == <span class="hljs-number">7</span> <span class="hljs-keyword">or</span> first_point == <span class="hljs-number">11</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;玩家胜!\n&#x27;</span>)
        money += debt
    <span class="hljs-keyword">elif</span> first_point == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> first_point == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> first_point == <span class="hljs-number">12</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;庄家胜!\n&#x27;</span>)
        money -= debt
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># 如果第一次摇色子没有分出胜负，玩家需要重新摇色子</span>
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            current_point = random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>) + random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;玩家摇出了<span class="hljs-subst">&#123;current_point&#125;</span>点&#x27;</span>)
            <span class="hljs-keyword">if</span> current_point == <span class="hljs-number">7</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;庄家胜!\n&#x27;</span>)
                money -= debt
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">elif</span> current_point == first_point:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;玩家胜!\n&#x27;</span>)
                money += debt
                <span class="hljs-keyword">break</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你破产了, 游戏结束!&#x27;</span>)</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分支结构和循环结构都非常重要，是构造程序逻辑的基础，<strong>一定要通过大量的练习来达到融会贯通</strong>。我们可以用上面讲的花旗骰游戏作为一个标准，如果你能够很顺利的完成这段代码，那么分支结构和循环结构的知识你就已经很好的掌握了。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/模块收集/" title="模块综合">
                    模块综合
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python综合/">Python综合</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="排序函数-sorted函数"><a href="#排序函数-sorted函数" class="headerlink" title="排序函数_sorted函数"></a>排序函数_sorted函数</h2><p><code>sorted</code> 函数是 Python 内置的用于排序的函数。它可以对任何可迭代对象进行排序，并返回一个新的已排序的列表，而不会改变原始对象。</p>
<h3 id="sorted-函数的语法"><a href="#sorted-函数的语法" class="headerlink" title="sorted 函数的语法"></a><code>sorted</code> 函数的语法</h3><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(iterable, *, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)</code></pre>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol>
<li><strong>iterable</strong>：要排序的可迭代对象（如列表、元组、字符串等）。</li>
<li><strong>key</strong>：一个函数，它将用于从 iterable 的每个元素中提取用于比较的键。默认值为 None，即直接比较元素的值。</li>
<li><strong>reverse</strong>：一个布尔值。如果设为 True，将按降序排序。默认值为 False，即按升序排序。</li>
</ol>
<h3 id="示例和详细解释"><a href="#示例和详细解释" class="headerlink" title="示例和详细解释"></a>示例和详细解释</h3><ol>
<li><p><strong>基本使用</strong>：</p>
<pre><code class="hljs python">numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
sorted_numbers = <span class="hljs-built_in">sorted</span>(numbers)
<span class="hljs-built_in">print</span>(sorted_numbers)  <span class="hljs-comment"># 输出: [1, 2, 5, 5, 6, 9]</span></code></pre>
<p>这个示例将一个数字列表按升序排序。</p>
</li>
<li><p><strong>使用 key 参数</strong>：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]
sorted_words = <span class="hljs-built_in">sorted</span>(words, key=<span class="hljs-built_in">len</span>)
<span class="hljs-built_in">print</span>(sorted_words)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span></code></pre>
<p>在这个例子中，列表按单词的长度进行排序。</p>
</li>
<li><p><strong>按降序排序</strong>：</p>
<pre><code class="hljs python">numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
sorted_numbers = <span class="hljs-built_in">sorted</span>(numbers, reverse=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(sorted_numbers)  <span class="hljs-comment"># 输出: [9, 6, 5, 5, 2, 1]</span></code></pre>
<p>这个示例按降序对数字列表进行排序。</p>
</li>
<li><p><strong>结合使用 key 和 reverse</strong>：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]
sorted_words = <span class="hljs-built_in">sorted</span>(words, key=<span class="hljs-built_in">len</span>, reverse=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(sorted_words)  <span class="hljs-comment"># 输出: [&#x27;banana&#x27;, &#x27;cherry&#x27;, &#x27;apple&#x27;]</span></code></pre>
<p>这个示例先按单词长度排序，再按降序排列。</p>
</li>
<li><p><strong>复杂数据结构排序</strong>：</p>
<pre><code class="hljs python">students = [
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>&#125;,
]
sorted_students = <span class="hljs-built_in">sorted</span>(students, key=<span class="hljs-keyword">lambda</span> student: student[<span class="hljs-string">&#x27;age&#x27;</span>])
<span class="hljs-built_in">print</span>(sorted_students)</code></pre>
<p>输出：</p>
<pre><code class="hljs python">[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;,
 &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>&#125;,
 &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>&#125;]</code></pre>
<p>在这个示例中，学生列表按年龄排序。</p>
</li>
</ol>
<h3 id="内置和自定义排序键"><a href="#内置和自定义排序键" class="headerlink" title="内置和自定义排序键"></a>内置和自定义排序键</h3><h4 id="按字符串排序："><a href="#按字符串排序：" class="headerlink" title="按字符串排序："></a>按字符串排序：</h4><pre><code class="hljs python">names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>]
sorted_names = <span class="hljs-built_in">sorted</span>(names)
<span class="hljs-built_in">print</span>(sorted_names)  <span class="hljs-comment"># 输出: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;]</span></code></pre>

<h4 id="按字符串长度排序："><a href="#按字符串长度排序：" class="headerlink" title="按字符串长度排序："></a>按字符串长度排序：</h4><pre><code class="hljs python">names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>]
sorted_names = <span class="hljs-built_in">sorted</span>(names, key=<span class="hljs-built_in">len</span>)
<span class="hljs-built_in">print</span>(sorted_names)  <span class="hljs-comment"># 输出: [&#x27;Bob&#x27;, &#x27;Alice&#x27;, &#x27;Charlie&#x27;]</span></code></pre>

<h4 id="自定义排序函数："><a href="#自定义排序函数：" class="headerlink" title="自定义排序函数："></a>自定义排序函数：</h4><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">custom_sort</span>(<span class="hljs-params">item</span>):
    <span class="hljs-keyword">return</span> item.lower()

names = [<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;charlie&quot;</span>]
sorted_names = <span class="hljs-built_in">sorted</span>(names, key=custom_sort)
<span class="hljs-built_in">print</span>(sorted_names)  <span class="hljs-comment"># 输出: [&#x27;alice&#x27;, &#x27;Bob&#x27;, &#x27;charlie&#x27;]</span></code></pre>

<h3 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h3><ul>
<li><strong>稳定排序</strong>：<code>sorted</code> 函数保证是稳定排序，这意味着当有多个记录具有相同键值时，它们的相对顺序在排序后会保持不变。</li>
<li><strong>复杂度</strong>：<code>sorted</code> 函数的时间复杂度为 O(n log n)，这是由于其底层实现是 Timsort，一种混合排序算法，结合了归并排序和插入排序的优点。</li>
</ul>
<h2 id="string-模块"><a href="#string-模块" class="headerlink" title="string 模块"></a>string 模块</h2><p>Python 的 <code>string</code> 模块提供了许多有用的字符串操作功能和常量，方便进行字符串处理。下面是 <code>string</code> 模块的一些主要功能和内容：</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li><code>string.ascii_letters</code>: 包含所有 ASCII 字母（大写和小写）。</li>
<li><code>string.ascii_lowercase</code>: 包含所有 ASCII 小写字母。</li>
<li><code>string.ascii_uppercase</code>: 包含所有 ASCII 大写字母。</li>
<li><code>string.digits</code>: 包含所有十进制数字（0-9）。</li>
<li><code>string.hexdigits</code>: 包含所有十六进制数字（0-9 和 a-f 和 A-F）。</li>
<li><code>string.octdigits</code>: 包含所有八进制数字（0-7）。</li>
<li><code>string.punctuation</code>: 包含所有 ASCII 标点符号。</li>
<li><code>string.printable</code>: 包含所有可打印字符（包括数字、字母、标点符号和空白字符）。</li>
<li><code>string.whitespace</code>: 包含所有空白字符（如空格、制表符、换行符等）。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>string.capwords(s, sep=None)</code>: 将字符串 <code>s</code> 中的单词首字母大写，其他字母小写。单词以 <code>sep</code> 作为分隔符（默认为空格）。</li>
</ul>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p><code>join</code> 方法是 Python 中字符串对象的一个方法，用于将一个可迭代对象（如列表、元组等）中的元素连接成一个字符串。连接时，元素之间会插入调用 <code>join</code> 方法的字符串。常见的用法为将列表中的字符串元素连接成一个长字符串。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs python"><span class="hljs-built_in">str</span>.join(iterable)</code></pre>

<ul>
<li><code>str</code>：调用 <code>join</code> 方法的字符串，用作连接符。</li>
<li><code>iterable</code>：一个可迭代对象，其元素是要连接成一个字符串的子字符串。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>将一个字符串列表用逗号连接成一个字符串：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>]
result = <span class="hljs-string">&quot;,&quot;</span>.join(words)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: hello,world,python</span></code></pre>

<p>在这个例子中，<code>&quot;,&quot;.join(words)</code> 会将 <code>words</code> 列表中的每个字符串元素连接起来，每两个元素之间插入一个逗号。</p>
<h4 id="用空格连接"><a href="#用空格连接" class="headerlink" title="用空格连接"></a>用空格连接</h4><p>将一个字符串列表用空格连接成一个字符串：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;join&quot;</span>, <span class="hljs-string">&quot;method&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>]
result = <span class="hljs-string">&quot; &quot;</span>.join(words)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: join method in python</span></code></pre>

<h4 id="用换行符连接"><a href="#用换行符连接" class="headerlink" title="用换行符连接"></a>用换行符连接</h4><p>将一个字符串列表用换行符连接成一个字符串：</p>
<pre><code class="hljs python">lines = [<span class="hljs-string">&quot;line1&quot;</span>, <span class="hljs-string">&quot;line2&quot;</span>, <span class="hljs-string">&quot;line3&quot;</span>]
result = <span class="hljs-string">&quot;\n&quot;</span>.join(lines)
<span class="hljs-built_in">print</span>(result)
<span class="hljs-comment"># 输出:</span>
<span class="hljs-comment"># line1</span>
<span class="hljs-comment"># line2</span>
<span class="hljs-comment"># line3</span></code></pre>

<h4 id="连接字符"><a href="#连接字符" class="headerlink" title="连接字符"></a>连接字符</h4><p>将一个字符列表连接成一个字符串：</p>
<pre><code class="hljs python">chars = [<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>]
result = <span class="hljs-string">&quot;&quot;</span>.join(chars)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: Python</span></code></pre>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>元素必须是字符串</strong>：<code>join</code> 方法只能连接字符串类型的元素。如果可迭代对象中的元素不是字符串类型，会引发 <code>TypeError</code>。</p>
 <pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
result = <span class="hljs-string">&quot;,&quot;</span>.join(numbers)  <span class="hljs-comment"># 会引发 TypeError</span></code></pre>
<p> 如果需要连接非字符串类型的元素，可以先将它们转换为字符串：</p>
 <pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
result = <span class="hljs-string">&quot;,&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, numbers))
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 1,2,3,4</span></code></pre>
</li>
<li><p><strong>可迭代对象</strong>：<code>join</code> 方法可以处理任何可迭代对象（如列表、元组、集合等），只要其中的元素是字符串。</p>
 <pre><code class="hljs python">words = (<span class="hljs-string">&quot;tuple&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;join&quot;</span>)
result = <span class="hljs-string">&quot; &quot;</span>.join(words)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: tuple example join</span></code></pre>
</li>
<li><p><strong>性能</strong>：<code>join</code> 方法比使用循环和字符串拼接（如使用 <code>+</code> 运算符）效率更高，尤其是在连接大量字符串时，<code>join</code> 方法的性能优势更加明显，因为它避免了创建多个中间字符串。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>join</code> 方法是一个非常实用的字符串方法，用于将可迭代对象中的字符串元素连接成一个字符串。通过灵活使用 <code>join</code> 方法，可以方便地处理字符串的连接和拼接操作。</p>
<h2 id="statistics模块"><a href="#statistics模块" class="headerlink" title="statistics模块"></a>statistics模块</h2><p><code>statistics</code> 模块是 Python 的标准库模块之一，用于执行基本的统计运算。这个模块提供了多种函数，帮助用户对数据进行统计分析，例如求平均值、中位数、标准差等。</p>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><p><code>statistics</code> 模块包含的功能主要分为以下几类：</p>
<ol>
<li><strong>均值和中位数计算</strong></li>
<li><strong>方差和标准差计算</strong></li>
<li><strong>分位数和百分位数计算</strong></li>
<li><strong>其他统计函数</strong></li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="均值和中位数"><a href="#均值和中位数" class="headerlink" title="均值和中位数"></a>均值和中位数</h4><ul>
<li><code>mean(data)</code>: 返回数据的算术平均值。</li>
<li><code>median(data)</code>: 返回数据的中位数。</li>
<li><code>mode(data)</code>: 返回数据的众数（出现次数最多的值）。</li>
<li><code>harmonic_mean(data)</code>: 返回数据的调和平均值。</li>
</ul>
<h4 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h4><ul>
<li><code>variance(data, xbar=None)</code>: 返回数据的样本方差。</li>
<li><code>stdev(data, xbar=None)</code>: 返回数据的样本标准差。</li>
<li><code>pstdev(data, mu=None)</code>: 返回数据的总体标准差。</li>
<li><code>pvariance(data, mu=None)</code>: 返回数据的总体方差。</li>
</ul>
<h4 id="分位数和百分位数"><a href="#分位数和百分位数" class="headerlink" title="分位数和百分位数"></a>分位数和百分位数</h4><ul>
<li><code>median_low(data)</code>: 返回数据的低中位数（当数据个数为偶数时，返回较小的那个中位数）。</li>
<li><code>median_high(data)</code>: 返回数据的高中位数（当数据个数为偶数时，返回较大的那个中位数）。</li>
<li><code>median_grouped(data, interval=1)</code>: 返回分组数据的中位数。</li>
<li><code>quantiles(data, n=4, method=&#39;exclusive&#39;)</code>: 返回数据的分位数。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是使用 <code>statistics</code> 模块的几个示例：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> statistics <span class="hljs-keyword">as</span> stats

data = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]

<span class="hljs-comment"># 均值</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mean:&quot;</span>, stats.mean(data))  <span class="hljs-comment"># 输出: Mean: 5</span>

<span class="hljs-comment"># 中位数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Median:&quot;</span>, stats.median(data))  <span class="hljs-comment"># 输出: Median: 4.5</span>

<span class="hljs-comment"># 众数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mode:&quot;</span>, stats.mode(data))  <span class="hljs-comment"># 输出: Mode: 4</span>

<span class="hljs-comment"># 方差</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Variance:&quot;</span>, stats.variance(data))  <span class="hljs-comment"># 输出: Variance: 4.571428571428571</span>

<span class="hljs-comment"># 标准差</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Standard Deviation:&quot;</span>, stats.stdev(data))  <span class="hljs-comment"># 输出: Standard Deviation: 2.138089935299395</span>

<span class="hljs-comment"># 分位数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Quantiles:&quot;</span>, stats.quantiles(data))  <span class="hljs-comment"># 输出: Quantiles: [4.0, 4.5, 5.0]</span></code></pre>

<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol>
<li><strong>输入数据</strong>：大部分函数的参数是一个可迭代对象（如列表、元组等），其中的元素应该是数值类型。</li>
<li><strong>样本与总体</strong>：方差和标准差的计算函数区分了样本和总体。<code>variance</code> 和 <code>stdev</code> 计算样本的方差和标准差，而 <code>pvariance</code> 和 <code>pstdev</code> 计算总体的方差和标准差。</li>
<li><strong>异常处理</strong>：在使用这些函数时，如果数据中包含非数值类型或数据为空，会引发 <code>StatisticsError</code> 异常。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>statistics</code> 模块是进行基础统计分析的有力工具，涵盖了从简单的平均值计算到复杂的方差和分位数计算的广泛功能。它使得统计运算在 Python 中变得简单和高效，适用于各种数据分析和科学计算的场景。</p>
<h2 id="operator模块"><a href="#operator模块" class="headerlink" title="operator模块"></a>operator模块</h2><p><code>operator</code> 模块是 Python 的一个标准库模块，提供了一系列函数对应于 Python 中的标准运算符。这些函数可以使代码更具可读性，并且在需要传递函数作为参数时尤其有用。<code>operator</code> 模块的功能包括基本的算术运算、比较运算、逻辑运算、序列操作等。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p><code>operator</code> 模块包含以下几类操作函数：</p>
<ol>
<li><strong>算术运算</strong></li>
<li><strong>比较运算</strong></li>
<li><strong>逻辑运算</strong></li>
<li><strong>序列和映射操作</strong></li>
<li><strong>属性和方法操作</strong></li>
</ol>
<h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="算术运算函数"><a href="#算术运算函数" class="headerlink" title="算术运算函数"></a>算术运算函数</h4><ul>
<li><code>add(a, b)</code>: 返回 <code>a + b</code></li>
<li><code>sub(a, b)</code>: 返回 <code>a - b</code></li>
<li><code>mul(a, b)</code>: 返回 <code>a * b</code></li>
<li><code>truediv(a, b)</code>: 返回 <code>a / b</code>（浮点除法）</li>
<li><code>floordiv(a, b)</code>: 返回 <code>a // b</code>（整数除法）</li>
<li><code>mod(a, b)</code>: 返回 <code>a % b</code></li>
<li><code>pow(a, b)</code>: 返回 <code>a ** b</code></li>
</ul>
<h4 id="比较运算函数"><a href="#比较运算函数" class="headerlink" title="比较运算函数"></a>比较运算函数</h4><ul>
<li><code>eq(a, b)</code>: 返回 <code>a == b</code></li>
<li><code>ne(a, b)</code>: 返回 <code>a != b</code></li>
<li><code>lt(a, b)</code>: 返回 <code>a &lt; b</code></li>
<li><code>le(a, b)</code>: 返回 <code>a &lt;= b</code></li>
<li><code>gt(a, b)</code>: 返回 <code>a &gt; b</code></li>
<li><code>ge(a, b)</code>: 返回 <code>a &gt;= b</code></li>
</ul>
<h4 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h4><ul>
<li><code>and_(a, b)</code>: 返回 <code>a and b</code></li>
<li><code>or_(a, b)</code>: 返回 <code>a or b</code></li>
<li><code>not_(a)</code>: 返回 <code>not a</code></li>
</ul>
<h4 id="序列和映射操作函数"><a href="#序列和映射操作函数" class="headerlink" title="序列和映射操作函数"></a>序列和映射操作函数</h4><ul>
<li><code>getitem(obj, key)</code>: 返回 <code>obj[key]</code></li>
<li><code>setitem(obj, key, value)</code>: 设置 <code>obj[key] = value</code></li>
<li><code>delitem(obj, key)</code>: 删除 <code>obj[key]</code></li>
<li><code>contains(obj, key)</code>: 返回 <code>key in obj</code></li>
<li><code>concat(a, b)</code>: 返回 <code>a + b</code>（序列连接）</li>
<li><code>countOf(a, b)</code>: 返回 <code>a</code> 中 <code>b</code> 的个数</li>
<li><code>indexOf(a, b)</code>: 返回 <code>a</code> 中第一次出现 <code>b</code> 的索引</li>
</ul>
<h4 id="属性和方法操作函数"><a href="#属性和方法操作函数" class="headerlink" title="属性和方法操作函数"></a>属性和方法操作函数</h4><ul>
<li><code>attrgetter(attr)</code>: 返回一个可调用对象，从对象获取名为 <code>attr</code> 的属性</li>
<li><code>itemgetter(*items)</code>: 返回一个可调用对象，从对象获取指定的多个值</li>
<li><code>methodcaller(name, *args, **kwargs)</code>: 返回一个可调用对象，对对象调用名为 <code>name</code> 的方法，并传递给定的参数和关键字参数</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下是使用 <code>operator</code> 模块的一些示例：</p>
<h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

a, b = <span class="hljs-number">5</span>, <span class="hljs-number">3</span>

<span class="hljs-built_in">print</span>(operator.add(a, b))  <span class="hljs-comment"># 输出: 8</span>
<span class="hljs-built_in">print</span>(operator.mul(a, b))  <span class="hljs-comment"># 输出: 15</span>
<span class="hljs-built_in">print</span>(operator.<span class="hljs-built_in">pow</span>(a, b))  <span class="hljs-comment"># 输出: 125</span></code></pre>

<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

a, b = <span class="hljs-number">5</span>, <span class="hljs-number">3</span>

<span class="hljs-built_in">print</span>(operator.lt(a, b))  <span class="hljs-comment"># 输出: False</span>
<span class="hljs-built_in">print</span>(operator.ge(a, b))  <span class="hljs-comment"># 输出: True</span>
<span class="hljs-built_in">print</span>(operator.eq(a, b))  <span class="hljs-comment"># 输出: False</span></code></pre>

<h4 id="序列和映射操作"><a href="#序列和映射操作" class="headerlink" title="序列和映射操作"></a>序列和映射操作</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

<span class="hljs-built_in">print</span>(operator.getitem(lst, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出: 3</span>
operator.setitem(lst, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)
<span class="hljs-built_in">print</span>(lst)  <span class="hljs-comment"># 输出: [1, 2, 10, 4, 5]</span>
operator.delitem(lst, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(lst)  <span class="hljs-comment"># 输出: [1, 2, 4, 5]</span>

d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;
<span class="hljs-built_in">print</span>(operator.getitem(d, <span class="hljs-string">&#x27;b&#x27;</span>))  <span class="hljs-comment"># 输出: 2</span></code></pre>

<h4 id="属性和方法操作"><a href="#属性和方法操作" class="headerlink" title="属性和方法操作"></a>属性和方法操作</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.age = age

p = Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>)

name = operator.attrgetter(<span class="hljs-string">&#x27;name&#x27;</span>)
<span class="hljs-built_in">print</span>(name(p))  <span class="hljs-comment"># 输出: Alice</span>

data = [(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>), (<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">35</span>)]
data.sort(key=operator.itemgetter(<span class="hljs-number">1</span>))
<span class="hljs-built_in">print</span>(data)  <span class="hljs-comment"># 输出: [(&#x27;Bob&#x27;, 25), (&#x27;Alice&#x27;, 30), (&#x27;Charlie&#x27;, 35)]</span></code></pre>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>operator</code> 模块提供了对 Python 内置运算符的函数接口，使得代码在处理操作时更加清晰和灵活。特别是在需要将函数作为参数传递的情况下，这些函数显得尤为有用。通过使用 <code>operator</code> 模块，可以提高代码的可读性和可维护性。</p>
<h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><p>Python 的 <code>random</code> 模块提供了各种生成随机数和执行随机操作的函数。以下是 <code>random</code> 模块中的主要功能和使用方法：</p>
<h3 id="1-生成随机数"><a href="#1-生成随机数" class="headerlink" title="1. 生成随机数"></a>1. 生成随机数</h3><ul>
<li><p><strong>随机浮点数</strong></p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> random

<span class="hljs-comment"># 生成 0 到 1 之间的随机浮点数</span>
random_float = random.random()
<span class="hljs-built_in">print</span>(random_float)  <span class="hljs-comment"># 例如 0.37444887175646646</span></code></pre>
</li>
<li><p><strong>指定范围内的随机浮点数</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成 [a, b] 之间的随机浮点数</span>
random_float = random.uniform(a, b)
<span class="hljs-built_in">print</span>(random_float)</code></pre>
</li>
<li><p><strong>随机整数</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成 [a, b] 之间的随机整数</span>
random_int = random.randint(a, b)
<span class="hljs-built_in">print</span>(random_int)</code></pre>
</li>
<li><p><strong>指定步长的随机整数</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成 range(start, stop, step) 范围内的随机整数</span>
random_int = random.randrange(start, stop, step)
<span class="hljs-built_in">print</span>(random_int)</code></pre></li>
</ul>
<h3 id="2-随机选择"><a href="#2-随机选择" class="headerlink" title="2. 随机选择"></a>2. 随机选择</h3><ul>
<li><p><strong>从序列中随机选择一个元素</strong></p>
<pre><code class="hljs python">choices = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]
random_choice = random.choice(choices)
<span class="hljs-built_in">print</span>(random_choice)  <span class="hljs-comment"># 例如 &#x27;banana&#x27;</span></code></pre>
</li>
<li><p><strong>从序列中随机选择多个元素</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 从序列中随机选择 k 个元素，可以有重复</span>
random_choices = random.choices(choices, k=<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(random_choices)  <span class="hljs-comment"># 例如 [&#x27;cherry&#x27;, &#x27;banana&#x27;, &#x27;banana&#x27;]</span></code></pre>
</li>
<li><p><strong>从序列中随机选择多个不重复元素</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 从序列中随机选择 k 个不重复元素</span>
random_sample = random.sample(choices, k=<span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(random_sample)  <span class="hljs-comment"># 例如 [&#x27;banana&#x27;, &#x27;apple&#x27;]</span></code></pre></li>
</ul>
<h3 id="3-打乱顺序"><a href="#3-打乱顺序" class="headerlink" title="3. 打乱顺序"></a>3. 打乱顺序</h3><ul>
<li><p><strong>就地打乱列表中的元素顺序</strong></p>
<pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
random.shuffle(numbers)
<span class="hljs-built_in">print</span>(numbers)  <span class="hljs-comment"># 例如 [3, 5, 1, 2, 4]</span></code></pre></li>
</ul>
<h3 id="4-生成随机分布"><a href="#4-生成随机分布" class="headerlink" title="4. 生成随机分布"></a>4. 生成随机分布</h3><ul>
<li><p><strong>正态分布（高斯分布）</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成均值为 mu，标准差为 sigma 的随机浮点数</span>
random_gauss = random.gauss(mu, sigma)
<span class="hljs-built_in">print</span>(random_gauss)</code></pre>
</li>
<li><p><strong>其他分布</strong></p>
<ul>
<li><p><strong>Beta 分布</strong></p>
<pre><code class="hljs python">random_beta = random.betavariate(alpha, beta)
<span class="hljs-built_in">print</span>(random_beta)</code></pre>
</li>
<li><p><strong>Gamma 分布</strong></p>
<pre><code class="hljs python">random_gamma = random.gammavariate(alpha, beta)
<span class="hljs-built_in">print</span>(random_gamma)</code></pre>
</li>
<li><p><strong>指数分布</strong></p>
<pre><code class="hljs python">random_exp = random.expovariate(lambd)
<span class="hljs-built_in">print</span>(random_exp)</code></pre>
</li>
<li><p><strong>对数正态分布</strong></p>
<pre><code class="hljs python">random_lognorm = random.lognormvariate(mu, sigma)
<span class="hljs-built_in">print</span>(random_lognorm)</code></pre>
</li>
<li><p><strong>Pareto 分布</strong></p>
<pre><code class="hljs python">random_pareto = random.paretovariate(alpha)
<span class="hljs-built_in">print</span>(random_pareto)</code></pre>
</li>
<li><p><strong>维布尔分布</strong></p>
<pre><code class="hljs python">random_weibull = random.weibullvariate(alpha, beta)
<span class="hljs-built_in">print</span>(random_weibull)</code></pre></li>
</ul>
</li>
</ul>
<h3 id="5-种子控制"><a href="#5-种子控制" class="headerlink" title="5. 种子控制"></a>5. 种子控制</h3><ul>
<li><p><strong>设置随机数生成器的种子</strong></p>
<pre><code class="hljs python">random.seed(a)</code></pre>

<p>使用相同的种子可以确保生成的随机数序列相同，对于调试和测试非常有用。</p>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Python 的 <code>random</code> 模块提供了丰富的随机数生成和操作函数，涵盖了基本的随机数生成、序列操作和多种随机分布。通过这些函数，可以方便地在各种应用中实现随机行为。</p>
<h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>Python 的 <code>time</code> 模块提供了多种与时间相关的函数，用于处理时间和日期。以下是 <code>time</code> 模块中的主要功能和使用方法：</p>
<h3 id="1-获取当前时间"><a href="#1-获取当前时间" class="headerlink" title="1. 获取当前时间"></a>1. 获取当前时间</h3><ul>
<li><p><strong>获取当前时间的时间戳</strong></p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> time <span class="hljs-comment">#返回当前时间的时间戳（自 Unix 纪元（1970年1月1日）以来的秒数）</span>
  <span class="hljs-built_in">print</span>(current_time)  <span class="hljs-comment"># 例如 1623673923.786348</span></code></pre>
</li>
<li><p><strong>获取当前时间的结构化时间（本地时间）</strong></p>
<pre><code class="hljs python">local_time = time.localtime() <span class="hljs-comment"># 返回当前时间的本地时间结构</span>
<span class="hljs-built_in">print</span>(local_time)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre>
</li>
<li><p><strong>获取当前时间的结构化时间（UTC 时间）</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 返回当前时间的 UTC 时间结构</span>
utc_time = time.gmtime()
<span class="hljs-built_in">print</span>(utc_time)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre></li>
</ul>
<h3 id="2-格式化时间"><a href="#2-格式化时间" class="headerlink" title="2. 格式化时间"></a>2. 格式化时间</h3><ul>
<li><p><strong>将时间结构转换为字符串</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 将当前本地时间转换为字符串</span>
formatted_time = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, local_time)
<span class="hljs-built_in">print</span>(formatted_time)  <span class="hljs-comment"># 例如 &#x27;2021-06-14 10:32:03&#x27;</span></code></pre>
</li>
<li><p><strong>将字符串解析为时间结构</strong></p>
<pre><code class="hljs python">time_string = <span class="hljs-string">&quot;2021-06-14 10:32:03&quot;</span>
<span class="hljs-comment"># 将字符串解析为时间结构</span>
parsed_time = time.strptime(time_string, <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)
<span class="hljs-built_in">print</span>(parsed_time)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre></li>
</ul>
<h3 id="3-时间戳和时间结构之间的转换"><a href="#3-时间戳和时间结构之间的转换" class="headerlink" title="3. 时间戳和时间结构之间的转换"></a>3. 时间戳和时间结构之间的转换</h3><ul>
<li><p><strong>时间戳转换为本地时间结构</strong></p>
<pre><code class="hljs python">timestamp = <span class="hljs-number">1623673923.786348</span>
local_time_from_timestamp = time.localtime(timestamp)
<span class="hljs-built_in">print</span>(local_time_from_timestamp)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre>
</li>
<li><p><strong>时间戳转换为 UTC 时间结构</strong></p>
<pre><code class="hljs python">utc_time_from_timestamp = time.gmtime(timestamp)
<span class="hljs-built_in">print</span>(utc_time_from_timestamp)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre>
</li>
<li><p><strong>时间结构转换为时间戳</strong></p>
<pre><code class="hljs python">timestamp_from_local_time = time.mktime(local_time)
<span class="hljs-built_in">print</span>(timestamp_from_local_time)  <span class="hljs-comment"># 例如 1623673923.0</span></code></pre></li>
</ul>
<h3 id="4-暂停程序执行"><a href="#4-暂停程序执行" class="headerlink" title="4. 暂停程序执行"></a>4. 暂停程序执行</h3><ul>
<li><p><strong>暂停程序执行指定秒数</strong></p>
<pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start&quot;</span>)
time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 暂停程序执行 2 秒</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;End&quot;</span>)</code></pre></li>
</ul>
<h3 id="5-其他实用功能"><a href="#5-其他实用功能" class="headerlink" title="5. 其他实用功能"></a>5. 其他实用功能</h3><ul>
<li><p><strong>获取 CPU 时间</strong></p>
<pre><code class="hljs python">cpu_time = time.process_time()
<span class="hljs-built_in">print</span>(cpu_time)  <span class="hljs-comment"># 例如 0.015625</span></code></pre>
</li>
<li><p><strong>测量时间间隔</strong></p>
<pre><code class="hljs python">start_time = time.perf_counter()
<span class="hljs-comment"># 进行一些操作</span>
end_time = time.perf_counter()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作耗时: <span class="hljs-subst">&#123;end_time - start_time&#125;</span> 秒&quot;</span>)</code></pre>
</li>
<li><p><strong>获取系统时区偏移量</strong></p>
<pre><code class="hljs python">timezone_offset = time.timezone  <span class="hljs-comment"># 返回本地时区相对于 UTC 的偏移量（秒）</span>
<span class="hljs-built_in">print</span>(timezone_offset)  <span class="hljs-comment"># 例如 -28800（对于 UTC-8 时区）</span></code></pre>
</li>
<li><p><strong>获取夏令时标志</strong></p>
<pre><code class="hljs python">daylight_saving_flag = time.daylight  <span class="hljs-comment"># 返回夏令时是否被定义</span>
<span class="hljs-built_in">print</span>(daylight_saving_flag)  <span class="hljs-comment"># 例如 1（表示夏令时定义）</span></code></pre></li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Python 的 <code>time</code> 模块提供了丰富的时间和日期操作功能，包括获取当前时间、格式化时间、时间戳和结构化时间的转换、暂停程序执行、测量时间间隔等。通过这些函数，可以在各种应用场景中方便地处理时间相关的数据。</p>
<h2 id="装饰器详细解释"><a href="#装饰器详细解释" class="headerlink" title="装饰器详细解释"></a>装饰器详细解释</h2><h3 id="装饰器的基本结构"><a href="#装饰器的基本结构" class="headerlink" title="装饰器的基本结构"></a>装饰器的基本结构</h3><p>装饰器是一个用于包裹另一个函数以增强或修改其行为的函数。装饰器本身是一个高阶函数，因为它接受一个函数作为参数，并返回一个新的函数。下面是一个最简单的装饰器结构：</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-comment"># 在这里添加增强功能的代码</span>
        result = func(*args, **kwargs)
        <span class="hljs-comment"># 在这里添加增强功能的代码</span>
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> wrapper</code></pre>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol>
<li><p><strong>decorator 函数</strong>：</p>
<ul>
<li><code>decorator(func)</code> 是装饰器函数，它接受一个函数 <code>func</code> 作为参数。</li>
<li><code>func</code> 是你想要增强或修改的函数。</li>
</ul>
</li>
<li><p><strong>wrapper 函数</strong>：</p>
<ul>
<li>在 <code>decorator</code> 函数内部定义了一个 <code>wrapper</code> 函数。</li>
<li><code>wrapper(*args, **kwargs)</code> 是一个包装函数，它接受任意数量的参数和关键字参数，并将它们传递给原始函数 <code>func</code>。</li>
<li><code>*args</code> 和 <code>**kwargs</code> 确保 <code>wrapper</code> 能处理所有类型的参数（位置参数和关键字参数），与 <code>func</code> 的参数一致。</li>
</ul>
</li>
<li><p><strong>增强功能</strong>：</p>
<ul>
<li>在 <code>wrapper</code> 函数中，你可以在调用原始函数 <code>func</code> 前后添加增强功能的代码。</li>
<li>例如，你可以在调用 <code>func</code> 前记录开始时间，在调用 <code>func</code> 后记录结束时间，并计算运行时间。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li><code>wrapper</code> 函数调用 <code>func(*args, **kwargs)</code> 并将结果存储在 <code>result</code> 变量中。</li>
<li><code>wrapper</code> 函数最终返回 <code>result</code>，即原始函数的返回值。</li>
</ul>
</li>
<li><p><strong>返回 wrapper</strong>：</p>
<ul>
<li><code>decorator</code> 函数返回 <code>wrapper</code> 函数。</li>
<li>这意味着当你用 <code>@decorator</code> 语法装饰一个函数时，这个函数会被 <code>wrapper</code> 替代，增强功能也随之生效。</li>
</ul>
</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>我们来看一个实际应用的例子，使用装饰器来记录函数的执行时间：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 定义装饰器函数</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">record_time</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        start_time = time.time()  <span class="hljs-comment"># 计时开始</span>
        result = func(*args, **kwargs)
        end_time = time.time()    <span class="hljs-comment"># 计时结束</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func.__name__&#125;</span> executed in <span class="hljs-subst">&#123;end_time - start_time&#125;</span> seconds&quot;</span>)
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment"># 使用装饰器</span>
<span class="hljs-meta">@record_time</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">file</span>):
    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟上传文件的延时</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Uploading <span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)

<span class="hljs-meta">@record_time</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">file</span>):
    time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟下载文件的延时</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Downloading <span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)

<span class="hljs-comment"># 调用被装饰的函数</span>
upload(<span class="hljs-string">&quot;file1.txt&quot;</span>)
download(<span class="hljs-string">&quot;file2.txt&quot;</span>)</code></pre>

<h3 id="详细解释实际应用"><a href="#详细解释实际应用" class="headerlink" title="详细解释实际应用"></a>详细解释实际应用</h3><ol>
<li><p><strong>定义装饰器</strong>：</p>
<ul>
<li><code>record_time</code> 函数是装饰器，它接受一个函数 <code>func</code> 作为参数。</li>
</ul>
</li>
<li><p><strong>定义 wrapper</strong>：</p>
<ul>
<li><code>wrapper(*args, **kwargs)</code> 函数在 <code>record_time</code> 内部定义。</li>
<li><code>start_time = time.time()</code> 记录函数执行开始时间。</li>
<li><code>result = func(*args, **kwargs)</code> 调用原始函数 <code>func</code>，并传递所有参数。</li>
<li><code>end_time = time.time()</code> 记录函数执行结束时间。</li>
<li><code>print(f&quot;&#123;func.__name__&#125; executed in &#123;end_time - start_time&#125; seconds&quot;)</code> 打印函数的执行时间。</li>
<li><code>return result</code> 返回原始函数的返回值。</li>
</ul>
</li>
<li><p><strong>返回 wrapper</strong>：</p>
<ul>
<li><code>record_time</code> 函数返回 <code>wrapper</code> 函数。</li>
</ul>
</li>
<li><p><strong>使用装饰器</strong>：</p>
<ul>
<li>使用 <code>@record_time</code> 语法将 <code>upload</code> 和 <code>download</code> 函数装饰。</li>
<li>这意味着 <code>upload</code> 和 <code>download</code> 函数实际上是 <code>wrapper</code> 函数。</li>
</ul>
</li>
<li><p><strong>调用被装饰的函数</strong>：</p>
<ul>
<li>调用 <code>upload(&quot;file1.txt&quot;)</code> 时，实际上调用的是 <code>wrapper(&quot;file1.txt&quot;)</code>。</li>
<li><code>wrapper</code> 函数记录开始时间，调用原始 <code>upload</code> 函数，记录结束时间，并打印执行时间。</li>
<li><code>download(&quot;file2.txt&quot;)</code> 的过程相同。</li>
</ul>
</li>
</ol>
<p>通过这种方式，我们将记录时间的逻辑与具体的业务逻辑分离，使代码更加清晰和模块化。</p>
<h2 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h2><p><code>itertools</code> 模块是 Python 的一个标准库模块，提供了许多用于高效循环和迭代的函数工具。这个模块包含了一组用于处理迭代器的函数，能够实现复杂的迭代逻辑。以下是 <code>itertools</code> 模块中一些常用功能及其简要介绍：</p>
<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><ol>
<li><p>**<code>count(start=0, step=1)</code>**：</p>
<ul>
<li>创建一个无限迭代器，从 <code>start</code> 开始，步长为 <code>step</code>。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.count(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>):
    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">20</span>:
        <span class="hljs-keyword">break</span>
    <span class="hljs-built_in">print</span>(i)</code></pre></li>
</ul>
</li>
<li><p>**<code>cycle(iterable)</code>**：</p>
<ul>
<li>创建一个无限迭代器，从给定的 <code>iterable</code> 中重复迭代元素。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
count = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.cycle(<span class="hljs-string">&#x27;AB&#x27;</span>):
    <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">5</span>:
        <span class="hljs-keyword">break</span>
    <span class="hljs-built_in">print</span>(item)
    count += <span class="hljs-number">1</span></code></pre></li>
</ul>
</li>
<li><p>**<code>repeat(object, times=None)</code>**：</p>
<ul>
<li>创建一个迭代器，重复给定的对象 <code>times</code> 次。如果 <code>times</code> 为 <code>None</code>，则无限重复。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.repeat(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">3</span>):
    <span class="hljs-built_in">print</span>(item)</code></pre></li>
</ul>
</li>
<li><p>**<code>chain(*iterables)</code>**：</p>
<ul>
<li>将多个迭代器连接成一个迭代器。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.chain(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-string">&#x27;DEF&#x27;</span>):
    <span class="hljs-built_in">print</span>(item)</code></pre></li>
</ul>
</li>
<li><p>**<code>islice(iterable, start, stop, step=1)</code>**：</p>
<ul>
<li>创建一个迭代器，从 <code>iterable</code> 中切片，类似于列表切片。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.islice(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>):
    <span class="hljs-built_in">print</span>(item)		<span class="hljs-comment">#C	D	E	F</span></code></pre></li>
</ul>
</li>
<li><p>**<code>compress(data, selectors)</code>**：</p>
<ul>
<li>过滤 <code>data</code> 中的元素，只保留与 <code>selectors</code> 中的<strong>真值</strong>对应的元素。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
data = <span class="hljs-string">&#x27;ABCDEF&#x27;</span>
selectors = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.compress(data, selectors)))		<span class="hljs-comment">#[&#x27;A&#x27;, &#x27;C&#x27;, &#x27;E&#x27;]</span></code></pre></li>
</ul>
</li>
<li><p>**<code>permutations(iterable, r=None)</code>**：</p>
<ul>
<li>返回 <code>iterable</code> 中元素的所有可能排列，长度为 <code>r</code>。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.permutations(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-number">2</span>)))</code></pre></li>
</ul>
</li>
<li><p>**<code>combinations(iterable, r)</code>**：</p>
<ul>
<li>返回 <code>iterable</code> 中元素的所有可能组合，长度为 <code>r</code>。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.combinations(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-number">2</span>)))	<span class="hljs-comment">#[(&#x27;A&#x27;, &#x27;B&#x27;), (&#x27;A&#x27;, &#x27;C&#x27;), (&#x27;B&#x27;, &#x27;C&#x27;)]</span></code></pre></li>
</ul>
</li>
<li><p>**<code>combinations_with_replacement(iterable, r)</code>**：</p>
<ul>
<li>返回 <code>iterable</code> 中元素的所有可能组合，长度为 <code>r</code>，允许元素重复。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.combinations_with_replacement(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-number">2</span>)))
<span class="hljs-comment"># [(&#x27;A&#x27;, &#x27;A&#x27;), (&#x27;A&#x27;, &#x27;B&#x27;), (&#x27;A&#x27;, &#x27;C&#x27;), (&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;B&#x27;, &#x27;C&#x27;), (&#x27;C&#x27;, &#x27;C&#x27;)]</span></code></pre></li>
</ul>
</li>
<li><p>**<code>product(*iterables, repeat=1)</code>**：</p>
<ul>
<li>返回多个迭代器的笛卡尔积，可以通过 <code>repeat</code> 参数指定重复次数。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.product(<span class="hljs-string">&#x27;AB&#x27;</span>, <span class="hljs-string">&#x27;CD&#x27;</span>)))</code></pre></li>
</ul>
</li>
<li><p>**<code>groupby(iterable, key=None)</code>**：</p>
<ul>
<li>对 <code>iterable</code> 中的相邻元素进行分组，<code>key</code> 为分组依据的函数。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
data = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">4</span>)]
<span class="hljs-keyword">for</span> key, group <span class="hljs-keyword">in</span> itertools.groupby(data, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]):
    <span class="hljs-built_in">print</span>(key, <span class="hljs-built_in">list</span>(group))</code></pre></li>
</ul>
</li>
</ol>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><code>itertools</code> 模块提供了一组非常有用的迭代器工具，这些工具在处理大数据集、生成无限序列、组合和排列等任务中非常高效。通过这些工具，能够简化代码、提高执行效率，同时保持代码的可读性和可维护性。</p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>Python提供了<code>re</code>模块来支持正则表达式相关操作，下面是<code>re</code>模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>compile(pattern, flags=0)</code></td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td><code>match(pattern, string, flags=0)</code></td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回<code>None</code></td>
</tr>
<tr>
<td><code>search(pattern, string, flags=0)</code></td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回<code>None</code></td>
</tr>
<tr>
<td><code>split(pattern, string, maxsplit=0, flags=0)</code></td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td><code>sub(pattern, repl, string, count=0, flags=0)</code></td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用<code>count</code>指定替换的次数</td>
</tr>
<tr>
<td><code>fullmatch(pattern, string, flags=0)</code></td>
<td><code>match</code>函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td><code>findall(pattern, string, flags=0)</code></td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td><code>finditer(pattern, string, flags=0)</code></td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td><code>purge()</code></td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td><code>re.I</code> &#x2F; <code>re.IGNORECASE</code></td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td><code>re.M</code> &#x2F; <code>re.MULTILINE</code></td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 上面提到的<code>re</code>模块中的这些函数，实际开发中也可以用正则表达式对象（<code>Pattern</code>对象）的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过<code>compile</code>函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>
<p>正则表达式对象（<code>Pattern</code> 对象）的方法主要包括以下几个：</p>
<ol>
<li><strong><code>match</code></strong>: 尝试从字符串的开始位置匹配模式。</li>
<li><strong><code>search</code></strong>: 在字符串中搜索模式的第一次出现。</li>
<li><strong><code>findall</code></strong>: 返回字符串中所有非重叠匹配的列表。</li>
<li><strong><code>finditer</code></strong>: 返回一个迭代器，产生字符串中所有非重叠匹配的<code>Match</code>对象。</li>
<li><strong><code>split</code></strong>: 根据模式匹配分割字符串，并返回分割后的列表。</li>
<li><strong><code>sub</code></strong>: 使用替换字符串替换模式匹配的所有部分。</li>
<li><strong><code>subn</code></strong>: 执行和<code>sub</code>方法相同的操作，但返回一个元组，其中包含新字符串和替换总数。</li>
</ol>
<p>以下是每个方法的简单示例：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> re

<span class="hljs-comment"># 定义一个Pattern对象</span>
pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)	<span class="hljs-comment">#匹配数字</span>

<span class="hljs-comment"># match方法</span>
m = pattern.<span class="hljs-keyword">match</span>(<span class="hljs-string">&quot;123abc&quot;</span>)
<span class="hljs-keyword">if</span> m:
    <span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># 输出: 123</span>

<span class="hljs-comment"># search方法</span>
s = pattern.search(<span class="hljs-string">&quot;abc123&quot;</span>)
<span class="hljs-keyword">if</span> s:
    <span class="hljs-built_in">print</span>(s.group())  <span class="hljs-comment"># 输出: 123</span>

<span class="hljs-comment"># findall方法</span>
f = pattern.findall(<span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(f)  <span class="hljs-comment"># 输出: [&#x27;123&#x27;, &#x27;456&#x27;]</span>

<span class="hljs-comment"># finditer方法</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> pattern.finditer(<span class="hljs-string">&quot;abc123def456&quot;</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">match</span>.group())  <span class="hljs-comment"># 输出: 123  456</span>

<span class="hljs-comment"># split方法</span>
split_result = pattern.split(<span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(split_result)  <span class="hljs-comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;&#x27;]</span>

<span class="hljs-comment"># sub方法</span>
sub_result = pattern.sub(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(sub_result)  <span class="hljs-comment"># 输出: abc-def-</span>

<span class="hljs-comment"># subn方法</span>
subn_result = pattern.subn(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(subn_result)  <span class="hljs-comment"># 输出: (&#x27;abc-def-&#x27;, 2)</span></code></pre>

<p>这些方法提供了强大的文本处理能力，使正则表达式在字符串操作中非常有用。</p>
<h2 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h2><p>[python] <code>asyncio</code>模块是Python标准库中的一个库，用于编写并发代码。它主要用于构建异步I&#x2F;O操作，可以用来处理网络连接、文件读写等需要等待的任务。通过<code>asyncio</code>，你可以编写非阻塞代码，这样可以提高程序的效率和响应速度。以下是<code>asyncio</code>模块的一些主要功能和概念：</p>
<h3 id="主要功能和概念"><a href="#主要功能和概念" class="headerlink" title="主要功能和概念"></a>主要功能和概念</h3><ol>
<li><p><strong>事件循环</strong> (<code>Event Loop</code>):</p>
<ul>
<li><code>asyncio</code>的核心是事件循环。事件循环负责调度和执行异步任务。你可以通过<code>asyncio.get_event_loop()</code>获取当前的事件循环。</li>
</ul>
</li>
<li><p><strong>协程</strong> (<code>Coroutine</code>):</p>
<ul>
<li>协程是Python中实现异步编程的基础。协程通过<code>async def</code>定义，可以使用<code>await</code>关键字等待异步操作完成。</li>
</ul>
</li>
<li><p><strong>任务</strong> (<code>Task</code>):</p>
<ul>
<li>任务是对协程的进一步封装，使其可以被调度执行。你可以使用<code>asyncio.create_task()</code>或<code>loop.create_task()</code>来创建一个任务。</li>
</ul>
</li>
<li><p><strong>未来对象</strong> (<code>Future</code>):</p>
<ul>
<li><code>Future</code>对象是一个低级别的同步原语，表示一个将来可能完成的操作。通常不直接使用，而是通过更高级的任务和协程来间接使用。</li>
</ul>
</li>
<li><p><strong>异步I&#x2F;O操作</strong>:</p>
<ul>
<li><code>asyncio</code>提供了一组异步I&#x2F;O操作的API，如<code>asyncio.open_connection()</code>、<code>asyncio.start_server()</code>等，用于处理网络连接。</li>
</ul>
</li>
<li><p><strong>同步原语</strong>:</p>
<ul>
<li><code>asyncio</code>还提供了一些用于协程间同步的原语，如锁、事件、条件变量和信号量。</li>
</ul>
</li>
</ol>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的<code>asyncio</code>示例，展示如何定义和运行协程：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;World&quot;</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 创建多个任务</span>
    task1 = asyncio.create_task(say_hello())
    task2 = asyncio.create_task(say_hello())
    
    <span class="hljs-comment"># 等待所有任务完成</span>
    <span class="hljs-keyword">await</span> task1
    <span class="hljs-keyword">await</span> task2

<span class="hljs-comment"># 获取事件循环并运行主协程</span>
asyncio.run(main())</code></pre>

<h3 id="详细功能介绍"><a href="#详细功能介绍" class="headerlink" title="详细功能介绍"></a>详细功能介绍</h3><ol>
<li><p><strong>事件循环</strong>:</p>
 <pre><code class="hljs python">loop = asyncio.get_event_loop()  <span class="hljs-comment"># 获取事件循环</span>
loop.run_until_complete(main())  <span class="hljs-comment"># 运行直到主协程完成</span>
loop.close()  <span class="hljs-comment"># 关闭事件循环</span></code></pre>
</li>
<li><p><strong>协程</strong>:</p>
 <pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>():
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟I/O操作</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data&quot;</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    data = <span class="hljs-keyword">await</span> fetch_data()  <span class="hljs-comment"># 等待协程完成</span>
    <span class="hljs-built_in">print</span>(data)

asyncio.run(main())</code></pre>
</li>
<li><p><strong>任务</strong>:</p>
 <pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;World&quot;</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    task = asyncio.create_task(say_hello())  <span class="hljs-comment"># 创建任务</span>
    <span class="hljs-keyword">await</span> task  <span class="hljs-comment"># 等待任务完成</span>

asyncio.run(main())</code></pre>
</li>
<li><p><strong>同步原语</strong>:</p>
 <pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">lock</span>):
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Worker is working&quot;</span>)
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Worker is done&quot;</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    lock = asyncio.Lock()  <span class="hljs-comment"># 创建锁</span>
    <span class="hljs-keyword">await</span> asyncio.gather(worker(lock), worker(lock))  <span class="hljs-comment"># 并发运行两个工作协程</span>

asyncio.run(main())</code></pre></li>
</ol>
<p>通过<code>asyncio</code>模块，Python程序可以更高效地处理并发任务，特别是那些涉及大量I&#x2F;O操作的任务。它是Python异步编程的一个重要工具。</p>
<h2 id="Aiohttp库"><a href="#Aiohttp库" class="headerlink" title="Aiohttp库"></a>Aiohttp库</h2><p>Aiohttp 是一个用于 Python 编程的异步 HTTP 客户端和服务器库。它使用 Python 的 <code>asyncio</code> 库实现异步编程，从而允许处理大量并发请求而不阻塞程序执行。Aiohttp 的主要功能包括：</p>
<ol>
<li><p><strong>异步 HTTP 客户端</strong>：</p>
<ul>
<li>可以发送 HTTP 请求并异步接收响应。</li>
<li>支持 HTTP&#x2F;1.1 和 WebSocket 协议。</li>
<li>提供了丰富的功能，例如会话处理、cookie、代理等。</li>
</ul>
</li>
<li><p><strong>异步 HTTP 服务器</strong>：</p>
<ul>
<li>可以创建高效的异步 Web 服务器来处理 HTTP 请求。</li>
<li>支持路由、URL 参数、查询字符串、表单数据等。</li>
<li>提供了中间件、请求和响应对象等功能，便于处理和扩展。</li>
</ul>
</li>
<li><p><strong>WebSocket 支持</strong>：</p>
<ul>
<li>支持 WebSocket 协议，方便创建实时通信应用。</li>
<li>可以在客户端和服务器之间进行全双工通信。</li>
</ul>
</li>
</ol>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/正则表达式入门/" title="正则表达式入门">
                    正则表达式入门
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/正则表达式/">正则表达式</a></li>
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>
<h2 id="如何使用本教程"><a href="#如何使用本教程" class="headerlink" title="如何使用本教程"></a>如何使用本教程</h2><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。</p>
<p>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？</p>
<p><a href="https://deerchao.cn/tutorials/regex/regex.htm">清除格式</a> 文本格式约定：<strong>专业术语</strong> 元字符&#x2F;语法格式 正则表达式 正则表达式中的一部分(用于分析) <em>对其进行匹配的源字符串</em> 对正则表达式或其中一部分的说明</p>
<p><a href="https://deerchao.cn/tutorials/regex/regex.htm">隐藏边注</a> 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。</p>
<p>本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看<a href="https://deerchao.cn/tutorials/regex/diffs.html">正则表达式引擎特性对比</a>。</p>
<p>最重要的是——请给我<em>30分钟</em>，如果你没有使用正则表达式的经验，请不要试图在30<em>秒</em>内入门——除非你是超人 :)</p>
<h2 id="正则表达式到底是什么东西？"><a href="#正则表达式到底是什么东西？" class="headerlink" title="正则表达式到底是什么东西？"></a>正则表达式到底是什么东西？</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>很可能你使用过Windows&#x2F;Dos下用于文件查找的*<em>通配符(wildcard)*<em>，也就是</em>和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，</em>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像<em>010-12345678</em>或<em>0376-7654321</em>)。</p>
<p><strong>字符</strong>是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。<strong>字符串</strong>是0个或更多个字符的序列。<strong>文本</strong>也就是文字，字符串。说某个字符串<strong>匹配</strong>某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。</p>
<p>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。</p>
<p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<em>hi</em>,<em>HI</em>,<em>Hi</em>,<em>hI</em>这四种情况中的任意一种。</p>
<p>不幸的是，很多单词里包含<em>hi</em>这两个连续的字符，比如<em>him</em>,<em>history</em>,<em>high</em>等等。用hi来查找的话，这里边的<em>hi</em>也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。</p>
<p>\b是正则表达式规定的一个特殊代码（好吧，某些人叫它<strong>元字符，metacharacter</strong>），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p>
<p>如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。</p>
<p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。</p>
<p>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p>
<p>换行符就是’\n’,ASCII编码为10(十六进制0x0A)的字符。</p>
<p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p>
<p>0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>
<p>这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。</p>
<p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。</p>
<h2 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h2><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。</p>
<p>不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.x 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 <a href="https://deerchao.cn/tools/regester/">Regester</a>。请参考该页面的说明来安装和运行该软件。</p>
<p>下面是Regester运行时的截图：</p>
<p><a href="https://deerchao.cn/tools/regester/"><img src="https://deerchao.cn/tools/regester/zh.png" alt="正则表达式测试器运行截图"></a></p>
<p>你也可以试试这个在线测试工具：<a href="https://deerchao.cn/tools/wegester/">Wegester, JavaScript正则表达式测试器。</a></p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p>
<p>对中文&#x2F;汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。</p>
<p>下面来看看更多的例子：</p>
<p>\ba\w<em>\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w</em>)，最后是单词结束处(\b)。</p>
<p>\d+匹配1个或更多连续的数字。这里的+是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p>
<p>\b\w{6}\b 匹配刚好6个字符的单词。</p>
<p>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody></table>
<p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。</p>
<p>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p>
<p>因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p>
<p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p>
<p>正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。</p>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\.</p>
<p>例如：deerchao.cn匹配deerchao.cn，C:\Windows匹配C:\Windows。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：</p>
<table>
<thead>
<tr>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>下面是一些使用重复的例子：</p>
<p>Windows\d+匹配Windows后面跟1个或更多数字</p>
<p>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>
<p>我们也可以轻松地指定一个字符<strong>范围</strong>，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p>
<p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。</p>
<p><strong><code>[) -]?</code></strong>:匹配一个可选的字符，可以是右括号 <code>)</code>、空格 或连字符 <code>-</code>。<code>[]</code> 表示字符集，包含在其中的任意一个字符都可以匹配。<code>?</code> 表示前面的元素是可选的，即出现零次或一次。</p>
<p>这个表达式可以匹配几种格式的电话号码，像*(010)88886666<em>，或</em>022-22334455<em>，或</em>02912345678*等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
<p>“(”和“)”也是元字符，后面的<a href="https://deerchao.cn/tutorials/regex/regex.htm#grouping">分组节</a>里会提到，所以在这里需要使用<a href="https://deerchao.cn/tutorials/regex/regex.htm#escape">转义</a>。</p>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配<em>010)12345678</em>或*(022-87654321*这样的“不正确”的格式。要解决这个问题，我们需要用到<strong>分枝条件</strong>。正则表达式里的<strong>分枝条件</strong>指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>
<p>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>
<p>(0\d{2})[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>
<p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>
<p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p>
<p>不幸的是，它也将匹配<em>256.300.888.999</em>这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p>
<p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong>：</p>
<table>
<thead>
<tr>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<p>例子：\S+匹配不包含空白符的字符串。</p>
<p>&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>呃……其实,组号分配还不像我刚说得那么简单：</p>
<ul>
<li>分组0对应整个正则表达式</li>
<li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li>
<li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li>
</ul>
<p><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：</p>
<p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像<em>go go</em>, 或者<em>kitty kitty</em>。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。</p>
<p>你也可以自己指定子表达式的<strong>组名</strong>。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组<strong>捕获</strong>的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。</p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>捕获</td>
<td>(exp)</td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td>(?<name>exp)</td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
<td></td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
<td></td>
</tr>
<tr>
<td>零宽断言</td>
<td>(?&#x3D;exp)</td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td>(?&lt;&#x3D;exp)</td>
<td>匹配exp后面的位置</td>
<td></td>
</tr>
<tr>
<td>(?!exp)</td>
<td>匹配后面跟的不是exp的位置</td>
<td></td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
<td></td>
</tr>
<tr>
<td>注释</td>
<td>(?#comment)</td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody></table>
<p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为<strong>零宽断言</strong>。最好还是拿例子来说明吧：</p>
<p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p>
<p>(?&#x3D;exp)也叫<strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?&#x3D;ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找*I’m singing while you’re dancing.*时，它会匹配sing和danc。</p>
<p>(?&lt;&#x3D;exp)也叫<strong>零宽度正回顾后发断言</strong>，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;&#x3D;\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<em>reading a book</em>时，它匹配ading。</p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;&#x3D;\d)\d{3})+\b，用它对<em>1234567890</em>进行查找时结果是234567890。</p>
<p>下面这个例子同时使用了这两种断言：(?&lt;&#x3D;\s)\d+(?&#x3D;\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p>
<p>\b\w<em>q[^u]\w</em>\b匹配包含<strong>后面不是字母u的字母q</strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w<em>\b将会匹配下一个单词，于是\b\w</em>q[^u]\w<em>\b就能匹配整个</em>Iraq fighting<em>。<strong>负向零宽断言</strong>能解决这样的问题，因为它只匹配一个位置，并不<strong>消费</strong>任何字符。现在，我们可以这样来解决这个问题：\b\w</em>q(?!u)\w*\b。</p>
<p><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p>
<p>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言</strong>来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。</p>
<p>一个更复杂的例子：(?&lt;&#x3D;&lt;(\w+)&gt;).<em>(?&#x3D;&lt;/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;&#x3D;&lt;(\w+)&gt;)指定了这样的<strong>前缀</strong>：被尖括号括起来的单词(比如可能是<b>)，然后是.</em>(任意的字符串),最后是一个<strong>后缀</strong>(?&#x3D;&lt;/\1&gt;)。注意后缀里的/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25<a href="?#250-255">0-5</a>|[01]?\d\d?(?#0-199)。</p>
<p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p>
<pre><code class="hljs plaintext">(?&lt;=    # 断言要匹配的文本的前缀
&lt;(\w+)&gt; # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
&lt;\/\1&gt;  # 查找尖括号括起来的内容
        # 查找尖括号括起来的内容
)       # 后缀结束</code></pre>

<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.<em>b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索</em>aabab*的话，它会匹配整个字符串aabab。这被称为<strong>贪婪</strong>匹配。</p>
<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>
<p>a.<em>?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于</em>aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>
<p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p>
<table>
<thead>
<tr>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IgnoreCase(忽略大小写)</td>
<td>匹配时不区分大小写。</td>
</tr>
<tr>
<td>Multiline(多行模式)</td>
<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</td>
</tr>
<tr>
<td>Singleline(单行模式)</td>
<td>更改.的含义，使它与每一个字符匹配（包括换行符\n）。</td>
</tr>
<tr>
<td>IgnorePatternWhitespace(忽略空白)</td>
<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>
</tr>
<tr>
<td>ExplicitCapture(显式捕获)</td>
<td>仅捕获已被显式命名的组。</td>
</tr>
</tbody></table>
<p>在C#中，你可以使用<a href="http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx">Regex(String, RegexOptions)构造函数</a>来设置正则表达式的处理选项。如：Regex regex &#x3D; new Regex(@”\ba\w{6}\b”, RegexOptions.IgnoreCase);</p>
<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s.</p>
<p>目前（2019&#x2F;06），只有基于 Webkit&#x2F;Chromium 的浏览器（如 Chrome, Safari等）才支持 dotAll 选项。</p>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组&#x2F;递归匹配"></a>平衡组&#x2F;递归匹配</h2><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如*( 5 &#x2F; ( 3 + 2 ) ) )*，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p>
<p>这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p>
<p>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把<em>xx &lt;aa <bbb> <bbb> aa&gt; yy</em>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p>
<p>这里需要用到以下的语法构造：</p>
<ul>
<li>(?’group’) 把捕获的内容命名为group,并压入<strong>堆栈(Stack)</strong></li>
<li>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>
<li>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>
<li>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>
</ul>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>
<pre><code class="hljs plaintext">&lt;                   #最外层的左括号
  [^&lt;&gt;]*            #它后面非括号的内容
  (
      (
        (?&#x27;Open&#x27;&lt;)  #左括号，压入&quot;Open&quot;
        [^&lt;&gt;]*      #左括号后面的内容
      )+
      (
        (?&#x27;-Open&#x27;&gt;) #右括号，弹出一个&quot;Open&quot;
        [^&lt;&gt;]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的&quot;Open&quot;
                    #则匹配失败

&gt;                #最外层的右括号</code></pre>

<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：&lt;div[^&gt;]<em>&gt;[^&lt;&gt;]</em>(((?’Open’&lt;div[^&gt;]<em>&gt;)[^&lt;&gt;]</em>)+((?’-Open’</div>)[^&lt;&gt;]<em>)+)</em>(?(Open)(?!))</div>.</p>
<p>如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。</p>
<h2 id="还有些什么东西没提到"><a href="#还有些什么东西没提到" class="headerlink" title="还有些什么东西没提到"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看<a href="http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx">关于正则表达式语言元素的MSDN在线文档</a>。</p>
<table>
<thead>
<tr>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>报警字符(打印它的效果是电脑嘀一声)</td>
</tr>
<tr>
<td>\b</td>
<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，Tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\v</td>
<td>竖向制表符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape</td>
</tr>
<tr>
<td>\0nn</td>
<td>ASCII代码中八进制代码为nn的字符</td>
</tr>
<tr>
<td>\xnn</td>
<td>ASCII代码中十六进制代码为nn的字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>Unicode代码中十六进制代码为nnnn的字符</td>
</tr>
<tr>
<td>\cN</td>
<td>ASCII控制字符。比如\cC代表Ctrl+C</td>
</tr>
<tr>
<td>\A</td>
<td>字符串开头(类似^，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\Z</td>
<td>字符串结尾或行尾(不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\z</td>
<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\G</td>
<td>当前搜索的开头</td>
</tr>
<tr>
<td>\p{name}</td>
<td>Unicode中命名为name的字符类，例如\p{IsGreek}</td>
</tr>
<tr>
<td>(?&gt;exp)</td>
<td>贪婪子表达式</td>
</tr>
<tr>
<td>(?<x>-<y>exp)</td>
<td>平衡组</td>
</tr>
<tr>
<td>(?im-nsx:exp)</td>
<td>在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td>(?im-nsx)</td>
<td>为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td>(?(exp)yes|no)</td>
<td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>
</tr>
<tr>
<td>(?(exp)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td>(?(name)yes|no)</td>
<td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>
</tr>
<tr>
<td>(?(name)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
</tbody></table>
<h2 id="网上的资源及本文参考文献"><a href="#网上的资源及本文参考文献" class="headerlink" title="网上的资源及本文参考文献"></a>网上的资源及本文参考文献</h2><ul>
<li><a href="https://u.jd.com/0yfKdc">精通正则表达式(第3版)</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions">微软的正则表达式教程</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex">Regex类(微软文档)</a></li>
<li><a href="http://www.regular-expressions.info/">专业的正则表达式教学网站(英文)</a></li>
<li><a href="http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx">关于.Net下的平衡组的详细讨论（英文）</a></li>
</ul>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/面对对象编程应用/" title="面向编程应用">
                    面向编程应用
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="面向对象编程应用"><a href="#面向对象编程应用" class="headerlink" title="面向对象编程应用"></a>面向对象编程应用</h2><p>面向对象编程对初学者来说不难理解但很难应用，虽然我们为大家总结过面向对象的三步走方法（定义类、创建对象、给对象发消息），但是说起来容易做起来难。<strong>大量的编程练习</strong>和<strong>阅读优质的代码</strong>可能是这个阶段最能够帮助到大家的两件事情。接下来我们还是通过经典的案例来剖析面向对象编程的知识，同时也通过这些案例把我们之前学过的 Python 知识都串联起来。</p>
<h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="案例1：扑克游戏。"><a href="#案例1：扑克游戏。" class="headerlink" title="案例1：扑克游戏。"></a>案例1：扑克游戏。</h4><blockquote>
<p><strong>说明</strong>：简单起见，我们的扑克只有52张牌（没有大小王），游戏需要将52张牌发到4个玩家的手上，每个玩家手上有13张牌，按照黑桃、红心、草花、方块的顺序和点数从小到大排列，暂时不实现其他的功能。</p>
</blockquote>
<p>使用面向对象编程方法，首先需要从问题的需求中找到对象并抽象出对应的<strong>类</strong>，此外还要找到<strong>对象的属性和行为</strong>。当然，这件事情并不是特别困难，我们可以从需求的描述中<strong>找出名词和动词</strong>，名词通常就是对象或者是对象的属性，而动词通常是对象的行为。扑克游戏中至少应该有三类对象，分别是<strong>牌、扑克和玩家</strong>，牌、扑克、玩家三个类也并不是孤立的。类和类之间的关系可以粗略的分为<strong>is-a关系（继承）</strong>、<strong>has-a关系（关联）</strong>和<strong>use-a关系（依赖）</strong>。很显然扑克和牌是has-a关系，因为一副扑克有（has-a）52张牌；玩家和牌之间不仅有关联关系还有依赖关系，因为玩家手上有（has-a）牌而且玩家使用了（use-a）牌。</p>
<ol>
<li><strong>牌（Card）</strong><ul>
<li>属性：<ul>
<li><strong>花色（suit）</strong>：黑桃、红心、草花、方块</li>
<li><strong>点数（rank）</strong>：1 到 13（A到K）</li>
</ul>
</li>
<li><strong>行为</strong>：牌本身在这个简化的例子中没有特殊行为，只是数据的集合。</li>
</ul>
</li>
<li><strong>扑克（Deck）</strong><ul>
<li>属性：<ul>
<li><strong>牌的集合（cards）</strong>：52张牌的列表</li>
</ul>
</li>
<li>行为：<ul>
<li><strong>洗牌（shuffle）</strong>：随机打乱牌的顺序</li>
<li><strong>发牌（deal）</strong>：将牌分发给玩家</li>
</ul>
</li>
</ul>
</li>
<li><strong>玩家（Player）</strong><ul>
<li>属性：<ul>
<li><strong>手牌（hand）</strong>：玩家手上的牌</li>
</ul>
</li>
<li>行为：<ul>
<li><strong>接牌（receive_card）</strong>：从扑克中获取一张牌并加入手牌</li>
<li><strong>显示手牌（show_hand）</strong>：显示玩家手上的牌</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>类与类之间的关系</strong></p>
<p>在面向对象编程中，类与类之间的关系可以分为几种常见类型：</p>
<ol>
<li><strong>is-a 关系（继承）</strong>：表示一种类是另一种类的特殊化。例如，如果我们有一种更通用的牌类（比如 <code>Card</code>）和一种特殊的牌类（比如 <code>JokerCard</code>），<code>JokerCard</code> 可以继承 <code>Card</code>，表示 <code>JokerCard</code> 是一种特殊的 <code>Card</code>。</li>
<li><strong>has-a 关系（关联）</strong>：表示一种类包含另一种类的实例。例如，一副扑克（<code>Deck</code>）包含52张牌（<code>Card</code>）。<code>Deck</code> 和 <code>Card</code> 之间的关系是 has-a 关系。</li>
<li><strong>use-a 关系（依赖）</strong>：表示一种类使用另一种类来完成某些功能。例如，玩家（<code>Player</code>）使用牌（<code>Card</code>）来进行游戏。玩家和牌之间既有 has-a 关系（玩家拥有牌），也有 use-a 关系（玩家使用牌）。</li>
</ol>
<p>牌的属性显而易见，有花色和点数。我们可以用0到3的四个数字来代表四种不同的花色，但是这样的代码可读性会非常糟糕，因为我们并不知道黑桃、红心、草花、方块跟0到3的数字的对应关系。如果一个变量的取值只有有限多个选项，我们可以使用枚举。与 C、Java 等语言不同的是，Python 中没有声明枚举类型的关键字，但是可以通过继承<code>enum</code>模块的<code>Enum</code>类来创建枚举类型，代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Suite</span>(<span class="hljs-title class_ inherited__">Enum</span>):
    <span class="hljs-string">&quot;&quot;&quot;花色(枚举)&quot;&quot;&quot;</span>
    SPADE, HEART, CLUB, DIAMOND = <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)</code></pre>

<p>通过上面的代码可以看出，定义枚举类型其实就是定义符号常量，如<code>SPADE</code>、<code>HEART</code>等。每个符号常量都有与之对应的值，这样表示黑桃就可以不用数字<code>0</code>，而是用<code>Suite.SPADE</code>；同理，表示方块可以不用数字<code>3</code>， 而是用<code>Suite.DIAMOND</code>。注意，使用符号常量肯定是优于使用字面常量的，因为能够读懂英文就能理解符号常量的含义，代码的可读性会提升很多。Python 中的枚举类型是可迭代类型，简单的说就是可以将枚举类型放到<code>for-in</code>循环中，依次取出每一个符号常量及其对应的值，如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">for</span> suite <span class="hljs-keyword">in</span> Suite:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;suite&#125;</span>: <span class="hljs-subst">&#123;suite.value&#125;</span>&#x27;</span>)</code></pre>

<p>接下来我们可以定义牌类。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span>:
    <span class="hljs-string">&quot;&quot;&quot;牌&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, suite, face</span>):
        <span class="hljs-variable language_">self</span>.suite = suite
        <span class="hljs-variable language_">self</span>.face = face

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        suites = <span class="hljs-string">&#x27;♠♥♣♦&#x27;</span>
        faces = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;suites[self.suite.value]&#125;</span><span class="hljs-subst">&#123;faces[self.face]&#125;</span>&#x27;</span>  <span class="hljs-comment"># 返回牌的花色和点数，[self.suite.value]就是对应列表中的值，例如返回suite[0]face[3] </span></code></pre>

<p>可以通过下面的代码来测试下<code>Card</code>类。</p>
<pre><code class="hljs Python">card1 = Card(Suite.SPADE, <span class="hljs-number">5</span>)
card2 = Card(Suite.HEART, <span class="hljs-number">13</span>)
<span class="hljs-built_in">print</span>(card1)  <span class="hljs-comment"># ♠5 </span>
<span class="hljs-built_in">print</span>(card2)  <span class="hljs-comment"># ♥K</span></code></pre>

<p>接下来我们定义扑克类。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> random


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Poker</span>:
    <span class="hljs-string">&quot;&quot;&quot;扑克&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.cards = [Card(suite, face) 	<span class="hljs-comment">#为列表生成式：[expression for item in iterable]</span>
                      <span class="hljs-keyword">for</span> suite <span class="hljs-keyword">in</span> Suite	<span class="hljs-comment">#嵌套的列表生成式，注意为一维列表</span>
                      <span class="hljs-keyword">for</span> face <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>)]  <span class="hljs-comment"># 52张牌构成的列表</span>
        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录发牌位置的属性</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;洗牌&quot;&quot;&quot;</span>
        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span>		<span class="hljs-comment"># 每次洗牌时重置发牌位置为0</span>
        random.shuffle(<span class="hljs-variable language_">self</span>.cards)  <span class="hljs-comment"># 通过random模块的shuffle函数实现随机乱序</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deal</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;发牌&quot;&quot;&quot;</span>
        card = <span class="hljs-variable language_">self</span>.cards[<span class="hljs-variable language_">self</span>.current]
        <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> card

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">has_next</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;还有没有牌可以发&quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.current &lt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.cards)</code></pre>

<blockquote>
<p>注意：<code>self.cards</code>是一维列表，这个<code>Card(suite, face) </code>是一种展示形式，并不是列表格式。</p>
<pre><code class="hljs python"><span class="hljs-variable language_">self</span>.cards = [
    Card(Suite.SPADE, <span class="hljs-number">1</span>), Card(Suite.SPADE, <span class="hljs-number">2</span>), ..., Card(Suite.SPADE, <span class="hljs-number">13</span>),
    Card(Suite.HEART, <span class="hljs-number">1</span>), Card(Suite.HEART, <span class="hljs-number">2</span>), ..., Card(Suite.HEART, <span class="hljs-number">13</span>),
    Card(Suite.CLUB, <span class="hljs-number">1</span>), Card(Suite.CLUB, <span class="hljs-number">2</span>), ..., Card(Suite.CLUB, <span class="hljs-number">13</span>),
    Card(Suite.DIAMOND, <span class="hljs-number">1</span>), Card(Suite.DIAMOND, <span class="hljs-number">2</span>), ..., Card(Suite.DIAMOND, <span class="hljs-number">13</span>)
]</code></pre>
</blockquote>
<p>可以通过下面的代码来测试下<code>Poker</code>类。</p>
<pre><code class="hljs Python">poker = Poker()
<span class="hljs-built_in">print</span>(poker.cards)  <span class="hljs-comment"># 洗牌前的牌</span>
poker.shuffle()
<span class="hljs-built_in">print</span>(poker.cards)  <span class="hljs-comment"># 洗牌后的牌</span></code></pre>

<p>定义玩家类。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>:
    <span class="hljs-string">&quot;&quot;&quot;玩家&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.cards = []  <span class="hljs-comment"># 玩家手上的牌</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_one</span>(<span class="hljs-params">self, card</span>):
        <span class="hljs-string">&quot;&quot;&quot;摸牌&quot;&quot;&quot;</span>
        <span class="hljs-variable language_">self</span>.cards.append(card)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrange</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;</span>
        <span class="hljs-variable language_">self</span>.cards.sort()</code></pre>

<p>创建四个玩家并将牌发到玩家的手上。</p>
<pre><code class="hljs Python">poker = Poker()
poker.shuffle()
players = [Player(<span class="hljs-string">&#x27;东邪&#x27;</span>), Player(<span class="hljs-string">&#x27;西毒&#x27;</span>), Player(<span class="hljs-string">&#x27;南帝&#x27;</span>), Player(<span class="hljs-string">&#x27;北丐&#x27;</span>)]
<span class="hljs-comment"># 将牌轮流发到每个玩家手上每人13张牌</span>
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>):
    <span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players:
        player.get_one(poker.deal())
<span class="hljs-comment"># 玩家整理手上的牌输出名字和手牌</span>
<span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players:
    player.arrange()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;player.name&#125;</span>: &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)
    <span class="hljs-built_in">print</span>(player.cards)</code></pre>

<p>执行上面的代码会在<code>player.arrange()</code>那里出现异常，因为<code>Player</code>的<code>arrange</code>方法使用了列表的<code>sort</code>对玩家手上的牌进行排序，排序需要比较两个<code>Card</code>对象的大小，但是Python不知道如何比较 <code>card1</code> 和 <code>card2</code>。所以就出现了<code>TypeError</code>异常，异常消息为：<code>&#39;&lt;&#39; not supported between instances of &#39;Card&#39; and &#39;Card&#39;</code>。</p>
<p>为了解决这个问题，我们可以对<code>Card</code>类的代码稍作修改，使得两个<code>Card</code>对象可以直接用<code>&lt;</code>进行大小的比较（可以理解为我们创建了一种比较方法）。这里用到技术叫<strong>运算符重载</strong>，Python 中要实现对<code>&lt;</code>运算符的重载，需要在类中添加一个名为<code>__lt__</code>的魔术方法。很显然，魔术方法<code>__lt__</code>中的<code>lt</code>是英文单词“less than”的缩写，以此类推，魔术方法<code>__gt__</code>对应<code>&gt;</code>运算符，魔术方法<code>__le__</code>对应<code>&lt;=</code>运算符，<code>__ge__</code>对应<code>&gt;=</code>运算符，<code>__eq__</code>对应<code>==</code>运算符，<code>__ne__</code>对应<code>!=</code>运算符。</p>
<p>修改后的<code>Card</code>类代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span>:
    <span class="hljs-string">&quot;&quot;&quot;牌&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, suite, face</span>):
        <span class="hljs-variable language_">self</span>.suite = suite
        <span class="hljs-variable language_">self</span>.face = face

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        suites = <span class="hljs-string">&#x27;♠♥♣♦&#x27;</span>
        faces = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;suites[self.suite.value]&#125;</span><span class="hljs-subst">&#123;faces[self.face]&#125;</span>&#x27;</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.suite == other.suite:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.face &lt; other.face   <span class="hljs-comment"># 花色相同比较点数的大小</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.suite.value &lt; other.suite.value   <span class="hljs-comment"># 花色不同比较花色对应的值</span></code></pre>

<blockquote>
<p><strong>说明：</strong> 大家可以尝试在上面代码的基础上写一个简单的扑克游戏，如21点游戏（Black Jack），游戏的规则可以自己在网上找一找。</p>
</blockquote>
<h4 id="案例2：工资结算系统。"><a href="#案例2：工资结算系统。" class="headerlink" title="案例2：工资结算系统。"></a>案例2：工资结算系统。</h4><blockquote>
<p><strong>要求</strong>：某公司有三种类型的员工，分别是部门经理、程序员和销售员。需要设计一个工资结算系统，根据提供的员工信息来计算员工的月薪。其中，部门经理的月薪是固定15000元；程序员按工作时间（以小时为单位）支付月薪，每小时200元；销售员的月薪由1800元底薪加上销售额5%的提成两部分构成。</p>
</blockquote>
<p>通过对上述需求的分析，可以看出部门经理、程序员、销售员都是员工，有相同的属性和行为，那么我们可以先设计一个名为<code>Employee</code>的父类，再通过继承的方式从这个父类派生出部门经理、程序员和销售员三个子类。很显然，后续的代码不会创建<code>Employee</code> 类的对象，因为我们需要的是具体的员工对象，所以这个类可以设计成专门用于继承的抽象类。Python 语言中没有定义抽象类的关键字，但是可以通过<code>abc</code>模块中名为<code>ABCMeta</code> 的元类来定义抽象类。关于元类的概念此处不展开讲解，当然大家不用纠结，照做即可。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>(metaclass=ABCMeta):
    <span class="hljs-string">&quot;&quot;&quot;员工&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;结算月薪&quot;&quot;&quot;</span>
        <span class="hljs-keyword">pass</span></code></pre>

<p>在上面的员工类中，有一个名为<code>get_salary</code>的方法用于结算月薪，但是由于还没有确定是哪一类员工，所以结算月薪虽然是员工的公共行为但这里却没有办法实现。对于暂时无法实现的方法，我们可以使用<code>abstractmethod</code>装饰器将其声明为抽象方法，所谓<strong>抽象方法就是只有声明没有实现的方法</strong>，<strong>声明这个方法是为了让子类去重写这个方法</strong>。接下来的代码展示了如何从员工类派生出部门经理、程序员、销售员这三个子类以及子类如何重写父类的抽象方法。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span>(<span class="hljs-title class_ inherited__">Employee</span>):
    <span class="hljs-string">&quot;&quot;&quot;部门经理&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">15000.0</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Programmer</span>(<span class="hljs-title class_ inherited__">Employee</span>):
    <span class="hljs-string">&quot;&quot;&quot;程序员&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, working_hour=<span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">super</span>().__init__(name)
        <span class="hljs-variable language_">self</span>.working_hour = working_hour

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> * <span class="hljs-variable language_">self</span>.working_hour


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Salesman</span>(<span class="hljs-title class_ inherited__">Employee</span>):
    <span class="hljs-string">&quot;&quot;&quot;销售员&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, sales=<span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">super</span>().__init__(name)
        <span class="hljs-variable language_">self</span>.sales = sales

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">1800</span> + <span class="hljs-variable language_">self</span>.sales * <span class="hljs-number">0.05</span></code></pre>

<p>上面的<code>Manager</code>、<code>Programmer</code>、<code>Salesman</code>三个类都继承自<code>Employee</code>，三个类都分别重写了<code>get_salary</code>方法。<strong>重写就是子类对父类已有的方法重新做出实现</strong>。相信大家已经注意到了，三个子类中的<code>get_salary</code>各不相同，所以这个方法在程序运行时会产生<strong>多态行为</strong>，多态简单的说就是<strong>调用相同的方法</strong>，<strong>不同的子类对象做不同的事情</strong>。</p>
<p>我们通过下面的代码来完成这个工资结算系统，由于程序员和销售员需要分别录入本月的工作时间和销售额，所以在下面的代码中我们使用了 Python 内置的<code>isinstance</code>函数来判断员工对象的类型。我们之前讲过的<code>type</code>函数也能识别对象的类型，但是<code>isinstance</code>函数更加强大，因为它可以判断出一个对象是不是某个继承结构下的子类型，你可以简单的理解为<code>type</code>函数是对对象类型的精准匹配，而<code>isinstance</code>函数是对对象类型的模糊匹配。</p>
<pre><code class="hljs Python">emps = [Manager(<span class="hljs-string">&#x27;刘备&#x27;</span>), Programmer(<span class="hljs-string">&#x27;诸葛亮&#x27;</span>), Manager(<span class="hljs-string">&#x27;曹操&#x27;</span>), Programmer(<span class="hljs-string">&#x27;荀彧&#x27;</span>), Salesman(<span class="hljs-string">&#x27;张辽&#x27;</span>)]
<span class="hljs-keyword">for</span> emp <span class="hljs-keyword">in</span> emps:
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(emp, Programmer):
        emp.working_hour = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">f&#x27;请输入<span class="hljs-subst">&#123;emp.name&#125;</span>本月工作时间: &#x27;</span>))
    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(emp, Salesman):
        emp.sales = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">f&#x27;请输入<span class="hljs-subst">&#123;emp.name&#125;</span>本月销售额: &#x27;</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;emp.name&#125;</span>本月工资为: ￥<span class="hljs-subst">&#123;emp.get_salary():<span class="hljs-number">.2</span>f&#125;</span>元&#x27;</span>)</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向对象的编程思想非常的好，也符合人类的正常思维习惯，但是要想灵活运用面向对象编程中的抽象、封装、继承、多态需要长时间的积累和沉淀，这件事情无法一蹴而就，因为知识的积累本就是涓滴成河的过程。</p>

        </div>
        
            
        
        
    </div>
</article>

        
        <ul class="pagination clear">
    <span class="page-number current">1</span>
</ul>
    </section>
    
<section class="tool-area">

    <div class="toolbar">
        

        
        <div class="widget-post widget" style="order: 1 ">
            <h2 class="widget-title"><i class="fa fa-file-text"></i> 近期文章</h2>
            <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/">HTTP协议入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/Python%E6%A0%87%E5%87%86%E5%BA%93%E5%88%9D%E6%8E%A2/">Python标准库初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9C%E5%90%84%E7%B1%BB%E6%96%87%E4%BB%B6/">使用Python操作各类文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/">函数的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/XML%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">XML入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A1%88%E4%BE%8B/">分支和循环案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E6%A8%A1%E5%9D%97%E6%94%B6%E9%9B%86/">模块综合</a></li></ul>
        </div>
        

        
        <div class="widget-tags widget" style="order: 2 ">
            <h2 class="widget-title"><i class="fa fa-tags"></i> 标签</h2>
            <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a>
        </div>
        

        
        <div class="widget-categories widget" style="order: 3 ">
            <h2 class="widget-title"><i class="fa fa-folder-open"></i> 分类</h2>
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E7%BB%BC%E5%90%88/">Python综合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xml/">Xml</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li></ul></li></ul>
        </div>
        

    </div>
</section>
</div>

    
        <footer class="footer">
	<p class="footer-intro">
		
		@2024 李梓卓的技术专栏.
	</p>
	<p class="footer-intro">
			Powered By <a href="https://hexo.io/zh-cn/" target="_blank">hexo</a>
			theme <a href="https://github.com/iengu/hexo-theme-mokusei" target="_blank">mokusei</a> by <a href="https://www.iengu.com" target="blank">iengu</a>
	</p>
</footer>




        <div class="extend-tools" id="extend-tools" style="display: none;">
    <ul>
        <li class="tools-returnTop" title="返回顶部"><i class="fa fa-angle-double-up"></i></li>
    </ul>
</div>

	</div>

	
<script src="/js/org/jquery.min.js"></script>

    
<script src="/js/extend.js"></script>

</body>
</html>