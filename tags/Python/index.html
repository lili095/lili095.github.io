<!DOCTYPE html>
<html lang="zh" >
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="description" content="">
	<meta name="keywords" content="">
	<title>Python - 李梓卓的技术专栏</title>
    <link rel="alternate" href="" type="application/atom+xml"/>
	<link rel="shortcut icon" href=""/>
	
<link rel="stylesheet" href="/css/style.css">

	
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
	<div class="main-con">

        <div class="nav cl">
    <ul class="cl nav-list">
        
            <li>
                
                    <a href="/" class="">
                        <i class="fa fa-home"></i> 
                        <span>主页</span>
                    </a>
                
            </li>
        
            <li>
                
                    <a href="/archives/" class="">
                        <i class=" fa-"></i> 
                        <span>归档</span>
                    </a>
                
            </li>
        
            <li>
                
                    
                    <a href="javascript:void(0)" class="">
                    
                        <i class=" fa-"></i> 
                        <span>关于</span>
                        <span class="drop-flag fa fa-angle-down"></span>
                    </a>
                    <dl>
                        
                            <li>
                                <a href="/about" class="">
                                    <i class=" fa-"></i>
                                    <span>关于本站</span>
                                </a>
                            </li>
                        
                    </dl>
                
            </li>
        
    </ul>
    <ul class="cl nav-tool">
        
            <li>
                <a href="/github">
                    <i class="fa fa-github"></i>
                </a>
            </li>
        
            <li>
                <a href="/mail">
                    <i class="fa fa-envelope"></i>
                </a>
            </li>
        
            <li>
                <a href="/twitter">
                    <i class="fa fa-twitter"></i>
                </a>
            </li>
        
        
        <li>
            <a href="javascript:void(0)" class="nav-search-btn">
                <i class="fa fa-search"></i>
            </a>
        </li>
        
    </ul>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="nav-search"><input type="search" name="q" class="nav-search-input" placeholder="search..."><input type="hidden" name="sitesearch" value="https://lili095.github.io"></form>
</div>

        <header class="top" id="fallEle" style="background-image: url(/imgs/head.jpg)">
    <i class="fa fa-bars" id="media-toggle" style="display: none"></i>
    <div class="top-info cl fadeToBottom">
        <h2 class="site-name"><a href="/">mokusei</a> <small id="type-data">This is a hexo theme</small></h2>
    </div>
</header>

        <div class="column-title fadeToTop">
    <h3><span class="title-info">标签</span> Python</h3>
</div>

<div class="con-wrap fadeToTop">
    
    <section class="article-area">
    
        
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/Python标准库初探/" title="Python标准库初探">
                    Python标准库初探
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>Python语言最可爱的地方在于它的标准库和三方库实在是太丰富了，日常开发工作中的很多任务都可以通过这些标准库或者三方库直接解决。下面我们先介绍Python标准库中的一些常用模块，后面的课程中再陆陆续续为大家介绍Python常用三方库的用途和用法。</p>
<h3 id="base64-Base64编解码模块"><a href="#base64-Base64编解码模块" class="headerlink" title="base64 - Base64编解码模块"></a>base64 - Base64编解码模块</h3><p><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的方法。由于$log _{2}64&#x3D;6$，所以Base64以6个比特（二进制位，可以表示0或1）为一个单元，每个单元对应一个可打印字符。对于3字节（24比特）的二进制数据，我们可以将其处理成对应于4个Base64单元，即3个字节可由4个可打印字符来表示。Base64编码可用来作为电子邮件的传输编码，也可以用于其他需要将二进制数据转成文本字符的场景，这使得在XML、JSON、YAML这些文本数据格式中传输二进制内容成为可能。在Base64中的可打印字符包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>，这里一共是62个字符，另外两个可打印符号通常是<code>+</code>和<code>/</code>，<code>=</code>用于在Base64编码最后进行补位。</p>
<p>关于Base64编码的细节，大家可以参考<a href="http://www.ruanyifeng.com/blog/2008/06/base64.html">《Base64笔记》</a>一文，Python标准库中的<code>base64</code>模块提供了<code>b64encode</code>和<code>b64decode</code>两个函数，专门用于实现Base64的编码和解码，下面演示了在<strong>Python的交互式环境</strong>中执行这两个函数的效果。</p>
<pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> base64
<span class="hljs-meta">&gt;&gt;&gt; </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>content = <span class="hljs-string">&#x27;Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base64.b64encode(content.encode())
<span class="hljs-string">b&#x27;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>content = <span class="hljs-string">b&#x27;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base64.b64decode(content).decode()
<span class="hljs-string">&#x27;Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.&#x27;</span></code></pre>

<h3 id="collections-容器数据类型模块"><a href="#collections-容器数据类型模块" class="headerlink" title="collections - 容器数据类型模块"></a>collections - 容器数据类型模块</h3><p><code>collections</code>模块提供了诸多非常好用的数据结构，主要包括：</p>
<ul>
<li><code>namedtuple</code>：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li>
<li><code>deque</code>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而<code>deque</code>底层是双向链表，因此当你需要在头尾添加和删除元素是，<code>deque</code>会表现出更好的性能，渐近时间复杂度为$O(1)$。</li>
<li><code>Counter</code>：<code>dict</code>的子类，键是元素，值是元素的计数，它的<code>most_common()</code>方法可以帮助我们获取出现频率最高的元素。<code>Counter</code>和<code>dict</code>的继承关系我认为是值得商榷的，按照CARP原则，<code>Counter</code>跟<code>dict</code>的关系应该设计为关联关系更为合理。</li>
<li><code>OrderedDict</code>：<code>dict</code>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li>
<li><code>defaultdict</code>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的<code>setdefault()</code>方法，这种做法更加高效。</li>
</ul>
<p>下面是在<strong>Python交互式环境中</strong>使用<code>namedtuple</code>创建扑克牌类的例子。</p>
<pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>Card = namedtuple(<span class="hljs-string">&#x27;Card&#x27;</span>, (<span class="hljs-string">&#x27;suite&#x27;</span>, <span class="hljs-string">&#x27;face&#x27;</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>card1 = Card(<span class="hljs-string">&#x27;红桃&#x27;</span>, <span class="hljs-number">5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>card2 = Card(<span class="hljs-string">&#x27;草花&#x27;</span>, <span class="hljs-number">9</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>card1
Card(suite=<span class="hljs-string">&#x27;红桃&#x27;</span>, face=<span class="hljs-number">5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>card2
Card(suite=<span class="hljs-string">&#x27;草花&#x27;</span>, face=<span class="hljs-number">9</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;card1.suite&#125;</span><span class="hljs-subst">&#123;card1.face&#125;</span>&#x27;</span>)
红桃<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;card2.suite&#125;</span><span class="hljs-subst">&#123;card2.face&#125;</span>&#x27;</span>)
草花<span class="hljs-number">9</span></code></pre>

<p>下面是使用<code>Counter</code>类统计列表中出现次数最多的三个元素的例子。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

words = [
    <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;into&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;into&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>,
    <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&#x27;not&#x27;</span>, <span class="hljs-string">&#x27;around&#x27;</span>,
    <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&quot;don&#x27;t&quot;</span>, <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;around&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>,
    <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-string">&#x27;into&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;eyes&#x27;</span>, <span class="hljs-string">&quot;you&#x27;re&quot;</span>, <span class="hljs-string">&#x27;under&#x27;</span>
]
counter = Counter(words)
<span class="hljs-comment"># 打印words列表中出现频率最高的3个元素及其出现次数</span>
<span class="hljs-keyword">for</span> elem, count <span class="hljs-keyword">in</span> counter.most_common(<span class="hljs-number">3</span>):
    <span class="hljs-built_in">print</span>(elem, count)</code></pre>

<h3 id="hashlib-哈希函数模块"><a href="#hashlib-哈希函数模块" class="headerlink" title="hashlib - 哈希函数模块"></a>hashlib - 哈希函数模块</h3><p>哈希函数又称哈希算法或散列函数，是一种为已有的数据创建“数字指纹”（哈希摘要）的方法。哈希函数把数据压缩成摘要，对于相同的输入，哈希函数可以生成相同的摘要（数字指纹），需要注意的是这个过程并不可逆（不能通过摘要计算出输入的内容）。一个优质的哈希函数能够为不同的输入生成不同的摘要，出现哈希冲突（不同的输入产生相同的摘要）的概率极低，<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>、<a href="%5Bhttps://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F%5D(https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)">SHA家族</a>就是这类好的哈希函数。</p>
<blockquote>
<p><strong>说明</strong>：在2011年的时候，RFC 6151中已经禁止将MD5用作密钥散列消息认证码，这个问题不在我们讨论的范围内。</p>
</blockquote>
<p>Python标准库的<code>hashlib</code>模块提供了对哈希函数的封装，通过使用<code>md5</code>、<code>sha1</code>、<code>sha256</code>等类，我们可以轻松的生成“数字指纹”。举一个简单的例子，用户注册时我们希望在数据库中保存用户的密码，很显然我们不能将用户密码直接保存在数据库中，这样可能会导致用户隐私的泄露，所以在数据库中保存用户密码时，通常都会将密码的“指纹”保存起来，用户登录时通过哈希函数计算密码的“指纹”再进行匹配来判断用户登录是否成功。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> hashlib

<span class="hljs-comment"># 计算字符串&quot;123456&quot;的MD5摘要</span>
<span class="hljs-built_in">print</span>(hashlib.md5(<span class="hljs-string">&#x27;123456&#x27;</span>.encode()).hexdigest())

<span class="hljs-comment"># 计算文件&quot;Python-3.7.1.tar.xz&quot;的MD5摘要</span>
hasher = hashlib.md5()
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Python-3.7.1.tar.xz&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:
    data = file.read(<span class="hljs-number">512</span>)
    <span class="hljs-keyword">while</span> data:
        hasher.update(data)
        data = file.read(<span class="hljs-number">512</span>)
<span class="hljs-built_in">print</span>(hasher.hexdigest())</code></pre>

<blockquote>
<p><strong>说明</strong>：很多网站在下载链接的旁边都提供了哈希摘要，完成文件下载后，我们可以计算该文件的哈希摘要并检查它与网站上提供的哈希摘要是否一致（指纹比对）。如果计算出的哈希摘要与网站提供的并不一致，很有可能是下载出错或该文件在传输过程中已经被篡改，这时候就不应该直接使用这个文件。</p>
</blockquote>
<h3 id="heapq-堆排序模块"><a href="#heapq-堆排序模块" class="headerlink" title="heapq - 堆排序模块"></a>heapq - 堆排序模块</h3><p><code>heapq</code>模块实现了堆排序算法，如果希望使用堆排序，尤其是要解决**<code>TopK</code>问题**（从序列中找到K个最大或最小元素），直接使用该模块即可，代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> heapq

list1 = [<span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">99</span>, <span class="hljs-number">87</span>, <span class="hljs-number">63</span>, <span class="hljs-number">58</span>, <span class="hljs-number">78</span>, <span class="hljs-number">88</span>, <span class="hljs-number">92</span>]
<span class="hljs-comment"># 找出列表中最大的三个元素</span>
<span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, list1))
<span class="hljs-comment"># 找出列表中最小的三个元素</span>
<span class="hljs-built_in">print</span>(heapq.nsmallest(<span class="hljs-number">3</span>, list1))

list2 = [
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;IBM&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">91.1</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;AAPL&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">543.22</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;FB&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">21.09</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;HPQ&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">31.75</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;YHOO&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">16.35</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ACME&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">115.65</span>&#125;
]
<span class="hljs-comment"># 找出价格最高的三只股票</span>
<span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, list2, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;price&#x27;</span>]))
<span class="hljs-comment"># 找出持有数量最高的三只股票</span>
<span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, list2, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;shares&#x27;</span>]))</code></pre>

<h3 id="itertools-迭代工具模块"><a href="#itertools-迭代工具模块" class="headerlink" title="itertools - 迭代工具模块"></a>itertools - 迭代工具模块</h3><p><code>itertools</code>可以帮助我们生成各种各样的迭代器，大家可以看看下面的例子。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> itertools

<span class="hljs-comment"># 产生ABCD的全排列</span>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> itertools.permutations(<span class="hljs-string">&#x27;ABCD&#x27;</span>):	
    <span class="hljs-built_in">print</span>(value)

<span class="hljs-comment"># 产生ABCDE的五选三组合</span>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> itertools.combinations(<span class="hljs-string">&#x27;ABCDE&#x27;</span>, <span class="hljs-number">3</span>):	<span class="hljs-comment">#返回 `iterable` 中元素的所有可能排列，长度为 `r`，为3。</span>
    <span class="hljs-built_in">print</span>(value)

<span class="hljs-comment"># 产生ABCD和123的笛卡尔积</span>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>):
    <span class="hljs-built_in">print</span>(value)

<span class="hljs-comment"># 产生ABC的无限循环序列</span>
it = itertools.cycle((<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))</code></pre>

<h3 id="random-随机数和随机抽样模块"><a href="#random-随机数和随机抽样模块" class="headerlink" title="random - 随机数和随机抽样模块"></a>random - 随机数和随机抽样模块</h3><p>这个模块我们之前已经用过很多次了，生成随机数、实现随机乱序和随机抽样，下面是常用函数的列表。</p>
<ul>
<li><code>getrandbits(k)</code>：返回具有<code>k</code>个随机比特位的整数。</li>
<li><code>randrange(start, stop[, step])</code>：从<code>range(start, stop, step)</code> 返回一个随机选择的元素，但实际上并没有构建一个<code>range</code>对象。</li>
<li><code>randint(a, b)</code>：返回随机整数<code>N</code>满足<code>a &lt;= N &lt;= b</code>，相当于<code>randrange(a, b+1)</code>。</li>
<li><code>choice(seq)</code>：从非空序列<code>seq</code>返回一个随机元素。 如果<code>seq</code>为空，则引发<code>IndexError</code>。</li>
<li><code>choices(population, weight=None, *, cum_weights=None, k=1)</code>：从<code>population</code>中选择替换，返回大小为<code>k</code>的元素列表。 如果<code>population</code>为空，则引发<code>IndexError</code>。</li>
<li><code>shuffle(x[, random])</code>：将序列<code>x</code>随机打乱位置。</li>
<li><code>sample(population, k)</code>：返回从总体序列或集合中选择<code>k</code>个不重复元素构造的列表，用于无重复的随机抽样。</li>
<li><code>random()</code>：返回<code>[0.0, 1.0)</code>范围内的下一个随机浮点数。</li>
<li><code>expovariate(lambd)</code>：指数分布。</li>
<li><code>gammavariate(alpha, beta)</code>：伽玛分布。</li>
<li><code>gauss(mu, sigma)</code> &#x2F; <code>normalvariate(mu, sigma)</code>：正态分布。</li>
<li><code>paretovariate(alpha)</code>：帕累托分布。 </li>
<li><code>weibullvariate(alpha, beta)</code>：威布尔分布。</li>
</ul>
<h3 id="os-path-路径操作相关模块"><a href="#os-path-路径操作相关模块" class="headerlink" title="os.path - 路径操作相关模块"></a>os.path - 路径操作相关模块</h3><p><code>os.path</code>模块封装了操作路径的工具函数，如果程序中需要对文件路径做拼接、拆分、获取以及获取文件的存在性和其他属性，这个模块将会非常有帮助，下面为大家罗列一些常用的函数。</p>
<ul>
<li><code>dirname(path)</code>：返回路径<code>path</code>的目录名称。</li>
<li><code>exists(path)</code>：如果<code>path</code>指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。</li>
<li><code>getatime(path)</code> &#x2F; <code>getmtime(path)</code> &#x2F; <code>getctime(path)</code>：返回<code>path</code>的最后访问时间&#x2F;最后修改时间&#x2F;创建时间。</li>
<li><code>getsize(path)</code>：返回<code>path</code>的大小，以字节为单位。如果该文件不存在或不可访问，则抛出<code>OSError</code>异常。</li>
<li><code>isfile(path)</code>：如果<code>path</code>是普通文件，则返回 <code>True</code>。</li>
<li><code>isdir(path)</code>：如果<code>path</code>是目录（文件夹），则返回<code>True</code>。</li>
<li><code>join(path, *paths)</code>：合理地拼接一个或多个路径部分。返回值是<code>path</code>和<code>paths</code>所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。</li>
<li><code>splitext(path)</code>：将路径<code>path</code>拆分为一对，即<code>(root, ext)</code>，使得<code>root + ext == path</code>，其中<code>ext</code>为空或以英文句点开头，且最多包含一个句点。</li>
</ul>
<h3 id="uuid-UUID生成模块"><a href="#uuid-UUID生成模块" class="headerlink" title="uuid - UUID生成模块"></a>uuid - UUID生成模块</h3><p><code>uuid</code>模块可以帮助我们生成全局唯一标识符（Universal Unique IDentity）。该模块提供了四个用于生成UUID的函数，分别是：</p>
<ul>
<li><code>uuid1()</code>：由MAC地址、当前时间戳、随机数生成，可以保证全球范围内的唯一性。</li>
<li><code>uuid3(namespace, name)</code>：通过计算命名空间和名字的MD5哈希摘要（“指纹”）值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字会生成相同的UUID。</li>
<li><code>uuid4()</code>：由伪随机数生成UUID，有一定的重复概率，该概率可以计算出来。</li>
<li><code>uuid5()</code>：算法与<code>uuid3</code>相同，只不过哈希函数用SHA-1取代了MD5。</li>
</ul>
<p>由于<code>uuid4</code>存在概率型重复，那么在真正需要全局唯一标识符的地方最好不用使用它。在分布式环境下，<code>uuid1</code>是很好的选择，因为它能够保证生成ID的全局唯一性。下面是在<strong>Python交互式环境中</strong>使用<code>uuid1</code>函数生成全局唯一标识符的例子。</p>
<pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> uuid
<span class="hljs-meta">&gt;&gt;&gt; </span>uuid.uuid1().<span class="hljs-built_in">hex</span>
<span class="hljs-string">&#x27;622a8334baab11eaaa9c60f81da8d840&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>uuid.uuid1().<span class="hljs-built_in">hex</span>
<span class="hljs-string">&#x27;62b066debaab11eaaa9c60f81da8d840&#x27;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>uuid.uuid1().<span class="hljs-built_in">hex</span>
<span class="hljs-string">&#x27;642c0db0baab11eaaa9c60f81da8d840&#x27;</span></code></pre>

<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>Python标准库中有大量的模块，日常开发中有很多常见的任务在Python标准库中都有封装好的函数或类可供使用，这也是Python这门语言最可爱的地方。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/分支和循环案例/" title="分支和循环案例">
                    分支和循环案例
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="分支结构和循环结构的应用"><a href="#分支结构和循环结构的应用" class="headerlink" title="分支结构和循环结构的应用"></a>分支结构和循环结构的应用</h2><p><strong>分支结构和循环结构是构造程序逻辑的基础</strong>，它们的重要性不言而喻，但是对于初学者来说这也是比较困难的部分。很多人对分支结构和循环结构的语法是能够理解的，但是遇到实际问题的时候又无法下手；<strong>看懂别人的代码很容易，但是要自己写出类似的代码却又很难</strong>。如果你也有同样的问题和困惑，千万不要沮丧，这只是因为你的编程之旅才刚刚开始，<strong>你的练习量还没有达到让你可以随心所欲的写出代码的程度</strong>，只要加强编程练习，通过量的积累来产生质的变化，这个问题迟早都会解决的。</p>
<h3 id="经典小案例"><a href="#经典小案例" class="headerlink" title="经典小案例"></a>经典小案例</h3><h4 id="例子1：100以内的素数"><a href="#例子1：100以内的素数" class="headerlink" title="例子1：100以内的素数"></a>例子1：100以内的素数</h4><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">输出100以内的素数</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>):
    is_prime = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(num ** <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:
            is_prime = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">if</span> is_prime:
        <span class="hljs-built_in">print</span>(num)</code></pre>

<h4 id="例子2：斐波那契数列"><a href="#例子2：斐波那契数列" class="headerlink" title="例子2：斐波那契数列"></a>例子2：斐波那契数列</h4><p>要求：输出斐波那契数列中的前20个数。</p>
<blockquote>
<p><strong>说明</strong>：斐波那契数列（Fibonacci sequence），通常也被称作黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中研究理想假设条件下兔子成长率问题而引入的数列，因此这个数列也常被戏称为“兔子数列”。斐波那契数列的特点是<strong>数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和。</strong>按照这个规律，斐波那契数列的前10个数是：<code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55</code>。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。</p>
</blockquote>
<pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">输出斐波那契数列中的前20个数</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):
    a, b = b, a + b
    <span class="hljs-built_in">print</span>(a)</code></pre>

<blockquote>
<p><strong>说明</strong>：上面循环中的<code>a, b = b, a + b</code>表示将变量<code>b</code>的值赋给<code>a</code>，把<code>a + b</code>的值赋给<code>b</code>。通过这个递推公式，我们可以依次获得斐波那契数列中的数。</p>
</blockquote>
<h4 id="例子3：寻找水仙花数"><a href="#例子3：寻找水仙花数" class="headerlink" title="例子3：寻找水仙花数"></a>例子3：寻找水仙花数</h4><p>要求：找出<code>100</code>到<code>999</code>范围内的所有水仙花数。</p>
<blockquote>
<p><strong>提示</strong>：在数论中，水仙花数（narcissistic number）也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个$\small{N}$位非负整数，其各位数字的$\small{N}$次方和刚好等于该数本身，例如：$\small{153&#x3D;1^3+5^3+3^3}$，所以<code>153</code> 是一个水仙花数；$\small{1634&#x3D;1^4+6^4+3^4+4^4}$，所以<code>1634</code>也是一个水仙花数。对于三位数，解题的关键是将它拆分为个位、十位、百位，再判断是否满足水仙花数的要求，这一点利用Python中的<code>//</code>和<code>%</code>运算符其实很容易做到。</p>
</blockquote>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">找出100到999范围内的水仙花数</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>):
    low = num % <span class="hljs-number">10</span>
    mid = num // <span class="hljs-number">10</span> % <span class="hljs-number">10</span>
    high = num // <span class="hljs-number">100</span>
    <span class="hljs-keyword">if</span> num == low ** <span class="hljs-number">3</span> + mid ** <span class="hljs-number">3</span> + high ** <span class="hljs-number">3</span>:
        <span class="hljs-built_in">print</span>(num)</code></pre>

<p>上面利用<code>//</code>和<code>%</code>拆分一个数的小技巧在写代码的时候还是很常用的。我们要<strong>将一个不知道有多少位的正整数进行反转</strong>，例如将<code>12389</code>变成<code>98321</code>，也可以利用这两个运算来实现，代码如下所示。</p>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">正整数的反转</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;num = &#x27;</span>))
reversed_num = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:	<span class="hljs-comment">#每次对10取余，到最后一位后取余会变为0</span>
    reversed_num = reversed_num * <span class="hljs-number">10</span> + num % <span class="hljs-number">10</span>
    num //= <span class="hljs-number">10</span>
<span class="hljs-built_in">print</span>(reversed_num)</code></pre>

<h4 id="例子4：百钱百鸡问题"><a href="#例子4：百钱百鸡问题" class="headerlink" title="例子4：百钱百鸡问题"></a>例子4：百钱百鸡问题</h4><blockquote>
<p><strong>说明</strong>：百钱百鸡是我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：<strong>公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</strong></p>
</blockquote>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">百钱百鸡问题</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">21</span>):
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">34</span>):
        <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>):
            <span class="hljs-keyword">if</span> x + y + z == <span class="hljs-number">100</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span> * y + z // <span class="hljs-number">3</span> == <span class="hljs-number">100</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;公鸡: <span class="hljs-subst">&#123;x&#125;</span>只, 母鸡: <span class="hljs-subst">&#123;y&#125;</span>只, 小鸡: <span class="hljs-subst">&#123;z&#125;</span>只&#x27;</span>)</code></pre>

<p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项，并检查每个候选项是否符合问题的描述，最终得到问题的解。上面的代码中，我们使用了嵌套的循环结构，假设公鸡有<code>x</code>只，显然<code>x</code>的取值范围是0到20，假设母鸡有<code>y</code>只，它的取值范围是<code>0</code>到<code>33</code>，假设小鸡有<code>z</code>只，它的取值范围是<code>0</code>到<code>99</code>且取值是<code>3</code> 的倍数。设置好<code>100</code>块钱的条件<code>5 * x + 3 * y + z // 3 == 100</code>，当条件同时满足时，就是问题的正确答案，我们用<code>print</code>函数输出它。</p>
<p>事实上，上面的代码还有更好的写法，既然我们已经假设公鸡有<code>x</code>只，母鸡有<code>y</code>只，那么小鸡的数量就应该是<code>100 - x - y</code>，这样减少一个条件，我们就可以把上面三层嵌套的<code>for-in</code>循环改写为两层嵌套的<code>for-in</code>循环。循环次数减少了，代码的执行效率就有了显著的提升，如下所示。</p>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">百钱百鸡问题</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">21</span>):
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">34</span>):
        z = <span class="hljs-number">100</span> - x - y
        <span class="hljs-keyword">if</span> z % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span> * y + z // <span class="hljs-number">3</span> == <span class="hljs-number">100</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;公鸡: <span class="hljs-subst">&#123;x&#125;</span>只, 母鸡: <span class="hljs-subst">&#123;y&#125;</span>只, 小鸡: <span class="hljs-subst">&#123;z&#125;</span>只&#x27;</span>)</code></pre>

<blockquote>
<p><strong>说明</strong>：上面代码中的<code>z % 3 == 0</code>是为了确保小鸡的数量是<code>3</code>的倍数。</p>
</blockquote>
<h4 id="例子5：CRAPS赌博游戏"><a href="#例子5：CRAPS赌博游戏" class="headerlink" title="例子5：CRAPS赌博游戏"></a>例子5：CRAPS赌博游戏</h4><blockquote>
<p><strong>说明</strong>：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简化后的规则是：玩家第一次摇骰子如果摇出了<code>7</code>点或<code>11</code>点，玩家胜；玩家第一次如果摇出<code>2</code>点、<code>3</code>点或<code>12</code>点，庄家胜；玩家如果摇出其他点数则游戏继续，玩家重新摇骰子，如果玩家摇出了<code>7</code>点，庄家胜；如果玩家摇出了<strong>第一次摇的点数</strong>，玩家胜；其他点数玩家继续摇骰子，直到分出胜负。为了增加代码的趣味性，我们设定游戏开始时玩家有<code>1000</code>元的赌注，每局游戏开始之前，玩家先下注，如果玩家获胜就可以获得对应下注金额的奖励，如果庄家获胜，玩家就会输掉自己下注的金额。游戏结束的条件是玩家破产（输光所有的赌注）。</p>
</blockquote>
<pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">Craps赌博游戏</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">import</span> random

money = <span class="hljs-number">1000</span>
<span class="hljs-keyword">while</span> money &gt; <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;你的总资产为: <span class="hljs-subst">&#123;money&#125;</span>元&#x27;</span>)
    <span class="hljs-comment"># 下注金额必须大于0且小于等于玩家的总资产</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        debt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请下注: &#x27;</span>))
        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; debt &lt;= money:
            <span class="hljs-keyword">break</span>
    <span class="hljs-comment"># 用两个1到6均匀分布的随机数相加模拟摇两颗色子得到的点数</span>
    first_point = random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>) + random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\n玩家摇出了<span class="hljs-subst">&#123;first_point&#125;</span>点&#x27;</span>)
    <span class="hljs-keyword">if</span> first_point == <span class="hljs-number">7</span> <span class="hljs-keyword">or</span> first_point == <span class="hljs-number">11</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;玩家胜!\n&#x27;</span>)
        money += debt
    <span class="hljs-keyword">elif</span> first_point == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> first_point == <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> first_point == <span class="hljs-number">12</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;庄家胜!\n&#x27;</span>)
        money -= debt
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># 如果第一次摇色子没有分出胜负，玩家需要重新摇色子</span>
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            current_point = random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>) + random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;玩家摇出了<span class="hljs-subst">&#123;current_point&#125;</span>点&#x27;</span>)
            <span class="hljs-keyword">if</span> current_point == <span class="hljs-number">7</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;庄家胜!\n&#x27;</span>)
                money -= debt
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">elif</span> current_point == first_point:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;玩家胜!\n&#x27;</span>)
                money += debt
                <span class="hljs-keyword">break</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你破产了, 游戏结束!&#x27;</span>)</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分支结构和循环结构都非常重要，是构造程序逻辑的基础，<strong>一定要通过大量的练习来达到融会贯通</strong>。我们可以用上面讲的花旗骰游戏作为一个标准，如果你能够很顺利的完成这段代码，那么分支结构和循环结构的知识你就已经很好的掌握了。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/函数的应用/" title="函数的应用">
                    函数的应用
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>设计一个生成随机验证码的函数，验证码由数字和英文大小写字母构成，长度可以通过参数设置。</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> string

ALL_CHARS = string.digits + string.ascii_letters


<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_code</span>(<span class="hljs-params">*, code_len=<span class="hljs-number">4</span></span>):	<span class="hljs-comment"># *后面的参数是命名关键字参数</span>
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    生成指定长度的验证码</span>
<span class="hljs-string">    :param code_len: 验证码的长度(默认4个字符)</span>
<span class="hljs-string">    :return: 由大小写英文字母和数字构成的随机验证码字符串</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(random.choices(ALL_CHARS, k=code_len))</code></pre>

<blockquote>
<p><strong>说明1</strong>：<code>string</code>模块的<code>digits</code>代表0到9的数字构成的字符串<code>&#39;0123456789&#39;</code>，<code>string</code>模块的<code>ascii_letters</code>代表大小写英文字母构成的字符串<code>&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code>。</p>
<p><strong>说明2</strong>：<code>random</code>模块的<code>sample</code>和<code>choices</code>函数都可以实现随机抽样，<code>sample</code>实现无放回抽样，这意味着抽样取出的元素是不重复的；<code>choices</code>实现有放回抽样，这意味着可能会重复选中某些元素。这两个函数的第一个参数代表抽样的总体，而参数<code>k</code>代表样本容量，需要说明的是<code>choices</code>函数的参数<code>k</code>是一个命名关键字参数，在传参时必须指定参数名。</p>
</blockquote>
<p>可以用下面的代码生成5组随机验证码来测试上面的函数。</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    <span class="hljs-built_in">print</span>(generate_code())</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">59tZ
QKU5
izq8
IBBb
jIfX</code></pre>



<p>或者</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    <span class="hljs-built_in">print</span>(generate_code(code_len=<span class="hljs-number">6</span>))</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">FxJucw
HS4H9G
0yyXfz
x7fohf
ReO22w</code></pre>

<blockquote>
<p><strong>说明</strong>：我们设计的<code>generate_code</code>函数的参数是命名关键字参数，由于它有默认值，可以不给它传值，使用默认值4。如果需要给函数传入参数，必须指定参数名<code>code_len</code>。</p>
</blockquote>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>设计一个判断给定的大于1的正整数是不是质数的函数。质数是只能被1和自身整除的正整数（大于1），如果一个大于1的正整数$N$是质数，那就意味着在2到$N-1$之间都没有它的因子。</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    判断一个正整数是不是质数</span>
<span class="hljs-string">    :param num: 大于1的正整数</span>
<span class="hljs-string">    :return: 如果num是质数返回True，否则返回False</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(num ** <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):		<span class="hljs-comment">#num ** 0.5为float格式，会报错，要改为int格式</span>
        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>

<blockquote>
<p><strong>说明1</strong>：上面<code>is_prime</code>函数的参数<code>num</code>后面的<code>: int</code>用来标注参数的类型，虽然<strong>它对代码的执行结果不产生任何影响</strong>，但是很好的增强了代码的可读性。同理，参数列表后面的<code>-&gt; bool</code>用来标注函数返回值的类型，它<strong>也不会对代码的执行结果产生影响</strong>，但是却让我们清楚的知道，调用函数会得到一个布尔值，要么是<code>True</code>，要么是<code>False</code>。</p>
<p><strong>说明2</strong>：上面的循环并不需要从2循环到$\small{N-1}$，因为如果循环进行到$\small{\sqrt{N}}$时，还没有找到$\small{N}$的因子，那么$\small{\sqrt{N}}$之后也不会出现$\small{N}$的因子，大家可以自己想一想这是为什么。</p>
</blockquote>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>设计计算两个正整数最大公约数和最小公倍数的函数。$x$和$y$的最大公约数是能够同时整除$x$和$y$的最大整数，如果$x$和$y$互质，那么它们的最大公约数为1；$x$和$y$的最小公倍数是能够同时被$x$和$y$整除的最小正整数，如果$x$和$y$互质，那么它们的最小公倍数为$x \times y$。需要提醒大家注意的是，计算最大公约数和最小公倍数是两个不同的功能，应该设计成两个函数，而不是把两个功能放到同一个函数中。</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot;求最小公倍数&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> x * y // gcd(x, y)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-string">&quot;&quot;&quot;求最大公约数&quot;&quot;&quot;</span>
    <span class="hljs-keyword">while</span> y % x != <span class="hljs-number">0</span>:
        x, y = y % x, x
    <span class="hljs-keyword">return</span> x</code></pre>

<blockquote>
<p><strong>说明1</strong>：函数之间可以相互调用，上面求最小公倍数的<code>lcm</code>函数就调用了求最大公约数的<code>gcd</code>函数，通过$\frac{x \times y}{ gcd(x, y)}$来计算最小公倍数。</p>
<p><strong>说明2</strong>：上面的<code>gcd</code>（自己定义的）函数使用了欧几里得算法计算最大公约数，欧几里得算法也称为辗转相除法，这个算法通常有更好的执行效率，不了解的小伙伴可以自行科普。</p>
</blockquote>
<h3 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h3><p>假设样本数据保存一个列表中，设计计算样本数据描述性统计信息的函数。描述性统计信息通常包括：算术平均值、中位数、极差（最大值和最小值的差）、方差、标准差、变异系数等，计算公式如下所示：</p>
<p>样本均值（sample mean）： $$ \bar{x} &#x3D; \frac{\sum_{i&#x3D;1}^{n}x_{i}}{n} &#x3D; \frac{x_{1}+x_{2}+\cdots +x_{n}}{n} $$ 样本方差（sample variance）： $$ s^2 &#x3D; \frac {\sum_{i&#x3D;1}^{n}(x_i - \bar{x})^2} {n-1} $$ 样本标准差（sample standard deviation）： $$ s &#x3D; \sqrt{\frac{\sum_{i&#x3D;1}^{n}(x_i - \bar{x})^2}{n-1}} $$ 变异系数（coefficient of sample variation）： $$ CV &#x3D; \frac{s}{\bar{x}} $$</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ptp</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;极差（全距）&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(data) - <span class="hljs-built_in">min</span>(data)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">mean</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;算术平均&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(data) / <span class="hljs-built_in">len</span>(data)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;中位数&quot;&quot;&quot;</span>
    temp, size = <span class="hljs-built_in">sorted</span>(data), <span class="hljs-built_in">len</span>(data)
    <span class="hljs-keyword">if</span> size % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> temp[size // <span class="hljs-number">2</span>]
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> mean(temp[size // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>:size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>])


<span class="hljs-keyword">def</span> <span class="hljs-title function_">var</span>(<span class="hljs-params">data, ddof=<span class="hljs-number">1</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;方差&quot;&quot;&quot;</span>
    x_bar = mean(data)
    temp = [(num - x_bar) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data]
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(temp) / (<span class="hljs-built_in">len</span>(temp) - ddof)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">std</span>(<span class="hljs-params">data, ddof=<span class="hljs-number">1</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;标准差&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> var(data, ddof) ** <span class="hljs-number">0.5</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">cv</span>(<span class="hljs-params">data, ddof=<span class="hljs-number">1</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;变异系数&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> std(data, ddof) / mean(data)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">describe</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">&quot;&quot;&quot;输出描述性统计信息&quot;&quot;&quot;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;均值: <span class="hljs-subst">&#123;mean(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中位数: <span class="hljs-subst">&#123;median(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;极差: <span class="hljs-subst">&#123;ptp(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差: <span class="hljs-subst">&#123;var(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差: <span class="hljs-subst">&#123;std(data)&#125;</span>&#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;变异系数: <span class="hljs-subst">&#123;cv(data)&#125;</span>&#x27;</span>)</code></pre>

<blockquote>
<p><strong>说明1</strong>：中位数是将数据按照升序或降序排列后位于中间的数，它描述了数据的中等水平。中位数的计算分两种情况：当数据体量$n$为奇数时，中位数是位于$\frac{n + 1}{2}$位置的元素；当数据体量$n$为偶数时，中位数是位于$\frac{n}{2}$和$\frac{n}{2} + 1$两个位置元素的均值。</p>
<p><strong>说明2</strong>：计算方差和标准差的函数中有一个名为<code>ddof</code>的参数，它代表了可以调整的自由度，默认值为1。在计算样本方差和样本标准差时，需要进行自由度校正；如果要计算总体方差和总体标准差，可以将<code>ddof</code>参数赋值为0，即不需要进行自由度校正。</p>
<p><strong>说明3</strong>：<code>describe</code>函数将上面封装好的统计函数组装到一起，用于输出数据的描述性统计信息。事实上，Python 标准库中有一个名为<code>statistics</code>的模块，它已经把获取描述性统计信息的函数封装好了，有兴趣的读者可以自行了解。</p>
</blockquote>
<h3 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h3><p>我们用函数重构之前讲过的双色球随机选号的例子，将生成随机号码和输出一组号码的功能分别封装到两个函数中，然后通过调用函数实现机选<code>N</code>注号码的功能。</p>
<pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">双色球随机选号程序</span>
<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-keyword">import</span> random

RED_BALLS = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">34</span>)]
BLUE_BALLS = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">17</span>)]


<span class="hljs-keyword">def</span> <span class="hljs-title function_">choose</span>():
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    生成一组随机号码</span>
<span class="hljs-string">    :return: 保存随机号码的列表</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    selected_balls = random.sample(RED_BALLS, <span class="hljs-number">6</span>)
    selected_balls.sort()
    selected_balls.append(random.choice(BLUE_BALLS))	<span class="hljs-comment">#从蓝色球列表中随机抽出1个蓝色球</span>
    <span class="hljs-keyword">return</span> selected_balls


<span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">balls</span>):
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    格式输出一组号码</span>
<span class="hljs-string">    :param balls: 保存随机号码的列表</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">for</span> ball <span class="hljs-keyword">in</span> balls[:-<span class="hljs-number">1</span>]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[031m<span class="hljs-subst">&#123;ball:<span class="hljs-number">0</span>&gt;2d&#125;</span>\033[0m&#x27;</span>, end=<span class="hljs-string">&#x27; &#x27;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[034m<span class="hljs-subst">&#123;balls[-<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>&gt;2d&#125;</span>\033[0m&#x27;</span>)


n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;生成几注号码: &#x27;</span>))
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
    display(choose())</code></pre>



<blockquote>
<p><strong>说明</strong>：大家看看<code>display(choose())</code>这行代码，这里我们先通过<code>choose</code>函数获得一组随机号码，然后把<code>choose</code>函数的返回值作为<code>display</code>函数的参数，通过<code>display</code>函数将选中的随机号码显示出来。重构之后的代码逻辑非常清晰，代码的可读性更强了。如果有人为你封装了这两个函数，你仅仅是函数的调用者，其实你根本不用关心<code>choose</code>函数和<code>display</code>函数的内部实现，你只需要知道调用<code>choose</code>函数可以生成一组随机号码，而调用<code>display</code>函数传入一个列表，就可以输出这组号码。将来我们使用各种各样的 Python 三方库时，我们也根本不关注它们的底层实现，我们需要知道的仅仅是调用哪个函数可以解决问题。</p>
</blockquote>

        </div>
        
            
        
        
    </div>
</article>

        
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/使用Python操作各类文件/" title="使用Python操作各类文件">
                    使用Python操作各类文件
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="用Python读写CSV文件"><a href="#用Python读写CSV文件" class="headerlink" title="用Python读写CSV文件"></a>用Python读写CSV文件</h2><h3 id="CSV文件介绍"><a href="#CSV文件介绍" class="headerlink" title="CSV文件介绍"></a>CSV文件介绍</h3><p>CSV（Comma Separated Values）全称<strong>逗号分隔值文件</strong>是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，而且很多编程语言中都提供了对读写CSV文件的支持，因此CSV格式在数据处理和数据科学中被广泛应用。</p>
<p>CSV文件有以下特点：</p>
<ol>
<li>纯文本，使用某种字符集（如<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>、<a href="https://zh.wikipedia.org/wiki/GB2312">GB2312</a>）等）；</li>
<li>由一条条的记录组成（典型的是每行一条记录）；</li>
<li>每条记录被分隔符（如逗号、分号、制表符等）分隔为字段（列）；</li>
<li>每条记录都有同样的字段序列。</li>
</ol>
<p>CSV文件可以使用文本编辑器或类似于Excel电子表格这类工具打开和编辑，当使用Excel这类电子表格打开CSV文件时，你甚至感觉不到CSV和Excel文件的区别。很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，这些内容并不是现在要讨论的重点。</p>
<h3 id="将数据写入CSV文件"><a href="#将数据写入CSV文件" class="headerlink" title="将数据写入CSV文件"></a>将数据写入CSV文件</h3><p>现有五个学生三门课程的考试成绩需要保存到一个CSV文件中，要达成这个目标，可以使用Python标准库中的<code>csv</code>模块，该模块的<code>writer</code>函数会返回一个<code>csvwriter</code>对象，通过该对象的<code>writerow</code>或<code>writerows</code>方法就可以将数据写入到CSV文件中，具体的代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">import</span> random

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;scores.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:
    writer = csv.writer(file)
    writer.writerow([<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>])
    names = [<span class="hljs-string">&#x27;关羽&#x27;</span>, <span class="hljs-string">&#x27;张飞&#x27;</span>, <span class="hljs-string">&#x27;赵云&#x27;</span>, <span class="hljs-string">&#x27;马超&#x27;</span>, <span class="hljs-string">&#x27;黄忠&#x27;</span>]
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:
        scores = [random.randrange(<span class="hljs-number">50</span>, <span class="hljs-number">101</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]
        scores.insert(<span class="hljs-number">0</span>, name)
        writer.writerow(scores)</code></pre>

<p>生成的CSV文件的内容。</p>
<pre><code class="hljs plaintext">姓名,语文,数学,英语
关羽,98,86,61
张飞,86,58,80
赵云,95,73,70
马超,83,97,55
黄忠,61,54,87</code></pre>

<p>需要说明的是上面的<code>writer</code>函数，除了传入要写入数据的文件对象外，还可以<code>dialect</code>参数，它表示CSV文件的方言，默认值是<code>excel</code>。除此之外，还可以通过<code>delimiter</code>、<code>quotechar</code>、<code>quoting</code>参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。大家可以尝试将上面第5行代码修改为下面的代码，然后查看生成的CSV文件。</p>
<pre><code class="hljs Python">writer = csv.writer(file, delimiter=<span class="hljs-string">&#x27;|&#x27;</span>, quoting=csv.QUOTE_ALL)</code></pre>

<p>生成的CSV文件的内容。</p>
<pre><code class="hljs plaintext">&quot;姓名&quot;|&quot;语文&quot;|&quot;数学&quot;|&quot;英语&quot;
&quot;关羽&quot;|&quot;88&quot;|&quot;64&quot;|&quot;65&quot;
&quot;张飞&quot;|&quot;76&quot;|&quot;93&quot;|&quot;79&quot;
&quot;赵云&quot;|&quot;78&quot;|&quot;55&quot;|&quot;76&quot;
&quot;马超&quot;|&quot;72&quot;|&quot;77&quot;|&quot;68&quot;
&quot;黄忠&quot;|&quot;70&quot;|&quot;72&quot;|&quot;51&quot;</code></pre>

<h3 id="从CSV文件读取数据"><a href="#从CSV文件读取数据" class="headerlink" title="从CSV文件读取数据"></a>从CSV文件读取数据</h3><p>如果要读取刚才创建的CSV文件，可以使用下面的代码，通过<code>csv</code>模块的<code>reader</code>函数可以创建出<code>csvreader</code>对象，该对象是一个迭代器，可以通过<code>next</code>函数或<code>for-in</code>循环读取到文件中的数据。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> csv

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;scores.csv&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:
    reader = csv.reader(file, delimiter=<span class="hljs-string">&#x27;|&#x27;</span>)
    <span class="hljs-keyword">for</span> data_list <span class="hljs-keyword">in</span> reader:
        <span class="hljs-built_in">print</span>(reader.line_num, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> data_list:
            <span class="hljs-built_in">print</span>(elem, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-built_in">print</span>()</code></pre>

<blockquote>
<p><strong>注意</strong>：上面的代码对<code>csvreader</code>对象做<code>for</code>循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。</p>
</blockquote>
<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>将来如果大家使用Python做数据分析，很有可能会用到名为<code>pandas</code>的三方库，它是Python数据分析的神器之一。<code>pandas</code>中封装了名为<code>read_csv</code>和<code>to_csv</code>的函数用来读写CSV文件，其中<code>read_CSV</code>会将读取到的数据变成一个<code>DataFrame</code>对象，而<code>DataFrame</code>就是<code>pandas</code>库中最重要的类型，它封装了一系列用于数据处理的方法（清洗、转换、聚合等）；而<code>to_csv</code>会将<code>DataFrame</code>对象中的数据写入CSV文件，完成数据的持久化。<code>read_csv</code>函数和<code>to_csv</code>函数远远比原生的<code>csvreader</code>和<code>csvwriter</code>强大。</p>
<h2 id="用Python读写Excel文件"><a href="#用Python读写Excel文件" class="headerlink" title="用Python读写Excel文件"></a>用Python读写Excel文件</h2><h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p>
<p>本章我们继续讲解基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p>
<pre><code class="hljs Bash">pip install openpyxl</code></pre>

<p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code><strong>并不支持操作Office 2007以前版本的</strong>Excel文件。</p>
<h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> datetime

<span class="hljs-keyword">import</span> openpyxl

<span class="hljs-comment"># 加载一个工作簿 ---&gt; Workbook</span>
wb = openpyxl.load_workbook(<span class="hljs-string">&#x27;阿里巴巴2020年股票数据.xlsx&#x27;</span>)
<span class="hljs-comment"># 获取工作表的名字</span>
<span class="hljs-built_in">print</span>(wb.sheetnames)
<span class="hljs-comment"># 获取工作表 ---&gt; Worksheet</span>
sheet = wb.worksheets[<span class="hljs-number">0</span>]
<span class="hljs-comment"># 获得单元格的范围</span>
<span class="hljs-built_in">print</span>(sheet.dimensions)
<span class="hljs-comment"># 获得行数和列数</span>
<span class="hljs-built_in">print</span>(sheet.max_row, sheet.max_column)

<span class="hljs-comment"># 获取指定单元格的值</span>
<span class="hljs-built_in">print</span>(sheet.cell(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>).value)
<span class="hljs-built_in">print</span>(sheet[<span class="hljs-string">&#x27;C3&#x27;</span>].value)
<span class="hljs-built_in">print</span>(sheet[<span class="hljs-string">&#x27;G255&#x27;</span>].value)

<span class="hljs-comment"># 获取多个单元格（嵌套元组）</span>
<span class="hljs-built_in">print</span>(sheet[<span class="hljs-string">&#x27;A2:C5&#x27;</span>])

<span class="hljs-comment"># 读取所有单元格的数据</span>
<span class="hljs-keyword">for</span> row_ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, sheet.max_row + <span class="hljs-number">1</span>):
    <span class="hljs-keyword">for</span> col_ch <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABCDEFG&#x27;</span>:
        value = sheet[<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col_ch&#125;</span><span class="hljs-subst">&#123;row_ch&#125;</span>&#x27;</span>].value
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) == datetime.datetime:
            <span class="hljs-built_in">print</span>(value.strftime(<span class="hljs-string">&#x27;%Y年%m月%d日&#x27;</span>), end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-built_in">int</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;value:&lt;10d&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-built_in">float</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;value:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(value, end=<span class="hljs-string">&#x27;\t&#x27;</span>)
    <span class="hljs-built_in">print</span>()</code></pre>

<blockquote>
<p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xlsx”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p>
</blockquote>
<p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet[&#39;A2:C5&#39;]</code>或<code>sheet[&#39;A2&#39;:&#39;C5&#39;]</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p>
<h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> random

<span class="hljs-keyword">import</span> openpyxl

<span class="hljs-comment"># 第一步：创建工作簿（Workbook）</span>
wb = openpyxl.Workbook()

<span class="hljs-comment"># 第二步：添加工作表（Worksheet）</span>
sheet = wb.active
sheet.title = <span class="hljs-string">&#x27;期末成绩&#x27;</span>

titles = (<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>)
<span class="hljs-keyword">for</span> col_index, title <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(titles):
    sheet.cell(<span class="hljs-number">1</span>, col_index + <span class="hljs-number">1</span>, title)

names = (<span class="hljs-string">&#x27;关羽&#x27;</span>, <span class="hljs-string">&#x27;张飞&#x27;</span>, <span class="hljs-string">&#x27;赵云&#x27;</span>, <span class="hljs-string">&#x27;马超&#x27;</span>, <span class="hljs-string">&#x27;黄忠&#x27;</span>)
<span class="hljs-keyword">for</span> row_index, name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(names):
    sheet.cell(row_index + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, name)
    <span class="hljs-keyword">for</span> col_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>):
        sheet.cell(row_index + <span class="hljs-number">2</span>, col_index, random.randrange(<span class="hljs-number">50</span>, <span class="hljs-number">101</span>))

<span class="hljs-comment"># 第四步：保存工作簿</span>
wb.save(<span class="hljs-string">&#x27;考试成绩表.xlsx&#x27;</span>)</code></pre>

<h4 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h4><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> openpyxl
<span class="hljs-keyword">from</span> openpyxl.styles <span class="hljs-keyword">import</span> Font, Alignment, Border, Side

<span class="hljs-comment"># 对齐方式</span>
alignment = Alignment(horizontal=<span class="hljs-string">&#x27;center&#x27;</span>, vertical=<span class="hljs-string">&#x27;center&#x27;</span>)
<span class="hljs-comment"># 边框线条</span>
side = Side(color=<span class="hljs-string">&#x27;ff7f50&#x27;</span>, style=<span class="hljs-string">&#x27;mediumDashed&#x27;</span>)

wb = openpyxl.load_workbook(<span class="hljs-string">&#x27;考试成绩表.xlsx&#x27;</span>)
sheet = wb.worksheets[<span class="hljs-number">0</span>]

<span class="hljs-comment"># 调整行高和列宽</span>
sheet.row_dimensions[<span class="hljs-number">1</span>].height = <span class="hljs-number">30</span>
sheet.column_dimensions[<span class="hljs-string">&#x27;E&#x27;</span>].width = <span class="hljs-number">120</span>

sheet[<span class="hljs-string">&#x27;E1&#x27;</span>] = <span class="hljs-string">&#x27;平均分&#x27;</span>
<span class="hljs-comment"># 设置字体</span>
sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).font = Font(size=<span class="hljs-number">18</span>, bold=<span class="hljs-literal">True</span>, color=<span class="hljs-string">&#x27;ff1493&#x27;</span>, name=<span class="hljs-string">&#x27;华文楷体&#x27;</span>)
<span class="hljs-comment"># 设置对齐方式</span>
sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).alignment = alignment
<span class="hljs-comment"># 设置单元格边框</span>
sheet.cell(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).border = Border(left=side, top=side, right=side, bottom=side)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">7</span>):
    <span class="hljs-comment"># 公式计算每个学生的平均分</span>
    sheet[<span class="hljs-string">f&#x27;E<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>] = <span class="hljs-string">f&#x27;=average(B<span class="hljs-subst">&#123;i&#125;</span>:D<span class="hljs-subst">&#123;i&#125;</span>)&#x27;</span>
    sheet.cell(i, <span class="hljs-number">5</span>).font = Font(size=<span class="hljs-number">12</span>, color=<span class="hljs-string">&#x27;4169e1&#x27;</span>, italic=<span class="hljs-literal">True</span>)
    sheet.cell(i, <span class="hljs-number">5</span>).alignment = alignment

wb.save(<span class="hljs-string">&#x27;考试成绩表.xlsx&#x27;</span>)</code></pre>

<h3 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h3><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook
<span class="hljs-keyword">from</span> openpyxl.chart <span class="hljs-keyword">import</span> BarChart, Reference

wb = Workbook(write_only=<span class="hljs-literal">True</span>)
sheet = wb.create_sheet()

rows = [
    (<span class="hljs-string">&#x27;类别&#x27;</span>, <span class="hljs-string">&#x27;销售A组&#x27;</span>, <span class="hljs-string">&#x27;销售B组&#x27;</span>),
    (<span class="hljs-string">&#x27;手机&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>),
    (<span class="hljs-string">&#x27;平板&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>),
    (<span class="hljs-string">&#x27;笔记本&#x27;</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>),
    (<span class="hljs-string">&#x27;外围设备&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>),
]

<span class="hljs-comment"># 向表单中添加行</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:
    sheet.append(row)

<span class="hljs-comment"># 创建图表对象</span>
chart = BarChart()
chart.<span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;col&#x27;</span>
chart.style = <span class="hljs-number">10</span>
<span class="hljs-comment"># 设置图表的标题</span>
chart.title = <span class="hljs-string">&#x27;销售统计图&#x27;</span>
<span class="hljs-comment"># 设置图表纵轴的标题</span>
chart.y_axis.title = <span class="hljs-string">&#x27;销量&#x27;</span>
<span class="hljs-comment"># 设置图表横轴的标题</span>
chart.x_axis.title = <span class="hljs-string">&#x27;商品类别&#x27;</span>
<span class="hljs-comment"># 设置数据的范围</span>
data = Reference(sheet, min_col=<span class="hljs-number">2</span>, min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">5</span>, max_col=<span class="hljs-number">3</span>)
<span class="hljs-comment"># 设置分类的范围</span>
cats = Reference(sheet, min_col=<span class="hljs-number">1</span>, min_row=<span class="hljs-number">2</span>, max_row=<span class="hljs-number">5</span>)
<span class="hljs-comment"># 给图表添加数据</span>
chart.add_data(data, titles_from_data=<span class="hljs-literal">True</span>)
<span class="hljs-comment"># 给图表设置分类</span>
chart.set_categories(cats)
chart.shape = <span class="hljs-number">4</span>
<span class="hljs-comment"># 将图表添加到表单指定的单元格中</span>
sheet.add_chart(chart, <span class="hljs-string">&#x27;A10&#x27;</span>)

wb.save(<span class="hljs-string">&#x27;demo.xlsx&#x27;</span>)</code></pre>

<p>运行上面的代码，打开生成的Excel文件，效果如下图所示。</p>
<img src="https://github.com/jackfrued/mypic/raw/master/20210819235009.png" alt="image-20210819235009026" width="75%">

<h3 id="简单的总结-1"><a href="#简单的总结-1" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/模块收集/" title="模块综合">
                    模块综合
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python综合/">Python综合</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="排序函数-sorted函数"><a href="#排序函数-sorted函数" class="headerlink" title="排序函数_sorted函数"></a>排序函数_sorted函数</h2><p><code>sorted</code> 函数是 Python 内置的用于排序的函数。它可以对任何可迭代对象进行排序，并返回一个新的已排序的列表，而不会改变原始对象。</p>
<h3 id="sorted-函数的语法"><a href="#sorted-函数的语法" class="headerlink" title="sorted 函数的语法"></a><code>sorted</code> 函数的语法</h3><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(iterable, *, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)</code></pre>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol>
<li><strong>iterable</strong>：要排序的可迭代对象（如列表、元组、字符串等）。</li>
<li><strong>key</strong>：一个函数，它将用于从 iterable 的每个元素中提取用于比较的键。默认值为 None，即直接比较元素的值。</li>
<li><strong>reverse</strong>：一个布尔值。如果设为 True，将按降序排序。默认值为 False，即按升序排序。</li>
</ol>
<h3 id="示例和详细解释"><a href="#示例和详细解释" class="headerlink" title="示例和详细解释"></a>示例和详细解释</h3><ol>
<li><p><strong>基本使用</strong>：</p>
<pre><code class="hljs python">numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
sorted_numbers = <span class="hljs-built_in">sorted</span>(numbers)
<span class="hljs-built_in">print</span>(sorted_numbers)  <span class="hljs-comment"># 输出: [1, 2, 5, 5, 6, 9]</span></code></pre>
<p>这个示例将一个数字列表按升序排序。</p>
</li>
<li><p><strong>使用 key 参数</strong>：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]
sorted_words = <span class="hljs-built_in">sorted</span>(words, key=<span class="hljs-built_in">len</span>)
<span class="hljs-built_in">print</span>(sorted_words)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span></code></pre>
<p>在这个例子中，列表按单词的长度进行排序。</p>
</li>
<li><p><strong>按降序排序</strong>：</p>
<pre><code class="hljs python">numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
sorted_numbers = <span class="hljs-built_in">sorted</span>(numbers, reverse=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(sorted_numbers)  <span class="hljs-comment"># 输出: [9, 6, 5, 5, 2, 1]</span></code></pre>
<p>这个示例按降序对数字列表进行排序。</p>
</li>
<li><p><strong>结合使用 key 和 reverse</strong>：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]
sorted_words = <span class="hljs-built_in">sorted</span>(words, key=<span class="hljs-built_in">len</span>, reverse=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(sorted_words)  <span class="hljs-comment"># 输出: [&#x27;banana&#x27;, &#x27;cherry&#x27;, &#x27;apple&#x27;]</span></code></pre>
<p>这个示例先按单词长度排序，再按降序排列。</p>
</li>
<li><p><strong>复杂数据结构排序</strong>：</p>
<pre><code class="hljs python">students = [
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;,
    &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>&#125;,
]
sorted_students = <span class="hljs-built_in">sorted</span>(students, key=<span class="hljs-keyword">lambda</span> student: student[<span class="hljs-string">&#x27;age&#x27;</span>])
<span class="hljs-built_in">print</span>(sorted_students)</code></pre>
<p>输出：</p>
<pre><code class="hljs python">[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;,
 &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>&#125;,
 &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;grade&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>&#125;]</code></pre>
<p>在这个示例中，学生列表按年龄排序。</p>
</li>
</ol>
<h3 id="内置和自定义排序键"><a href="#内置和自定义排序键" class="headerlink" title="内置和自定义排序键"></a>内置和自定义排序键</h3><h4 id="按字符串排序："><a href="#按字符串排序：" class="headerlink" title="按字符串排序："></a>按字符串排序：</h4><pre><code class="hljs python">names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>]
sorted_names = <span class="hljs-built_in">sorted</span>(names)
<span class="hljs-built_in">print</span>(sorted_names)  <span class="hljs-comment"># 输出: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;]</span></code></pre>

<h4 id="按字符串长度排序："><a href="#按字符串长度排序：" class="headerlink" title="按字符串长度排序："></a>按字符串长度排序：</h4><pre><code class="hljs python">names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>]
sorted_names = <span class="hljs-built_in">sorted</span>(names, key=<span class="hljs-built_in">len</span>)
<span class="hljs-built_in">print</span>(sorted_names)  <span class="hljs-comment"># 输出: [&#x27;Bob&#x27;, &#x27;Alice&#x27;, &#x27;Charlie&#x27;]</span></code></pre>

<h4 id="自定义排序函数："><a href="#自定义排序函数：" class="headerlink" title="自定义排序函数："></a>自定义排序函数：</h4><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">custom_sort</span>(<span class="hljs-params">item</span>):
    <span class="hljs-keyword">return</span> item.lower()

names = [<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;charlie&quot;</span>]
sorted_names = <span class="hljs-built_in">sorted</span>(names, key=custom_sort)
<span class="hljs-built_in">print</span>(sorted_names)  <span class="hljs-comment"># 输出: [&#x27;alice&#x27;, &#x27;Bob&#x27;, &#x27;charlie&#x27;]</span></code></pre>

<h3 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h3><ul>
<li><strong>稳定排序</strong>：<code>sorted</code> 函数保证是稳定排序，这意味着当有多个记录具有相同键值时，它们的相对顺序在排序后会保持不变。</li>
<li><strong>复杂度</strong>：<code>sorted</code> 函数的时间复杂度为 O(n log n)，这是由于其底层实现是 Timsort，一种混合排序算法，结合了归并排序和插入排序的优点。</li>
</ul>
<h2 id="string-模块"><a href="#string-模块" class="headerlink" title="string 模块"></a>string 模块</h2><p>Python 的 <code>string</code> 模块提供了许多有用的字符串操作功能和常量，方便进行字符串处理。下面是 <code>string</code> 模块的一些主要功能和内容：</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li><code>string.ascii_letters</code>: 包含所有 ASCII 字母（大写和小写）。</li>
<li><code>string.ascii_lowercase</code>: 包含所有 ASCII 小写字母。</li>
<li><code>string.ascii_uppercase</code>: 包含所有 ASCII 大写字母。</li>
<li><code>string.digits</code>: 包含所有十进制数字（0-9）。</li>
<li><code>string.hexdigits</code>: 包含所有十六进制数字（0-9 和 a-f 和 A-F）。</li>
<li><code>string.octdigits</code>: 包含所有八进制数字（0-7）。</li>
<li><code>string.punctuation</code>: 包含所有 ASCII 标点符号。</li>
<li><code>string.printable</code>: 包含所有可打印字符（包括数字、字母、标点符号和空白字符）。</li>
<li><code>string.whitespace</code>: 包含所有空白字符（如空格、制表符、换行符等）。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>string.capwords(s, sep=None)</code>: 将字符串 <code>s</code> 中的单词首字母大写，其他字母小写。单词以 <code>sep</code> 作为分隔符（默认为空格）。</li>
</ul>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p><code>join</code> 方法是 Python 中字符串对象的一个方法，用于将一个可迭代对象（如列表、元组等）中的元素连接成一个字符串。连接时，元素之间会插入调用 <code>join</code> 方法的字符串。常见的用法为将列表中的字符串元素连接成一个长字符串。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs python"><span class="hljs-built_in">str</span>.join(iterable)</code></pre>

<ul>
<li><code>str</code>：调用 <code>join</code> 方法的字符串，用作连接符。</li>
<li><code>iterable</code>：一个可迭代对象，其元素是要连接成一个字符串的子字符串。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>将一个字符串列表用逗号连接成一个字符串：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>]
result = <span class="hljs-string">&quot;,&quot;</span>.join(words)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: hello,world,python</span></code></pre>

<p>在这个例子中，<code>&quot;,&quot;.join(words)</code> 会将 <code>words</code> 列表中的每个字符串元素连接起来，每两个元素之间插入一个逗号。</p>
<h4 id="用空格连接"><a href="#用空格连接" class="headerlink" title="用空格连接"></a>用空格连接</h4><p>将一个字符串列表用空格连接成一个字符串：</p>
<pre><code class="hljs python">words = [<span class="hljs-string">&quot;join&quot;</span>, <span class="hljs-string">&quot;method&quot;</span>, <span class="hljs-string">&quot;in&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>]
result = <span class="hljs-string">&quot; &quot;</span>.join(words)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: join method in python</span></code></pre>

<h4 id="用换行符连接"><a href="#用换行符连接" class="headerlink" title="用换行符连接"></a>用换行符连接</h4><p>将一个字符串列表用换行符连接成一个字符串：</p>
<pre><code class="hljs python">lines = [<span class="hljs-string">&quot;line1&quot;</span>, <span class="hljs-string">&quot;line2&quot;</span>, <span class="hljs-string">&quot;line3&quot;</span>]
result = <span class="hljs-string">&quot;\n&quot;</span>.join(lines)
<span class="hljs-built_in">print</span>(result)
<span class="hljs-comment"># 输出:</span>
<span class="hljs-comment"># line1</span>
<span class="hljs-comment"># line2</span>
<span class="hljs-comment"># line3</span></code></pre>

<h4 id="连接字符"><a href="#连接字符" class="headerlink" title="连接字符"></a>连接字符</h4><p>将一个字符列表连接成一个字符串：</p>
<pre><code class="hljs python">chars = [<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>]
result = <span class="hljs-string">&quot;&quot;</span>.join(chars)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: Python</span></code></pre>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>元素必须是字符串</strong>：<code>join</code> 方法只能连接字符串类型的元素。如果可迭代对象中的元素不是字符串类型，会引发 <code>TypeError</code>。</p>
 <pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
result = <span class="hljs-string">&quot;,&quot;</span>.join(numbers)  <span class="hljs-comment"># 会引发 TypeError</span></code></pre>
<p> 如果需要连接非字符串类型的元素，可以先将它们转换为字符串：</p>
 <pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
result = <span class="hljs-string">&quot;,&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, numbers))
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 1,2,3,4</span></code></pre>
</li>
<li><p><strong>可迭代对象</strong>：<code>join</code> 方法可以处理任何可迭代对象（如列表、元组、集合等），只要其中的元素是字符串。</p>
 <pre><code class="hljs python">words = (<span class="hljs-string">&quot;tuple&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;join&quot;</span>)
result = <span class="hljs-string">&quot; &quot;</span>.join(words)
<span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: tuple example join</span></code></pre>
</li>
<li><p><strong>性能</strong>：<code>join</code> 方法比使用循环和字符串拼接（如使用 <code>+</code> 运算符）效率更高，尤其是在连接大量字符串时，<code>join</code> 方法的性能优势更加明显，因为它避免了创建多个中间字符串。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>join</code> 方法是一个非常实用的字符串方法，用于将可迭代对象中的字符串元素连接成一个字符串。通过灵活使用 <code>join</code> 方法，可以方便地处理字符串的连接和拼接操作。</p>
<h2 id="statistics模块"><a href="#statistics模块" class="headerlink" title="statistics模块"></a>statistics模块</h2><p><code>statistics</code> 模块是 Python 的标准库模块之一，用于执行基本的统计运算。这个模块提供了多种函数，帮助用户对数据进行统计分析，例如求平均值、中位数、标准差等。</p>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><p><code>statistics</code> 模块包含的功能主要分为以下几类：</p>
<ol>
<li><strong>均值和中位数计算</strong></li>
<li><strong>方差和标准差计算</strong></li>
<li><strong>分位数和百分位数计算</strong></li>
<li><strong>其他统计函数</strong></li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="均值和中位数"><a href="#均值和中位数" class="headerlink" title="均值和中位数"></a>均值和中位数</h4><ul>
<li><code>mean(data)</code>: 返回数据的算术平均值。</li>
<li><code>median(data)</code>: 返回数据的中位数。</li>
<li><code>mode(data)</code>: 返回数据的众数（出现次数最多的值）。</li>
<li><code>harmonic_mean(data)</code>: 返回数据的调和平均值。</li>
</ul>
<h4 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h4><ul>
<li><code>variance(data, xbar=None)</code>: 返回数据的样本方差。</li>
<li><code>stdev(data, xbar=None)</code>: 返回数据的样本标准差。</li>
<li><code>pstdev(data, mu=None)</code>: 返回数据的总体标准差。</li>
<li><code>pvariance(data, mu=None)</code>: 返回数据的总体方差。</li>
</ul>
<h4 id="分位数和百分位数"><a href="#分位数和百分位数" class="headerlink" title="分位数和百分位数"></a>分位数和百分位数</h4><ul>
<li><code>median_low(data)</code>: 返回数据的低中位数（当数据个数为偶数时，返回较小的那个中位数）。</li>
<li><code>median_high(data)</code>: 返回数据的高中位数（当数据个数为偶数时，返回较大的那个中位数）。</li>
<li><code>median_grouped(data, interval=1)</code>: 返回分组数据的中位数。</li>
<li><code>quantiles(data, n=4, method=&#39;exclusive&#39;)</code>: 返回数据的分位数。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是使用 <code>statistics</code> 模块的几个示例：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> statistics <span class="hljs-keyword">as</span> stats

data = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]

<span class="hljs-comment"># 均值</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mean:&quot;</span>, stats.mean(data))  <span class="hljs-comment"># 输出: Mean: 5</span>

<span class="hljs-comment"># 中位数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Median:&quot;</span>, stats.median(data))  <span class="hljs-comment"># 输出: Median: 4.5</span>

<span class="hljs-comment"># 众数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mode:&quot;</span>, stats.mode(data))  <span class="hljs-comment"># 输出: Mode: 4</span>

<span class="hljs-comment"># 方差</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Variance:&quot;</span>, stats.variance(data))  <span class="hljs-comment"># 输出: Variance: 4.571428571428571</span>

<span class="hljs-comment"># 标准差</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Standard Deviation:&quot;</span>, stats.stdev(data))  <span class="hljs-comment"># 输出: Standard Deviation: 2.138089935299395</span>

<span class="hljs-comment"># 分位数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Quantiles:&quot;</span>, stats.quantiles(data))  <span class="hljs-comment"># 输出: Quantiles: [4.0, 4.5, 5.0]</span></code></pre>

<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol>
<li><strong>输入数据</strong>：大部分函数的参数是一个可迭代对象（如列表、元组等），其中的元素应该是数值类型。</li>
<li><strong>样本与总体</strong>：方差和标准差的计算函数区分了样本和总体。<code>variance</code> 和 <code>stdev</code> 计算样本的方差和标准差，而 <code>pvariance</code> 和 <code>pstdev</code> 计算总体的方差和标准差。</li>
<li><strong>异常处理</strong>：在使用这些函数时，如果数据中包含非数值类型或数据为空，会引发 <code>StatisticsError</code> 异常。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>statistics</code> 模块是进行基础统计分析的有力工具，涵盖了从简单的平均值计算到复杂的方差和分位数计算的广泛功能。它使得统计运算在 Python 中变得简单和高效，适用于各种数据分析和科学计算的场景。</p>
<h2 id="operator模块"><a href="#operator模块" class="headerlink" title="operator模块"></a>operator模块</h2><p><code>operator</code> 模块是 Python 的一个标准库模块，提供了一系列函数对应于 Python 中的标准运算符。这些函数可以使代码更具可读性，并且在需要传递函数作为参数时尤其有用。<code>operator</code> 模块的功能包括基本的算术运算、比较运算、逻辑运算、序列操作等。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p><code>operator</code> 模块包含以下几类操作函数：</p>
<ol>
<li><strong>算术运算</strong></li>
<li><strong>比较运算</strong></li>
<li><strong>逻辑运算</strong></li>
<li><strong>序列和映射操作</strong></li>
<li><strong>属性和方法操作</strong></li>
</ol>
<h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="算术运算函数"><a href="#算术运算函数" class="headerlink" title="算术运算函数"></a>算术运算函数</h4><ul>
<li><code>add(a, b)</code>: 返回 <code>a + b</code></li>
<li><code>sub(a, b)</code>: 返回 <code>a - b</code></li>
<li><code>mul(a, b)</code>: 返回 <code>a * b</code></li>
<li><code>truediv(a, b)</code>: 返回 <code>a / b</code>（浮点除法）</li>
<li><code>floordiv(a, b)</code>: 返回 <code>a // b</code>（整数除法）</li>
<li><code>mod(a, b)</code>: 返回 <code>a % b</code></li>
<li><code>pow(a, b)</code>: 返回 <code>a ** b</code></li>
</ul>
<h4 id="比较运算函数"><a href="#比较运算函数" class="headerlink" title="比较运算函数"></a>比较运算函数</h4><ul>
<li><code>eq(a, b)</code>: 返回 <code>a == b</code></li>
<li><code>ne(a, b)</code>: 返回 <code>a != b</code></li>
<li><code>lt(a, b)</code>: 返回 <code>a &lt; b</code></li>
<li><code>le(a, b)</code>: 返回 <code>a &lt;= b</code></li>
<li><code>gt(a, b)</code>: 返回 <code>a &gt; b</code></li>
<li><code>ge(a, b)</code>: 返回 <code>a &gt;= b</code></li>
</ul>
<h4 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h4><ul>
<li><code>and_(a, b)</code>: 返回 <code>a and b</code></li>
<li><code>or_(a, b)</code>: 返回 <code>a or b</code></li>
<li><code>not_(a)</code>: 返回 <code>not a</code></li>
</ul>
<h4 id="序列和映射操作函数"><a href="#序列和映射操作函数" class="headerlink" title="序列和映射操作函数"></a>序列和映射操作函数</h4><ul>
<li><code>getitem(obj, key)</code>: 返回 <code>obj[key]</code></li>
<li><code>setitem(obj, key, value)</code>: 设置 <code>obj[key] = value</code></li>
<li><code>delitem(obj, key)</code>: 删除 <code>obj[key]</code></li>
<li><code>contains(obj, key)</code>: 返回 <code>key in obj</code></li>
<li><code>concat(a, b)</code>: 返回 <code>a + b</code>（序列连接）</li>
<li><code>countOf(a, b)</code>: 返回 <code>a</code> 中 <code>b</code> 的个数</li>
<li><code>indexOf(a, b)</code>: 返回 <code>a</code> 中第一次出现 <code>b</code> 的索引</li>
</ul>
<h4 id="属性和方法操作函数"><a href="#属性和方法操作函数" class="headerlink" title="属性和方法操作函数"></a>属性和方法操作函数</h4><ul>
<li><code>attrgetter(attr)</code>: 返回一个可调用对象，从对象获取名为 <code>attr</code> 的属性</li>
<li><code>itemgetter(*items)</code>: 返回一个可调用对象，从对象获取指定的多个值</li>
<li><code>methodcaller(name, *args, **kwargs)</code>: 返回一个可调用对象，对对象调用名为 <code>name</code> 的方法，并传递给定的参数和关键字参数</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下是使用 <code>operator</code> 模块的一些示例：</p>
<h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

a, b = <span class="hljs-number">5</span>, <span class="hljs-number">3</span>

<span class="hljs-built_in">print</span>(operator.add(a, b))  <span class="hljs-comment"># 输出: 8</span>
<span class="hljs-built_in">print</span>(operator.mul(a, b))  <span class="hljs-comment"># 输出: 15</span>
<span class="hljs-built_in">print</span>(operator.<span class="hljs-built_in">pow</span>(a, b))  <span class="hljs-comment"># 输出: 125</span></code></pre>

<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

a, b = <span class="hljs-number">5</span>, <span class="hljs-number">3</span>

<span class="hljs-built_in">print</span>(operator.lt(a, b))  <span class="hljs-comment"># 输出: False</span>
<span class="hljs-built_in">print</span>(operator.ge(a, b))  <span class="hljs-comment"># 输出: True</span>
<span class="hljs-built_in">print</span>(operator.eq(a, b))  <span class="hljs-comment"># 输出: False</span></code></pre>

<h4 id="序列和映射操作"><a href="#序列和映射操作" class="headerlink" title="序列和映射操作"></a>序列和映射操作</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

<span class="hljs-built_in">print</span>(operator.getitem(lst, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出: 3</span>
operator.setitem(lst, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)
<span class="hljs-built_in">print</span>(lst)  <span class="hljs-comment"># 输出: [1, 2, 10, 4, 5]</span>
operator.delitem(lst, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(lst)  <span class="hljs-comment"># 输出: [1, 2, 4, 5]</span>

d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;
<span class="hljs-built_in">print</span>(operator.getitem(d, <span class="hljs-string">&#x27;b&#x27;</span>))  <span class="hljs-comment"># 输出: 2</span></code></pre>

<h4 id="属性和方法操作"><a href="#属性和方法操作" class="headerlink" title="属性和方法操作"></a>属性和方法操作</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> operator

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.age = age

p = Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>)

name = operator.attrgetter(<span class="hljs-string">&#x27;name&#x27;</span>)
<span class="hljs-built_in">print</span>(name(p))  <span class="hljs-comment"># 输出: Alice</span>

data = [(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>), (<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">35</span>)]
data.sort(key=operator.itemgetter(<span class="hljs-number">1</span>))
<span class="hljs-built_in">print</span>(data)  <span class="hljs-comment"># 输出: [(&#x27;Bob&#x27;, 25), (&#x27;Alice&#x27;, 30), (&#x27;Charlie&#x27;, 35)]</span></code></pre>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>operator</code> 模块提供了对 Python 内置运算符的函数接口，使得代码在处理操作时更加清晰和灵活。特别是在需要将函数作为参数传递的情况下，这些函数显得尤为有用。通过使用 <code>operator</code> 模块，可以提高代码的可读性和可维护性。</p>
<h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><p>Python 的 <code>random</code> 模块提供了各种生成随机数和执行随机操作的函数。以下是 <code>random</code> 模块中的主要功能和使用方法：</p>
<h3 id="1-生成随机数"><a href="#1-生成随机数" class="headerlink" title="1. 生成随机数"></a>1. 生成随机数</h3><ul>
<li><p><strong>随机浮点数</strong></p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> random

<span class="hljs-comment"># 生成 0 到 1 之间的随机浮点数</span>
random_float = random.random()
<span class="hljs-built_in">print</span>(random_float)  <span class="hljs-comment"># 例如 0.37444887175646646</span></code></pre>
</li>
<li><p><strong>指定范围内的随机浮点数</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成 [a, b] 之间的随机浮点数</span>
random_float = random.uniform(a, b)
<span class="hljs-built_in">print</span>(random_float)</code></pre>
</li>
<li><p><strong>随机整数</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成 [a, b] 之间的随机整数</span>
random_int = random.randint(a, b)
<span class="hljs-built_in">print</span>(random_int)</code></pre>
</li>
<li><p><strong>指定步长的随机整数</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成 range(start, stop, step) 范围内的随机整数</span>
random_int = random.randrange(start, stop, step)
<span class="hljs-built_in">print</span>(random_int)</code></pre></li>
</ul>
<h3 id="2-随机选择"><a href="#2-随机选择" class="headerlink" title="2. 随机选择"></a>2. 随机选择</h3><ul>
<li><p><strong>从序列中随机选择一个元素</strong></p>
<pre><code class="hljs python">choices = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]
random_choice = random.choice(choices)
<span class="hljs-built_in">print</span>(random_choice)  <span class="hljs-comment"># 例如 &#x27;banana&#x27;</span></code></pre>
</li>
<li><p><strong>从序列中随机选择多个元素</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 从序列中随机选择 k 个元素，可以有重复</span>
random_choices = random.choices(choices, k=<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(random_choices)  <span class="hljs-comment"># 例如 [&#x27;cherry&#x27;, &#x27;banana&#x27;, &#x27;banana&#x27;]</span></code></pre>
</li>
<li><p><strong>从序列中随机选择多个不重复元素</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 从序列中随机选择 k 个不重复元素</span>
random_sample = random.sample(choices, k=<span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(random_sample)  <span class="hljs-comment"># 例如 [&#x27;banana&#x27;, &#x27;apple&#x27;]</span></code></pre></li>
</ul>
<h3 id="3-打乱顺序"><a href="#3-打乱顺序" class="headerlink" title="3. 打乱顺序"></a>3. 打乱顺序</h3><ul>
<li><p><strong>就地打乱列表中的元素顺序</strong></p>
<pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
random.shuffle(numbers)
<span class="hljs-built_in">print</span>(numbers)  <span class="hljs-comment"># 例如 [3, 5, 1, 2, 4]</span></code></pre></li>
</ul>
<h3 id="4-生成随机分布"><a href="#4-生成随机分布" class="headerlink" title="4. 生成随机分布"></a>4. 生成随机分布</h3><ul>
<li><p><strong>正态分布（高斯分布）</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 生成均值为 mu，标准差为 sigma 的随机浮点数</span>
random_gauss = random.gauss(mu, sigma)
<span class="hljs-built_in">print</span>(random_gauss)</code></pre>
</li>
<li><p><strong>其他分布</strong></p>
<ul>
<li><p><strong>Beta 分布</strong></p>
<pre><code class="hljs python">random_beta = random.betavariate(alpha, beta)
<span class="hljs-built_in">print</span>(random_beta)</code></pre>
</li>
<li><p><strong>Gamma 分布</strong></p>
<pre><code class="hljs python">random_gamma = random.gammavariate(alpha, beta)
<span class="hljs-built_in">print</span>(random_gamma)</code></pre>
</li>
<li><p><strong>指数分布</strong></p>
<pre><code class="hljs python">random_exp = random.expovariate(lambd)
<span class="hljs-built_in">print</span>(random_exp)</code></pre>
</li>
<li><p><strong>对数正态分布</strong></p>
<pre><code class="hljs python">random_lognorm = random.lognormvariate(mu, sigma)
<span class="hljs-built_in">print</span>(random_lognorm)</code></pre>
</li>
<li><p><strong>Pareto 分布</strong></p>
<pre><code class="hljs python">random_pareto = random.paretovariate(alpha)
<span class="hljs-built_in">print</span>(random_pareto)</code></pre>
</li>
<li><p><strong>维布尔分布</strong></p>
<pre><code class="hljs python">random_weibull = random.weibullvariate(alpha, beta)
<span class="hljs-built_in">print</span>(random_weibull)</code></pre></li>
</ul>
</li>
</ul>
<h3 id="5-种子控制"><a href="#5-种子控制" class="headerlink" title="5. 种子控制"></a>5. 种子控制</h3><ul>
<li><p><strong>设置随机数生成器的种子</strong></p>
<pre><code class="hljs python">random.seed(a)</code></pre>

<p>使用相同的种子可以确保生成的随机数序列相同，对于调试和测试非常有用。</p>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Python 的 <code>random</code> 模块提供了丰富的随机数生成和操作函数，涵盖了基本的随机数生成、序列操作和多种随机分布。通过这些函数，可以方便地在各种应用中实现随机行为。</p>
<h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>Python 的 <code>time</code> 模块提供了多种与时间相关的函数，用于处理时间和日期。以下是 <code>time</code> 模块中的主要功能和使用方法：</p>
<h3 id="1-获取当前时间"><a href="#1-获取当前时间" class="headerlink" title="1. 获取当前时间"></a>1. 获取当前时间</h3><ul>
<li><p><strong>获取当前时间的时间戳</strong></p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> time <span class="hljs-comment">#返回当前时间的时间戳（自 Unix 纪元（1970年1月1日）以来的秒数）</span>
  <span class="hljs-built_in">print</span>(current_time)  <span class="hljs-comment"># 例如 1623673923.786348</span></code></pre>
</li>
<li><p><strong>获取当前时间的结构化时间（本地时间）</strong></p>
<pre><code class="hljs python">local_time = time.localtime() <span class="hljs-comment"># 返回当前时间的本地时间结构</span>
<span class="hljs-built_in">print</span>(local_time)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre>
</li>
<li><p><strong>获取当前时间的结构化时间（UTC 时间）</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 返回当前时间的 UTC 时间结构</span>
utc_time = time.gmtime()
<span class="hljs-built_in">print</span>(utc_time)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre></li>
</ul>
<h3 id="2-格式化时间"><a href="#2-格式化时间" class="headerlink" title="2. 格式化时间"></a>2. 格式化时间</h3><ul>
<li><p><strong>将时间结构转换为字符串</strong></p>
<pre><code class="hljs python"><span class="hljs-comment"># 将当前本地时间转换为字符串</span>
formatted_time = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, local_time)
<span class="hljs-built_in">print</span>(formatted_time)  <span class="hljs-comment"># 例如 &#x27;2021-06-14 10:32:03&#x27;</span></code></pre>
</li>
<li><p><strong>将字符串解析为时间结构</strong></p>
<pre><code class="hljs python">time_string = <span class="hljs-string">&quot;2021-06-14 10:32:03&quot;</span>
<span class="hljs-comment"># 将字符串解析为时间结构</span>
parsed_time = time.strptime(time_string, <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)
<span class="hljs-built_in">print</span>(parsed_time)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre></li>
</ul>
<h3 id="3-时间戳和时间结构之间的转换"><a href="#3-时间戳和时间结构之间的转换" class="headerlink" title="3. 时间戳和时间结构之间的转换"></a>3. 时间戳和时间结构之间的转换</h3><ul>
<li><p><strong>时间戳转换为本地时间结构</strong></p>
<pre><code class="hljs python">timestamp = <span class="hljs-number">1623673923.786348</span>
local_time_from_timestamp = time.localtime(timestamp)
<span class="hljs-built_in">print</span>(local_time_from_timestamp)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre>
</li>
<li><p><strong>时间戳转换为 UTC 时间结构</strong></p>
<pre><code class="hljs python">utc_time_from_timestamp = time.gmtime(timestamp)
<span class="hljs-built_in">print</span>(utc_time_from_timestamp)  <span class="hljs-comment"># 例如 time.struct_time(tm_year=2021, tm_mon=6, tm_mday=14, ...)</span></code></pre>
</li>
<li><p><strong>时间结构转换为时间戳</strong></p>
<pre><code class="hljs python">timestamp_from_local_time = time.mktime(local_time)
<span class="hljs-built_in">print</span>(timestamp_from_local_time)  <span class="hljs-comment"># 例如 1623673923.0</span></code></pre></li>
</ul>
<h3 id="4-暂停程序执行"><a href="#4-暂停程序执行" class="headerlink" title="4. 暂停程序执行"></a>4. 暂停程序执行</h3><ul>
<li><p><strong>暂停程序执行指定秒数</strong></p>
<pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start&quot;</span>)
time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 暂停程序执行 2 秒</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;End&quot;</span>)</code></pre></li>
</ul>
<h3 id="5-其他实用功能"><a href="#5-其他实用功能" class="headerlink" title="5. 其他实用功能"></a>5. 其他实用功能</h3><ul>
<li><p><strong>获取 CPU 时间</strong></p>
<pre><code class="hljs python">cpu_time = time.process_time()
<span class="hljs-built_in">print</span>(cpu_time)  <span class="hljs-comment"># 例如 0.015625</span></code></pre>
</li>
<li><p><strong>测量时间间隔</strong></p>
<pre><code class="hljs python">start_time = time.perf_counter()
<span class="hljs-comment"># 进行一些操作</span>
end_time = time.perf_counter()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;操作耗时: <span class="hljs-subst">&#123;end_time - start_time&#125;</span> 秒&quot;</span>)</code></pre>
</li>
<li><p><strong>获取系统时区偏移量</strong></p>
<pre><code class="hljs python">timezone_offset = time.timezone  <span class="hljs-comment"># 返回本地时区相对于 UTC 的偏移量（秒）</span>
<span class="hljs-built_in">print</span>(timezone_offset)  <span class="hljs-comment"># 例如 -28800（对于 UTC-8 时区）</span></code></pre>
</li>
<li><p><strong>获取夏令时标志</strong></p>
<pre><code class="hljs python">daylight_saving_flag = time.daylight  <span class="hljs-comment"># 返回夏令时是否被定义</span>
<span class="hljs-built_in">print</span>(daylight_saving_flag)  <span class="hljs-comment"># 例如 1（表示夏令时定义）</span></code></pre></li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Python 的 <code>time</code> 模块提供了丰富的时间和日期操作功能，包括获取当前时间、格式化时间、时间戳和结构化时间的转换、暂停程序执行、测量时间间隔等。通过这些函数，可以在各种应用场景中方便地处理时间相关的数据。</p>
<h2 id="装饰器详细解释"><a href="#装饰器详细解释" class="headerlink" title="装饰器详细解释"></a>装饰器详细解释</h2><h3 id="装饰器的基本结构"><a href="#装饰器的基本结构" class="headerlink" title="装饰器的基本结构"></a>装饰器的基本结构</h3><p>装饰器是一个用于包裹另一个函数以增强或修改其行为的函数。装饰器本身是一个高阶函数，因为它接受一个函数作为参数，并返回一个新的函数。下面是一个最简单的装饰器结构：</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-comment"># 在这里添加增强功能的代码</span>
        result = func(*args, **kwargs)
        <span class="hljs-comment"># 在这里添加增强功能的代码</span>
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> wrapper</code></pre>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol>
<li><p><strong>decorator 函数</strong>：</p>
<ul>
<li><code>decorator(func)</code> 是装饰器函数，它接受一个函数 <code>func</code> 作为参数。</li>
<li><code>func</code> 是你想要增强或修改的函数。</li>
</ul>
</li>
<li><p><strong>wrapper 函数</strong>：</p>
<ul>
<li>在 <code>decorator</code> 函数内部定义了一个 <code>wrapper</code> 函数。</li>
<li><code>wrapper(*args, **kwargs)</code> 是一个包装函数，它接受任意数量的参数和关键字参数，并将它们传递给原始函数 <code>func</code>。</li>
<li><code>*args</code> 和 <code>**kwargs</code> 确保 <code>wrapper</code> 能处理所有类型的参数（位置参数和关键字参数），与 <code>func</code> 的参数一致。</li>
</ul>
</li>
<li><p><strong>增强功能</strong>：</p>
<ul>
<li>在 <code>wrapper</code> 函数中，你可以在调用原始函数 <code>func</code> 前后添加增强功能的代码。</li>
<li>例如，你可以在调用 <code>func</code> 前记录开始时间，在调用 <code>func</code> 后记录结束时间，并计算运行时间。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li><code>wrapper</code> 函数调用 <code>func(*args, **kwargs)</code> 并将结果存储在 <code>result</code> 变量中。</li>
<li><code>wrapper</code> 函数最终返回 <code>result</code>，即原始函数的返回值。</li>
</ul>
</li>
<li><p><strong>返回 wrapper</strong>：</p>
<ul>
<li><code>decorator</code> 函数返回 <code>wrapper</code> 函数。</li>
<li>这意味着当你用 <code>@decorator</code> 语法装饰一个函数时，这个函数会被 <code>wrapper</code> 替代，增强功能也随之生效。</li>
</ul>
</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>我们来看一个实际应用的例子，使用装饰器来记录函数的执行时间：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 定义装饰器函数</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">record_time</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        start_time = time.time()  <span class="hljs-comment"># 计时开始</span>
        result = func(*args, **kwargs)
        end_time = time.time()    <span class="hljs-comment"># 计时结束</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func.__name__&#125;</span> executed in <span class="hljs-subst">&#123;end_time - start_time&#125;</span> seconds&quot;</span>)
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment"># 使用装饰器</span>
<span class="hljs-meta">@record_time</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">file</span>):
    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟上传文件的延时</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Uploading <span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)

<span class="hljs-meta">@record_time</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">file</span>):
    time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟下载文件的延时</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Downloading <span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)

<span class="hljs-comment"># 调用被装饰的函数</span>
upload(<span class="hljs-string">&quot;file1.txt&quot;</span>)
download(<span class="hljs-string">&quot;file2.txt&quot;</span>)</code></pre>

<h3 id="详细解释实际应用"><a href="#详细解释实际应用" class="headerlink" title="详细解释实际应用"></a>详细解释实际应用</h3><ol>
<li><p><strong>定义装饰器</strong>：</p>
<ul>
<li><code>record_time</code> 函数是装饰器，它接受一个函数 <code>func</code> 作为参数。</li>
</ul>
</li>
<li><p><strong>定义 wrapper</strong>：</p>
<ul>
<li><code>wrapper(*args, **kwargs)</code> 函数在 <code>record_time</code> 内部定义。</li>
<li><code>start_time = time.time()</code> 记录函数执行开始时间。</li>
<li><code>result = func(*args, **kwargs)</code> 调用原始函数 <code>func</code>，并传递所有参数。</li>
<li><code>end_time = time.time()</code> 记录函数执行结束时间。</li>
<li><code>print(f&quot;&#123;func.__name__&#125; executed in &#123;end_time - start_time&#125; seconds&quot;)</code> 打印函数的执行时间。</li>
<li><code>return result</code> 返回原始函数的返回值。</li>
</ul>
</li>
<li><p><strong>返回 wrapper</strong>：</p>
<ul>
<li><code>record_time</code> 函数返回 <code>wrapper</code> 函数。</li>
</ul>
</li>
<li><p><strong>使用装饰器</strong>：</p>
<ul>
<li>使用 <code>@record_time</code> 语法将 <code>upload</code> 和 <code>download</code> 函数装饰。</li>
<li>这意味着 <code>upload</code> 和 <code>download</code> 函数实际上是 <code>wrapper</code> 函数。</li>
</ul>
</li>
<li><p><strong>调用被装饰的函数</strong>：</p>
<ul>
<li>调用 <code>upload(&quot;file1.txt&quot;)</code> 时，实际上调用的是 <code>wrapper(&quot;file1.txt&quot;)</code>。</li>
<li><code>wrapper</code> 函数记录开始时间，调用原始 <code>upload</code> 函数，记录结束时间，并打印执行时间。</li>
<li><code>download(&quot;file2.txt&quot;)</code> 的过程相同。</li>
</ul>
</li>
</ol>
<p>通过这种方式，我们将记录时间的逻辑与具体的业务逻辑分离，使代码更加清晰和模块化。</p>
<h2 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h2><p><code>itertools</code> 模块是 Python 的一个标准库模块，提供了许多用于高效循环和迭代的函数工具。这个模块包含了一组用于处理迭代器的函数，能够实现复杂的迭代逻辑。以下是 <code>itertools</code> 模块中一些常用功能及其简要介绍：</p>
<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><ol>
<li><p>**<code>count(start=0, step=1)</code>**：</p>
<ul>
<li>创建一个无限迭代器，从 <code>start</code> 开始，步长为 <code>step</code>。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.count(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>):
    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">20</span>:
        <span class="hljs-keyword">break</span>
    <span class="hljs-built_in">print</span>(i)</code></pre></li>
</ul>
</li>
<li><p>**<code>cycle(iterable)</code>**：</p>
<ul>
<li>创建一个无限迭代器，从给定的 <code>iterable</code> 中重复迭代元素。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
count = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.cycle(<span class="hljs-string">&#x27;AB&#x27;</span>):
    <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">5</span>:
        <span class="hljs-keyword">break</span>
    <span class="hljs-built_in">print</span>(item)
    count += <span class="hljs-number">1</span></code></pre></li>
</ul>
</li>
<li><p>**<code>repeat(object, times=None)</code>**：</p>
<ul>
<li>创建一个迭代器，重复给定的对象 <code>times</code> 次。如果 <code>times</code> 为 <code>None</code>，则无限重复。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.repeat(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">3</span>):
    <span class="hljs-built_in">print</span>(item)</code></pre></li>
</ul>
</li>
<li><p>**<code>chain(*iterables)</code>**：</p>
<ul>
<li>将多个迭代器连接成一个迭代器。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.chain(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-string">&#x27;DEF&#x27;</span>):
    <span class="hljs-built_in">print</span>(item)</code></pre></li>
</ul>
</li>
<li><p>**<code>islice(iterable, start, stop, step=1)</code>**：</p>
<ul>
<li>创建一个迭代器，从 <code>iterable</code> 中切片，类似于列表切片。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itertools.islice(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>):
    <span class="hljs-built_in">print</span>(item)		<span class="hljs-comment">#C	D	E	F</span></code></pre></li>
</ul>
</li>
<li><p>**<code>compress(data, selectors)</code>**：</p>
<ul>
<li>过滤 <code>data</code> 中的元素，只保留与 <code>selectors</code> 中的<strong>真值</strong>对应的元素。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
data = <span class="hljs-string">&#x27;ABCDEF&#x27;</span>
selectors = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.compress(data, selectors)))		<span class="hljs-comment">#[&#x27;A&#x27;, &#x27;C&#x27;, &#x27;E&#x27;]</span></code></pre></li>
</ul>
</li>
<li><p>**<code>permutations(iterable, r=None)</code>**：</p>
<ul>
<li>返回 <code>iterable</code> 中元素的所有可能排列，长度为 <code>r</code>。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.permutations(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-number">2</span>)))</code></pre></li>
</ul>
</li>
<li><p>**<code>combinations(iterable, r)</code>**：</p>
<ul>
<li>返回 <code>iterable</code> 中元素的所有可能组合，长度为 <code>r</code>。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.combinations(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-number">2</span>)))	<span class="hljs-comment">#[(&#x27;A&#x27;, &#x27;B&#x27;), (&#x27;A&#x27;, &#x27;C&#x27;), (&#x27;B&#x27;, &#x27;C&#x27;)]</span></code></pre></li>
</ul>
</li>
<li><p>**<code>combinations_with_replacement(iterable, r)</code>**：</p>
<ul>
<li>返回 <code>iterable</code> 中元素的所有可能组合，长度为 <code>r</code>，允许元素重复。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.combinations_with_replacement(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-number">2</span>)))
<span class="hljs-comment"># [(&#x27;A&#x27;, &#x27;A&#x27;), (&#x27;A&#x27;, &#x27;B&#x27;), (&#x27;A&#x27;, &#x27;C&#x27;), (&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;B&#x27;, &#x27;C&#x27;), (&#x27;C&#x27;, &#x27;C&#x27;)]</span></code></pre></li>
</ul>
</li>
<li><p>**<code>product(*iterables, repeat=1)</code>**：</p>
<ul>
<li>返回多个迭代器的笛卡尔积，可以通过 <code>repeat</code> 参数指定重复次数。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.product(<span class="hljs-string">&#x27;AB&#x27;</span>, <span class="hljs-string">&#x27;CD&#x27;</span>)))</code></pre></li>
</ul>
</li>
<li><p>**<code>groupby(iterable, key=None)</code>**：</p>
<ul>
<li>对 <code>iterable</code> 中的相邻元素进行分组，<code>key</code> 为分组依据的函数。</li>
<li>示例：<pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools
data = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">4</span>)]
<span class="hljs-keyword">for</span> key, group <span class="hljs-keyword">in</span> itertools.groupby(data, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]):
    <span class="hljs-built_in">print</span>(key, <span class="hljs-built_in">list</span>(group))</code></pre></li>
</ul>
</li>
</ol>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><code>itertools</code> 模块提供了一组非常有用的迭代器工具，这些工具在处理大数据集、生成无限序列、组合和排列等任务中非常高效。通过这些工具，能够简化代码、提高执行效率，同时保持代码的可读性和可维护性。</p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>Python提供了<code>re</code>模块来支持正则表达式相关操作，下面是<code>re</code>模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>compile(pattern, flags=0)</code></td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td><code>match(pattern, string, flags=0)</code></td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回<code>None</code></td>
</tr>
<tr>
<td><code>search(pattern, string, flags=0)</code></td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回<code>None</code></td>
</tr>
<tr>
<td><code>split(pattern, string, maxsplit=0, flags=0)</code></td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td><code>sub(pattern, repl, string, count=0, flags=0)</code></td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用<code>count</code>指定替换的次数</td>
</tr>
<tr>
<td><code>fullmatch(pattern, string, flags=0)</code></td>
<td><code>match</code>函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td><code>findall(pattern, string, flags=0)</code></td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td><code>finditer(pattern, string, flags=0)</code></td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td><code>purge()</code></td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td><code>re.I</code> &#x2F; <code>re.IGNORECASE</code></td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td><code>re.M</code> &#x2F; <code>re.MULTILINE</code></td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 上面提到的<code>re</code>模块中的这些函数，实际开发中也可以用正则表达式对象（<code>Pattern</code>对象）的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过<code>compile</code>函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>
<p>正则表达式对象（<code>Pattern</code> 对象）的方法主要包括以下几个：</p>
<ol>
<li><strong><code>match</code></strong>: 尝试从字符串的开始位置匹配模式。</li>
<li><strong><code>search</code></strong>: 在字符串中搜索模式的第一次出现。</li>
<li><strong><code>findall</code></strong>: 返回字符串中所有非重叠匹配的列表。</li>
<li><strong><code>finditer</code></strong>: 返回一个迭代器，产生字符串中所有非重叠匹配的<code>Match</code>对象。</li>
<li><strong><code>split</code></strong>: 根据模式匹配分割字符串，并返回分割后的列表。</li>
<li><strong><code>sub</code></strong>: 使用替换字符串替换模式匹配的所有部分。</li>
<li><strong><code>subn</code></strong>: 执行和<code>sub</code>方法相同的操作，但返回一个元组，其中包含新字符串和替换总数。</li>
</ol>
<p>以下是每个方法的简单示例：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> re

<span class="hljs-comment"># 定义一个Pattern对象</span>
pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)	<span class="hljs-comment">#匹配数字</span>

<span class="hljs-comment"># match方法</span>
m = pattern.<span class="hljs-keyword">match</span>(<span class="hljs-string">&quot;123abc&quot;</span>)
<span class="hljs-keyword">if</span> m:
    <span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># 输出: 123</span>

<span class="hljs-comment"># search方法</span>
s = pattern.search(<span class="hljs-string">&quot;abc123&quot;</span>)
<span class="hljs-keyword">if</span> s:
    <span class="hljs-built_in">print</span>(s.group())  <span class="hljs-comment"># 输出: 123</span>

<span class="hljs-comment"># findall方法</span>
f = pattern.findall(<span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(f)  <span class="hljs-comment"># 输出: [&#x27;123&#x27;, &#x27;456&#x27;]</span>

<span class="hljs-comment"># finditer方法</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> pattern.finditer(<span class="hljs-string">&quot;abc123def456&quot;</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">match</span>.group())  <span class="hljs-comment"># 输出: 123  456</span>

<span class="hljs-comment"># split方法</span>
split_result = pattern.split(<span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(split_result)  <span class="hljs-comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;&#x27;]</span>

<span class="hljs-comment"># sub方法</span>
sub_result = pattern.sub(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(sub_result)  <span class="hljs-comment"># 输出: abc-def-</span>

<span class="hljs-comment"># subn方法</span>
subn_result = pattern.subn(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&quot;abc123def456&quot;</span>)
<span class="hljs-built_in">print</span>(subn_result)  <span class="hljs-comment"># 输出: (&#x27;abc-def-&#x27;, 2)</span></code></pre>

<p>这些方法提供了强大的文本处理能力，使正则表达式在字符串操作中非常有用。</p>
<h2 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h2><p>[python] <code>asyncio</code>模块是Python标准库中的一个库，用于编写并发代码。它主要用于构建异步I&#x2F;O操作，可以用来处理网络连接、文件读写等需要等待的任务。通过<code>asyncio</code>，你可以编写非阻塞代码，这样可以提高程序的效率和响应速度。以下是<code>asyncio</code>模块的一些主要功能和概念：</p>
<h3 id="主要功能和概念"><a href="#主要功能和概念" class="headerlink" title="主要功能和概念"></a>主要功能和概念</h3><ol>
<li><p><strong>事件循环</strong> (<code>Event Loop</code>):</p>
<ul>
<li><code>asyncio</code>的核心是事件循环。事件循环负责调度和执行异步任务。你可以通过<code>asyncio.get_event_loop()</code>获取当前的事件循环。</li>
</ul>
</li>
<li><p><strong>协程</strong> (<code>Coroutine</code>):</p>
<ul>
<li>协程是Python中实现异步编程的基础。协程通过<code>async def</code>定义，可以使用<code>await</code>关键字等待异步操作完成。</li>
</ul>
</li>
<li><p><strong>任务</strong> (<code>Task</code>):</p>
<ul>
<li>任务是对协程的进一步封装，使其可以被调度执行。你可以使用<code>asyncio.create_task()</code>或<code>loop.create_task()</code>来创建一个任务。</li>
</ul>
</li>
<li><p><strong>未来对象</strong> (<code>Future</code>):</p>
<ul>
<li><code>Future</code>对象是一个低级别的同步原语，表示一个将来可能完成的操作。通常不直接使用，而是通过更高级的任务和协程来间接使用。</li>
</ul>
</li>
<li><p><strong>异步I&#x2F;O操作</strong>:</p>
<ul>
<li><code>asyncio</code>提供了一组异步I&#x2F;O操作的API，如<code>asyncio.open_connection()</code>、<code>asyncio.start_server()</code>等，用于处理网络连接。</li>
</ul>
</li>
<li><p><strong>同步原语</strong>:</p>
<ul>
<li><code>asyncio</code>还提供了一些用于协程间同步的原语，如锁、事件、条件变量和信号量。</li>
</ul>
</li>
</ol>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的<code>asyncio</code>示例，展示如何定义和运行协程：</p>
<pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;World&quot;</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 创建多个任务</span>
    task1 = asyncio.create_task(say_hello())
    task2 = asyncio.create_task(say_hello())
    
    <span class="hljs-comment"># 等待所有任务完成</span>
    <span class="hljs-keyword">await</span> task1
    <span class="hljs-keyword">await</span> task2

<span class="hljs-comment"># 获取事件循环并运行主协程</span>
asyncio.run(main())</code></pre>

<h3 id="详细功能介绍"><a href="#详细功能介绍" class="headerlink" title="详细功能介绍"></a>详细功能介绍</h3><ol>
<li><p><strong>事件循环</strong>:</p>
 <pre><code class="hljs python">loop = asyncio.get_event_loop()  <span class="hljs-comment"># 获取事件循环</span>
loop.run_until_complete(main())  <span class="hljs-comment"># 运行直到主协程完成</span>
loop.close()  <span class="hljs-comment"># 关闭事件循环</span></code></pre>
</li>
<li><p><strong>协程</strong>:</p>
 <pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>():
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟I/O操作</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data&quot;</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    data = <span class="hljs-keyword">await</span> fetch_data()  <span class="hljs-comment"># 等待协程完成</span>
    <span class="hljs-built_in">print</span>(data)

asyncio.run(main())</code></pre>
</li>
<li><p><strong>任务</strong>:</p>
 <pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;World&quot;</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    task = asyncio.create_task(say_hello())  <span class="hljs-comment"># 创建任务</span>
    <span class="hljs-keyword">await</span> task  <span class="hljs-comment"># 等待任务完成</span>

asyncio.run(main())</code></pre>
</li>
<li><p><strong>同步原语</strong>:</p>
 <pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">lock</span>):
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Worker is working&quot;</span>)
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Worker is done&quot;</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    lock = asyncio.Lock()  <span class="hljs-comment"># 创建锁</span>
    <span class="hljs-keyword">await</span> asyncio.gather(worker(lock), worker(lock))  <span class="hljs-comment"># 并发运行两个工作协程</span>

asyncio.run(main())</code></pre></li>
</ol>
<p>通过<code>asyncio</code>模块，Python程序可以更高效地处理并发任务，特别是那些涉及大量I&#x2F;O操作的任务。它是Python异步编程的一个重要工具。</p>
<h2 id="Aiohttp库"><a href="#Aiohttp库" class="headerlink" title="Aiohttp库"></a>Aiohttp库</h2><p>Aiohttp 是一个用于 Python 编程的异步 HTTP 客户端和服务器库。它使用 Python 的 <code>asyncio</code> 库实现异步编程，从而允许处理大量并发请求而不阻塞程序执行。Aiohttp 的主要功能包括：</p>
<ol>
<li><p><strong>异步 HTTP 客户端</strong>：</p>
<ul>
<li>可以发送 HTTP 请求并异步接收响应。</li>
<li>支持 HTTP&#x2F;1.1 和 WebSocket 协议。</li>
<li>提供了丰富的功能，例如会话处理、cookie、代理等。</li>
</ul>
</li>
<li><p><strong>异步 HTTP 服务器</strong>：</p>
<ul>
<li>可以创建高效的异步 Web 服务器来处理 HTTP 请求。</li>
<li>支持路由、URL 参数、查询字符串、表单数据等。</li>
<li>提供了中间件、请求和响应对象等功能，便于处理和扩展。</li>
</ul>
</li>
<li><p><strong>WebSocket 支持</strong>：</p>
<ul>
<li>支持 WebSocket 协议，方便创建实时通信应用。</li>
<li>可以在客户端和服务器之间进行全双工通信。</li>
</ul>
</li>
</ol>

        </div>
        
            
        
        
    </div>
</article>

        
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/07/09/面对对象编程应用/" title="面向编程应用">
                    面向编程应用
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-07-09
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python基础/">Python基础</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <h2 id="面向对象编程应用"><a href="#面向对象编程应用" class="headerlink" title="面向对象编程应用"></a>面向对象编程应用</h2><p>面向对象编程对初学者来说不难理解但很难应用，虽然我们为大家总结过面向对象的三步走方法（定义类、创建对象、给对象发消息），但是说起来容易做起来难。<strong>大量的编程练习</strong>和<strong>阅读优质的代码</strong>可能是这个阶段最能够帮助到大家的两件事情。接下来我们还是通过经典的案例来剖析面向对象编程的知识，同时也通过这些案例把我们之前学过的 Python 知识都串联起来。</p>
<h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="案例1：扑克游戏。"><a href="#案例1：扑克游戏。" class="headerlink" title="案例1：扑克游戏。"></a>案例1：扑克游戏。</h4><blockquote>
<p><strong>说明</strong>：简单起见，我们的扑克只有52张牌（没有大小王），游戏需要将52张牌发到4个玩家的手上，每个玩家手上有13张牌，按照黑桃、红心、草花、方块的顺序和点数从小到大排列，暂时不实现其他的功能。</p>
</blockquote>
<p>使用面向对象编程方法，首先需要从问题的需求中找到对象并抽象出对应的<strong>类</strong>，此外还要找到<strong>对象的属性和行为</strong>。当然，这件事情并不是特别困难，我们可以从需求的描述中<strong>找出名词和动词</strong>，名词通常就是对象或者是对象的属性，而动词通常是对象的行为。扑克游戏中至少应该有三类对象，分别是<strong>牌、扑克和玩家</strong>，牌、扑克、玩家三个类也并不是孤立的。类和类之间的关系可以粗略的分为<strong>is-a关系（继承）</strong>、<strong>has-a关系（关联）</strong>和<strong>use-a关系（依赖）</strong>。很显然扑克和牌是has-a关系，因为一副扑克有（has-a）52张牌；玩家和牌之间不仅有关联关系还有依赖关系，因为玩家手上有（has-a）牌而且玩家使用了（use-a）牌。</p>
<ol>
<li><strong>牌（Card）</strong><ul>
<li>属性：<ul>
<li><strong>花色（suit）</strong>：黑桃、红心、草花、方块</li>
<li><strong>点数（rank）</strong>：1 到 13（A到K）</li>
</ul>
</li>
<li><strong>行为</strong>：牌本身在这个简化的例子中没有特殊行为，只是数据的集合。</li>
</ul>
</li>
<li><strong>扑克（Deck）</strong><ul>
<li>属性：<ul>
<li><strong>牌的集合（cards）</strong>：52张牌的列表</li>
</ul>
</li>
<li>行为：<ul>
<li><strong>洗牌（shuffle）</strong>：随机打乱牌的顺序</li>
<li><strong>发牌（deal）</strong>：将牌分发给玩家</li>
</ul>
</li>
</ul>
</li>
<li><strong>玩家（Player）</strong><ul>
<li>属性：<ul>
<li><strong>手牌（hand）</strong>：玩家手上的牌</li>
</ul>
</li>
<li>行为：<ul>
<li><strong>接牌（receive_card）</strong>：从扑克中获取一张牌并加入手牌</li>
<li><strong>显示手牌（show_hand）</strong>：显示玩家手上的牌</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>类与类之间的关系</strong></p>
<p>在面向对象编程中，类与类之间的关系可以分为几种常见类型：</p>
<ol>
<li><strong>is-a 关系（继承）</strong>：表示一种类是另一种类的特殊化。例如，如果我们有一种更通用的牌类（比如 <code>Card</code>）和一种特殊的牌类（比如 <code>JokerCard</code>），<code>JokerCard</code> 可以继承 <code>Card</code>，表示 <code>JokerCard</code> 是一种特殊的 <code>Card</code>。</li>
<li><strong>has-a 关系（关联）</strong>：表示一种类包含另一种类的实例。例如，一副扑克（<code>Deck</code>）包含52张牌（<code>Card</code>）。<code>Deck</code> 和 <code>Card</code> 之间的关系是 has-a 关系。</li>
<li><strong>use-a 关系（依赖）</strong>：表示一种类使用另一种类来完成某些功能。例如，玩家（<code>Player</code>）使用牌（<code>Card</code>）来进行游戏。玩家和牌之间既有 has-a 关系（玩家拥有牌），也有 use-a 关系（玩家使用牌）。</li>
</ol>
<p>牌的属性显而易见，有花色和点数。我们可以用0到3的四个数字来代表四种不同的花色，但是这样的代码可读性会非常糟糕，因为我们并不知道黑桃、红心、草花、方块跟0到3的数字的对应关系。如果一个变量的取值只有有限多个选项，我们可以使用枚举。与 C、Java 等语言不同的是，Python 中没有声明枚举类型的关键字，但是可以通过继承<code>enum</code>模块的<code>Enum</code>类来创建枚举类型，代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Suite</span>(<span class="hljs-title class_ inherited__">Enum</span>):
    <span class="hljs-string">&quot;&quot;&quot;花色(枚举)&quot;&quot;&quot;</span>
    SPADE, HEART, CLUB, DIAMOND = <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)</code></pre>

<p>通过上面的代码可以看出，定义枚举类型其实就是定义符号常量，如<code>SPADE</code>、<code>HEART</code>等。每个符号常量都有与之对应的值，这样表示黑桃就可以不用数字<code>0</code>，而是用<code>Suite.SPADE</code>；同理，表示方块可以不用数字<code>3</code>， 而是用<code>Suite.DIAMOND</code>。注意，使用符号常量肯定是优于使用字面常量的，因为能够读懂英文就能理解符号常量的含义，代码的可读性会提升很多。Python 中的枚举类型是可迭代类型，简单的说就是可以将枚举类型放到<code>for-in</code>循环中，依次取出每一个符号常量及其对应的值，如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">for</span> suite <span class="hljs-keyword">in</span> Suite:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;suite&#125;</span>: <span class="hljs-subst">&#123;suite.value&#125;</span>&#x27;</span>)</code></pre>

<p>接下来我们可以定义牌类。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span>:
    <span class="hljs-string">&quot;&quot;&quot;牌&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, suite, face</span>):
        <span class="hljs-variable language_">self</span>.suite = suite
        <span class="hljs-variable language_">self</span>.face = face

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        suites = <span class="hljs-string">&#x27;♠♥♣♦&#x27;</span>
        faces = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;suites[self.suite.value]&#125;</span><span class="hljs-subst">&#123;faces[self.face]&#125;</span>&#x27;</span>  <span class="hljs-comment"># 返回牌的花色和点数，[self.suite.value]就是对应列表中的值，例如返回suite[0]face[3] </span></code></pre>

<p>可以通过下面的代码来测试下<code>Card</code>类。</p>
<pre><code class="hljs Python">card1 = Card(Suite.SPADE, <span class="hljs-number">5</span>)
card2 = Card(Suite.HEART, <span class="hljs-number">13</span>)
<span class="hljs-built_in">print</span>(card1)  <span class="hljs-comment"># ♠5 </span>
<span class="hljs-built_in">print</span>(card2)  <span class="hljs-comment"># ♥K</span></code></pre>

<p>接下来我们定义扑克类。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> random


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Poker</span>:
    <span class="hljs-string">&quot;&quot;&quot;扑克&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.cards = [Card(suite, face) 	<span class="hljs-comment">#为列表生成式：[expression for item in iterable]</span>
                      <span class="hljs-keyword">for</span> suite <span class="hljs-keyword">in</span> Suite	<span class="hljs-comment">#嵌套的列表生成式，注意为一维列表</span>
                      <span class="hljs-keyword">for</span> face <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>)]  <span class="hljs-comment"># 52张牌构成的列表</span>
        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录发牌位置的属性</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;洗牌&quot;&quot;&quot;</span>
        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span>		<span class="hljs-comment"># 每次洗牌时重置发牌位置为0</span>
        random.shuffle(<span class="hljs-variable language_">self</span>.cards)  <span class="hljs-comment"># 通过random模块的shuffle函数实现随机乱序</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deal</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;发牌&quot;&quot;&quot;</span>
        card = <span class="hljs-variable language_">self</span>.cards[<span class="hljs-variable language_">self</span>.current]
        <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> card

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">has_next</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;还有没有牌可以发&quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.current &lt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.cards)</code></pre>

<blockquote>
<p>注意：<code>self.cards</code>是一维列表，这个<code>Card(suite, face) </code>是一种展示形式，并不是列表格式。</p>
<pre><code class="hljs python"><span class="hljs-variable language_">self</span>.cards = [
    Card(Suite.SPADE, <span class="hljs-number">1</span>), Card(Suite.SPADE, <span class="hljs-number">2</span>), ..., Card(Suite.SPADE, <span class="hljs-number">13</span>),
    Card(Suite.HEART, <span class="hljs-number">1</span>), Card(Suite.HEART, <span class="hljs-number">2</span>), ..., Card(Suite.HEART, <span class="hljs-number">13</span>),
    Card(Suite.CLUB, <span class="hljs-number">1</span>), Card(Suite.CLUB, <span class="hljs-number">2</span>), ..., Card(Suite.CLUB, <span class="hljs-number">13</span>),
    Card(Suite.DIAMOND, <span class="hljs-number">1</span>), Card(Suite.DIAMOND, <span class="hljs-number">2</span>), ..., Card(Suite.DIAMOND, <span class="hljs-number">13</span>)
]</code></pre>
</blockquote>
<p>可以通过下面的代码来测试下<code>Poker</code>类。</p>
<pre><code class="hljs Python">poker = Poker()
<span class="hljs-built_in">print</span>(poker.cards)  <span class="hljs-comment"># 洗牌前的牌</span>
poker.shuffle()
<span class="hljs-built_in">print</span>(poker.cards)  <span class="hljs-comment"># 洗牌后的牌</span></code></pre>

<p>定义玩家类。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>:
    <span class="hljs-string">&quot;&quot;&quot;玩家&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.cards = []  <span class="hljs-comment"># 玩家手上的牌</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_one</span>(<span class="hljs-params">self, card</span>):
        <span class="hljs-string">&quot;&quot;&quot;摸牌&quot;&quot;&quot;</span>
        <span class="hljs-variable language_">self</span>.cards.append(card)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrange</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;</span>
        <span class="hljs-variable language_">self</span>.cards.sort()</code></pre>

<p>创建四个玩家并将牌发到玩家的手上。</p>
<pre><code class="hljs Python">poker = Poker()
poker.shuffle()
players = [Player(<span class="hljs-string">&#x27;东邪&#x27;</span>), Player(<span class="hljs-string">&#x27;西毒&#x27;</span>), Player(<span class="hljs-string">&#x27;南帝&#x27;</span>), Player(<span class="hljs-string">&#x27;北丐&#x27;</span>)]
<span class="hljs-comment"># 将牌轮流发到每个玩家手上每人13张牌</span>
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>):
    <span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players:
        player.get_one(poker.deal())
<span class="hljs-comment"># 玩家整理手上的牌输出名字和手牌</span>
<span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players:
    player.arrange()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;player.name&#125;</span>: &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)
    <span class="hljs-built_in">print</span>(player.cards)</code></pre>

<p>执行上面的代码会在<code>player.arrange()</code>那里出现异常，因为<code>Player</code>的<code>arrange</code>方法使用了列表的<code>sort</code>对玩家手上的牌进行排序，排序需要比较两个<code>Card</code>对象的大小，但是Python不知道如何比较 <code>card1</code> 和 <code>card2</code>。所以就出现了<code>TypeError</code>异常，异常消息为：<code>&#39;&lt;&#39; not supported between instances of &#39;Card&#39; and &#39;Card&#39;</code>。</p>
<p>为了解决这个问题，我们可以对<code>Card</code>类的代码稍作修改，使得两个<code>Card</code>对象可以直接用<code>&lt;</code>进行大小的比较（可以理解为我们创建了一种比较方法）。这里用到技术叫<strong>运算符重载</strong>，Python 中要实现对<code>&lt;</code>运算符的重载，需要在类中添加一个名为<code>__lt__</code>的魔术方法。很显然，魔术方法<code>__lt__</code>中的<code>lt</code>是英文单词“less than”的缩写，以此类推，魔术方法<code>__gt__</code>对应<code>&gt;</code>运算符，魔术方法<code>__le__</code>对应<code>&lt;=</code>运算符，<code>__ge__</code>对应<code>&gt;=</code>运算符，<code>__eq__</code>对应<code>==</code>运算符，<code>__ne__</code>对应<code>!=</code>运算符。</p>
<p>修改后的<code>Card</code>类代码如下所示。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span>:
    <span class="hljs-string">&quot;&quot;&quot;牌&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, suite, face</span>):
        <span class="hljs-variable language_">self</span>.suite = suite
        <span class="hljs-variable language_">self</span>.face = face

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        suites = <span class="hljs-string">&#x27;♠♥♣♦&#x27;</span>
        faces = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;suites[self.suite.value]&#125;</span><span class="hljs-subst">&#123;faces[self.face]&#125;</span>&#x27;</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.suite == other.suite:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.face &lt; other.face   <span class="hljs-comment"># 花色相同比较点数的大小</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.suite.value &lt; other.suite.value   <span class="hljs-comment"># 花色不同比较花色对应的值</span></code></pre>

<blockquote>
<p><strong>说明：</strong> 大家可以尝试在上面代码的基础上写一个简单的扑克游戏，如21点游戏（Black Jack），游戏的规则可以自己在网上找一找。</p>
</blockquote>
<h4 id="案例2：工资结算系统。"><a href="#案例2：工资结算系统。" class="headerlink" title="案例2：工资结算系统。"></a>案例2：工资结算系统。</h4><blockquote>
<p><strong>要求</strong>：某公司有三种类型的员工，分别是部门经理、程序员和销售员。需要设计一个工资结算系统，根据提供的员工信息来计算员工的月薪。其中，部门经理的月薪是固定15000元；程序员按工作时间（以小时为单位）支付月薪，每小时200元；销售员的月薪由1800元底薪加上销售额5%的提成两部分构成。</p>
</blockquote>
<p>通过对上述需求的分析，可以看出部门经理、程序员、销售员都是员工，有相同的属性和行为，那么我们可以先设计一个名为<code>Employee</code>的父类，再通过继承的方式从这个父类派生出部门经理、程序员和销售员三个子类。很显然，后续的代码不会创建<code>Employee</code> 类的对象，因为我们需要的是具体的员工对象，所以这个类可以设计成专门用于继承的抽象类。Python 语言中没有定义抽象类的关键字，但是可以通过<code>abc</code>模块中名为<code>ABCMeta</code> 的元类来定义抽象类。关于元类的概念此处不展开讲解，当然大家不用纠结，照做即可。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>(metaclass=ABCMeta):
    <span class="hljs-string">&quot;&quot;&quot;员工&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">&quot;&quot;&quot;结算月薪&quot;&quot;&quot;</span>
        <span class="hljs-keyword">pass</span></code></pre>

<p>在上面的员工类中，有一个名为<code>get_salary</code>的方法用于结算月薪，但是由于还没有确定是哪一类员工，所以结算月薪虽然是员工的公共行为但这里却没有办法实现。对于暂时无法实现的方法，我们可以使用<code>abstractmethod</code>装饰器将其声明为抽象方法，所谓<strong>抽象方法就是只有声明没有实现的方法</strong>，<strong>声明这个方法是为了让子类去重写这个方法</strong>。接下来的代码展示了如何从员工类派生出部门经理、程序员、销售员这三个子类以及子类如何重写父类的抽象方法。</p>
<pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span>(<span class="hljs-title class_ inherited__">Employee</span>):
    <span class="hljs-string">&quot;&quot;&quot;部门经理&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">15000.0</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Programmer</span>(<span class="hljs-title class_ inherited__">Employee</span>):
    <span class="hljs-string">&quot;&quot;&quot;程序员&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, working_hour=<span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">super</span>().__init__(name)
        <span class="hljs-variable language_">self</span>.working_hour = working_hour

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> * <span class="hljs-variable language_">self</span>.working_hour


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Salesman</span>(<span class="hljs-title class_ inherited__">Employee</span>):
    <span class="hljs-string">&quot;&quot;&quot;销售员&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, sales=<span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">super</span>().__init__(name)
        <span class="hljs-variable language_">self</span>.sales = sales

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_salary</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">1800</span> + <span class="hljs-variable language_">self</span>.sales * <span class="hljs-number">0.05</span></code></pre>

<p>上面的<code>Manager</code>、<code>Programmer</code>、<code>Salesman</code>三个类都继承自<code>Employee</code>，三个类都分别重写了<code>get_salary</code>方法。<strong>重写就是子类对父类已有的方法重新做出实现</strong>。相信大家已经注意到了，三个子类中的<code>get_salary</code>各不相同，所以这个方法在程序运行时会产生<strong>多态行为</strong>，多态简单的说就是<strong>调用相同的方法</strong>，<strong>不同的子类对象做不同的事情</strong>。</p>
<p>我们通过下面的代码来完成这个工资结算系统，由于程序员和销售员需要分别录入本月的工作时间和销售额，所以在下面的代码中我们使用了 Python 内置的<code>isinstance</code>函数来判断员工对象的类型。我们之前讲过的<code>type</code>函数也能识别对象的类型，但是<code>isinstance</code>函数更加强大，因为它可以判断出一个对象是不是某个继承结构下的子类型，你可以简单的理解为<code>type</code>函数是对对象类型的精准匹配，而<code>isinstance</code>函数是对对象类型的模糊匹配。</p>
<pre><code class="hljs Python">emps = [Manager(<span class="hljs-string">&#x27;刘备&#x27;</span>), Programmer(<span class="hljs-string">&#x27;诸葛亮&#x27;</span>), Manager(<span class="hljs-string">&#x27;曹操&#x27;</span>), Programmer(<span class="hljs-string">&#x27;荀彧&#x27;</span>), Salesman(<span class="hljs-string">&#x27;张辽&#x27;</span>)]
<span class="hljs-keyword">for</span> emp <span class="hljs-keyword">in</span> emps:
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(emp, Programmer):
        emp.working_hour = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">f&#x27;请输入<span class="hljs-subst">&#123;emp.name&#125;</span>本月工作时间: &#x27;</span>))
    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(emp, Salesman):
        emp.sales = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">f&#x27;请输入<span class="hljs-subst">&#123;emp.name&#125;</span>本月销售额: &#x27;</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;emp.name&#125;</span>本月工资为: ￥<span class="hljs-subst">&#123;emp.get_salary():<span class="hljs-number">.2</span>f&#125;</span>元&#x27;</span>)</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向对象的编程思想非常的好，也符合人类的正常思维习惯，但是要想灵活运用面向对象编程中的抽象、封装、继承、多态需要长时间的积累和沉淀，这件事情无法一蹴而就，因为知识的积累本就是涓滴成河的过程。</p>

        </div>
        
            
        
        
    </div>
</article>

        
        <ul class="pagination clear">
    <span class="page-number current">1</span>
</ul>
    </section>
    
<section class="tool-area">

    <div class="toolbar">
        

        
        <div class="widget-post widget" style="order: 1 ">
            <h2 class="widget-title"><i class="fa fa-file-text"></i> 近期文章</h2>
            <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/">HTTP协议入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/Python%E6%A0%87%E5%87%86%E5%BA%93%E5%88%9D%E6%8E%A2/">Python标准库初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/XML%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">XML入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A1%88%E4%BE%8B/">分支和循环案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/">函数的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9C%E5%90%84%E7%B1%BB%E6%96%87%E4%BB%B6/">使用Python操作各类文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/">正则表达式入门</a></li></ul>
        </div>
        

        
        <div class="widget-tags widget" style="order: 2 ">
            <h2 class="widget-title"><i class="fa fa-tags"></i> 标签</h2>
            <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a>
        </div>
        

        
        <div class="widget-categories widget" style="order: 3 ">
            <h2 class="widget-title"><i class="fa fa-folder-open"></i> 分类</h2>
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E7%BB%BC%E5%90%88/">Python综合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xml/">Xml</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li></ul></li></ul>
        </div>
        

    </div>
</section>
</div>

    
        <footer class="footer">
	<p class="footer-intro">
		
		@2024 李梓卓的技术专栏.
	</p>
	<p class="footer-intro">
			Powered By <a href="https://hexo.io/zh-cn/" target="_blank">hexo</a>
			theme <a href="https://github.com/iengu/hexo-theme-mokusei" target="_blank">mokusei</a> by <a href="https://www.iengu.com" target="blank">iengu</a>
	</p>
</footer>




        <div class="extend-tools" id="extend-tools" style="display: none;">
    <ul>
        <li class="tools-returnTop" title="返回顶部"><i class="fa fa-angle-double-up"></i></li>
    </ul>
</div>

	</div>

	
<script src="/js/org/jquery.min.js"></script>

    
<script src="/js/extend.js"></script>

</body>
</html>